From 60c56e787ee7d67ab4e5da379d754958cf089a24 Mon Sep 17 00:00:00 2001
From: Ansuel Smith <ansuelsmth@gmail.com>
Date: Wed, 7 Apr 2021 01:14:26 +0200
Subject: [PATCH] linux: introduce multi-cpu dsa patch

Add support for multi-cpu dsa. This is a reworked version of the RFC patch proposed some time ago. By default the cpus are selected in a round-robin way and the command
'ip link set PORT link CPU_PORT' can be used to change the used cpu port at runtime.

Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
---
 ...net-dsa-allow_for_multiple_CPU_ports.patch | 216 ++++++++++++++++++
 ..._ndo_for_setting_the_iflink_property.patch | 153 +++++++++++++
 ..._netlink_for_changing_ports_CPU_port.patch | 145 ++++++++++++
 ...clude-net-add-dsa_cpu_ports-function.patch |  39 ++++
 4 files changed, 553 insertions(+)
 create mode 100644 target/linux/generic/hack-5.10/780-1-net-dsa-allow_for_multiple_CPU_ports.patch
 create mode 100644 target/linux/generic/hack-5.10/780-2-net-add_ndo_for_setting_the_iflink_property.patch
 create mode 100644 target/linux/generic/hack-5.10/780-3-net-dsa-implement_ndo_set_netlink_for_changing_ports_CPU_port.patch
 create mode 100644 target/linux/generic/hack-5.10/780-4-include-net-add-dsa_cpu_ports-function.patch

diff --git a/target/linux/generic/hack-5.10/780-1-net-dsa-allow_for_multiple_CPU_ports.patch b/target/linux/generic/hack-5.10/780-1-net-dsa-allow_for_multiple_CPU_ports.patch
new file mode 100644
index 000000000000..e1b9b4a27838
--- /dev/null
+++ b/target/linux/generic/hack-5.10/780-1-net-dsa-allow_for_multiple_CPU_ports.patch
@@ -0,0 +1,216 @@
+From mboxrd@z Thu Jan  1 00:00:00 1970
+Return-Path: <SRS0=lHAO=WU=vger.kernel.org=netdev-owner@kernel.org>
+X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
+	aws-us-west-2-korg-lkml-1.web.codeaurora.org
+X-Spam-Level: 
+X-Spam-Status: No, score=-9.9 required=3.0 tests=DKIM_SIGNED,DKIM_VALID,
+	DKIM_VALID_AU,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_PATCH,MAILING_LIST_MULTI,
+	SIGNED_OFF_BY,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT autolearn=ham
+	autolearn_force=no version=3.4.0
+Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
+	by smtp.lore.kernel.org (Postfix) with ESMTP id 98EBDC3A5A2
+	for <netdev@archiver.kernel.org>; Sat, 24 Aug 2019 02:43:07 +0000 (UTC)
+Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
+	by mail.kernel.org (Postfix) with ESMTP id 6168A2173B
+	for <netdev@archiver.kernel.org>; Sat, 24 Aug 2019 02:43:07 +0000 (UTC)
+Authentication-Results: mail.kernel.org;
+	dkim=pass (1024-bit key) header.d=nic.cz header.i=@nic.cz header.b="Kl8qU9Mx"
+Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
+        id S1726888AbfHXCnF (ORCPT <rfc822;netdev@archiver.kernel.org>);
+        Fri, 23 Aug 2019 22:43:05 -0400
+Received: from mail.nic.cz ([217.31.204.67]:37268 "EHLO mail.nic.cz"
+        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
+        id S1725807AbfHXCnD (ORCPT <rfc822;netdev@vger.kernel.org>);
+        Fri, 23 Aug 2019 22:43:03 -0400
+Received: from dellmb.labs.office.nic.cz (unknown [IPv6:2001:1488:fffe:6:cac7:3539:7f1f:463])
+        by mail.nic.cz (Postfix) with ESMTP id 94D1E140D1E;
+        Sat, 24 Aug 2019 04:42:59 +0200 (CEST)
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=nic.cz; s=default;
+        t=1566614579; bh=jPa21EsnWy9WksW68HSx/O+la2qm4ImIACY+K2cEnLY=;
+        h=From:To:Date;
+        b=Kl8qU9MxZdC3EQnTetDA7VbGXYIuwCO2zS6HinOo7XykIKQDlvB7jIUcH0FQLgG6T
+         BNf/aIsDASIL1PBSAlNynoTMSDf8m6I2Xo8auxQr4L6sslF683w8hY9PN7f+pYyL2R
+         FQs93FIJYSp5I2NCSktTxGFNumTvYPxA8lEqBaZo=
+From:   =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+To:     netdev@vger.kernel.org
+Cc:     Andrew Lunn <andrew@lunn.ch>,
+        Vivien Didelot <vivien.didelot@gmail.com>,
+        Florian Fainelli <f.fainelli@gmail.com>,
+        David Ahern <dsahern@gmail.com>,
+        Stephen Hemminger <stephen@networkplumber.org>,
+        =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Subject: [PATCH RFC net-next 1/3] net: dsa: allow for multiple CPU ports
+Date:   Sat, 24 Aug 2019 04:42:48 +0200
+Message-Id: <20190824024251.4542-2-marek.behun@nic.cz>
+X-Mailer: git-send-email 2.21.0
+In-Reply-To: <20190824024251.4542-1-marek.behun@nic.cz>
+References: <20190824024251.4542-1-marek.behun@nic.cz>
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+X-Virus-Scanned: clamav-milter 0.100.3 at mail.nic.cz
+X-Virus-Status: Clean
+Sender: netdev-owner@vger.kernel.org
+Precedence: bulk
+List-ID: <netdev.vger.kernel.org>
+X-Mailing-List: netdev@vger.kernel.org
+Archived-At: <https://lore.kernel.org/netdev/20190824024251.4542-2-marek.behun@nic.cz/>
+List-Archive: <https://lore.kernel.org/netdev/>
+List-Post: <mailto:netdev@vger.kernel.org>
+
+Allow for multiple CPU ports in a DSA switch tree. By default assign the
+CPU ports to user ports in a round robin way, ie. if there are two CPU
+ports connected to eth0 and eth1, and five user ports (lan1..lan5),
+assign them as:
+  lan1 <-> eth0
+  lan2 <-> eth1
+  lan3 <-> eth0
+  lan4 <-> eth1
+  lan5 <-> eth0
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ include/net/dsa.h |  5 +--
+ net/dsa/dsa2.c    | 84 +++++++++++++++++++++++++++++++----------------
+ 2 files changed, 58 insertions(+), 31 deletions(-)
+
+diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
+index 8c4eccb0cfe6..c5af89079a6b 100644
+@@ -211,36 +212,43 @@ static bool dsa_tree_setup_routing_table(struct dsa_switch_tree *dst)
+ 	return complete;
+ }
+ 
+-static struct dsa_port *dsa_tree_find_first_cpu(struct dsa_switch_tree *dst)
++static int dsa_tree_setup_default_cpus(struct dsa_switch_tree *dst)
+ {
+-	struct dsa_port *dp;
+-
++	struct dsa_port *cpu_dp, *dp, *first_cpu_dp = NULL, *last_cpu_dp = NULL;
++	
++	/* Find first and last CPU port */
+ 	list_for_each_entry(dp, &dst->ports, list)
+-		if (dsa_port_is_cpu(dp))
+-			return dp;
+-
+-	return NULL;
+-}
++		if (dsa_port_is_cpu(dp)) {
++			if (first_cpu_dp == NULL)
++				first_cpu_dp = dp;
+ 
+-static int dsa_tree_setup_default_cpu(struct dsa_switch_tree *dst)
+-{
+-	struct dsa_port *cpu_dp, *dp;
++			last_cpu_dp = dp;
++		}
+ 
+-	cpu_dp = dsa_tree_find_first_cpu(dst);
+-	if (!cpu_dp) {
++	if (first_cpu_dp == NULL) {
+ 		pr_err("DSA: tree %d has no CPU port\n", dst->index);
+ 		return -EINVAL;
+ 	}
+ 
+-	/* Assign the default CPU port to all ports of the fabric */
++	cpu_dp = first_cpu_dp;
++
++	/* Assign the CPU ports in round-robbin way to all ports of the fabric */
+ 	list_for_each_entry(dp, &dst->ports, list)
+-		if (dsa_port_is_user(dp) || dsa_port_is_dsa(dp))
++		if (dsa_port_is_user(dp) || dsa_port_is_dsa(dp)) {
+ 			dp->cpu_dp = cpu_dp;
+ 
++			if (cpu_dp == last_cpu_dp)
++				cpu_dp = first_cpu_dp;
++			else
++				while((cpu_dp = list_next_entry(cpu_dp, list)) != 0)
++					if (dsa_port_is_cpu(cpu_dp))
++						break;
++		}
++
+ 	return 0;
+ }
+ 
+-static void dsa_tree_teardown_default_cpu(struct dsa_switch_tree *dst)
++static void dsa_tree_teardown_default_cpus(struct dsa_switch_tree *dst)
+ {
+ 	struct dsa_port *dp;
+ 
+@@ -560,7 +577,7 @@ static void dsa_tree_teardown_switches(struct dsa_switch_tree *dst)
+ 		dsa_switch_teardown(dp->ds);
+ }
+ 
+-static int dsa_tree_setup_master(struct dsa_switch_tree *dst)
++static int dsa_tree_setup_masters(struct dsa_switch_tree *dst)
+ {
+ 	struct dsa_port *dp;
+ 	int err;
+@@ -569,14 +586,20 @@ static int dsa_tree_setup_master(struct dsa_switch_tree *dst)
+ 		if (dsa_port_is_cpu(dp)) {
+ 			err = dsa_master_setup(dp->master, dp);
+ 			if (err)
+-				return err;
++				goto teardown;
+ 		}
+ 	}
+ 
+ 	return 0;
++teardown:
++	list_for_each_entry(dp, &dst->ports, list)
++		if (dsa_port_is_cpu(dp))
++			dsa_master_teardown(dp->master);
++
++	return err;
+ }
+ 
+-static void dsa_tree_teardown_master(struct dsa_switch_tree *dst)
++static void dsa_tree_teardown_masters(struct dsa_switch_tree *dst)
+ {
+ 	struct dsa_port *dp;
+ 
+@@ -600,7 +623,7 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
+ 	if (!complete)
+ 		return 0;
+ 
+-	err = dsa_tree_setup_default_cpu(dst);
++	err = dsa_tree_setup_default_cpus(dst);
+ 	if (err)
+ 		return err;
+ 
+@@ -608,7 +631,7 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
+ 	if (err)
+ 		goto teardown_default_cpu;
+ 
+-	err = dsa_tree_setup_master(dst);
++	err = dsa_tree_setup_masters(dst);
+ 	if (err)
+ 		goto teardown_switches;
+ 
+@@ -621,7 +644,7 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
+ teardown_switches:
+ 	dsa_tree_teardown_switches(dst);
+ teardown_default_cpu:
+-	dsa_tree_teardown_default_cpu(dst);
++	dsa_tree_teardown_default_cpus(dst);
+ 
+ 	return err;
+ }
+@@ -633,11 +656,11 @@ static void dsa_tree_teardown(struct dsa_switch_tree *dst)
+ 	if (!dst->setup)
+ 		return;
+ 
+-	dsa_tree_teardown_master(dst);
++	dsa_tree_teardown_masters(dst);
+ 
+ 	dsa_tree_teardown_switches(dst);
+ 
+-	dsa_tree_teardown_default_cpu(dst);
++	dsa_tree_teardown_default_cpus(dst);
+ 
+ 	list_for_each_entry_safe(dl, next, &dst->rtable, list) {
+ 		list_del(&dl->list);
+
+-- 
+2.21.0
+
+
diff --git a/target/linux/generic/hack-5.10/780-2-net-add_ndo_for_setting_the_iflink_property.patch b/target/linux/generic/hack-5.10/780-2-net-add_ndo_for_setting_the_iflink_property.patch
new file mode 100644
index 000000000000..093b722c0cb5
--- /dev/null
+++ b/target/linux/generic/hack-5.10/780-2-net-add_ndo_for_setting_the_iflink_property.patch
@@ -0,0 +1,153 @@
+From mboxrd@z Thu Jan  1 00:00:00 1970
+Return-Path: <SRS0=lHAO=WU=vger.kernel.org=netdev-owner@kernel.org>
+X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
+	aws-us-west-2-korg-lkml-1.web.codeaurora.org
+X-Spam-Level: 
+X-Spam-Status: No, score=-9.9 required=3.0 tests=DKIM_SIGNED,DKIM_VALID,
+	DKIM_VALID_AU,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_PATCH,MAILING_LIST_MULTI,
+	SIGNED_OFF_BY,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT autolearn=ham
+	autolearn_force=no version=3.4.0
+Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
+	by smtp.lore.kernel.org (Postfix) with ESMTP id 9DBACC3A5A2
+	for <netdev@archiver.kernel.org>; Sat, 24 Aug 2019 02:43:05 +0000 (UTC)
+Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
+	by mail.kernel.org (Postfix) with ESMTP id 738DE2173B
+	for <netdev@archiver.kernel.org>; Sat, 24 Aug 2019 02:43:05 +0000 (UTC)
+Authentication-Results: mail.kernel.org;
+	dkim=pass (1024-bit key) header.d=nic.cz header.i=@nic.cz header.b="Nu6Or/RA"
+Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
+        id S1726852AbfHXCnE (ORCPT <rfc822;netdev@archiver.kernel.org>);
+        Fri, 23 Aug 2019 22:43:04 -0400
+Received: from mail.nic.cz ([217.31.204.67]:37276 "EHLO mail.nic.cz"
+        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
+        id S1725917AbfHXCnC (ORCPT <rfc822;netdev@vger.kernel.org>);
+        Fri, 23 Aug 2019 22:43:02 -0400
+Received: from dellmb.labs.office.nic.cz (unknown [IPv6:2001:1488:fffe:6:cac7:3539:7f1f:463])
+        by mail.nic.cz (Postfix) with ESMTP id B6AD9140D20;
+        Sat, 24 Aug 2019 04:42:59 +0200 (CEST)
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=nic.cz; s=default;
+        t=1566614579; bh=MugrABbJ8AsshZDatXz+1ocRDwPULL+0ZzKYCe8l2mE=;
+        h=From:To:Date;
+        b=Nu6Or/RAmhsH+sDbnw7+YKz9nZiF3Mdxpgf/4O30gloicSpv1+tz0tKWgiq51aUv9
+         VXCZbGHqdv7a9DO3bcKTxYiYAn54nKRboIdvBEQit+hUZzBJOBajBIJcTvXZKYP6mT
+         P4FcXHMpLC4KPBaR+8jT+EcHK1MmyxprksBnjjMc=
+From:   =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+To:     netdev@vger.kernel.org
+Cc:     Andrew Lunn <andrew@lunn.ch>,
+        Vivien Didelot <vivien.didelot@gmail.com>,
+        Florian Fainelli <f.fainelli@gmail.com>,
+        David Ahern <dsahern@gmail.com>,
+        Stephen Hemminger <stephen@networkplumber.org>,
+        =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Subject: [PATCH RFC net-next 2/3] net: add ndo for setting the iflink property
+Date:   Sat, 24 Aug 2019 04:42:49 +0200
+Message-Id: <20190824024251.4542-3-marek.behun@nic.cz>
+X-Mailer: git-send-email 2.21.0
+In-Reply-To: <20190824024251.4542-1-marek.behun@nic.cz>
+References: <20190824024251.4542-1-marek.behun@nic.cz>
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+X-Virus-Scanned: clamav-milter 0.100.3 at mail.nic.cz
+X-Virus-Status: Clean
+Sender: netdev-owner@vger.kernel.org
+Precedence: bulk
+List-ID: <netdev.vger.kernel.org>
+X-Mailing-List: netdev@vger.kernel.org
+Archived-At: <https://lore.kernel.org/netdev/20190824024251.4542-3-marek.behun@nic.cz/>
+List-Archive: <https://lore.kernel.org/netdev/>
+List-Post: <mailto:netdev@vger.kernel.org>
+
+In DSA the iflink value is used to report to which CPU port a given
+switch port is connected to. Since we want to support multi-CPU DSA, we
+want the user to be able to change this value.
+
+Add ndo_set_iflink method into the ndo strucutre to be a pair to
+ndo_get_iflink. Also create dev_set_iflink and call this from the
+netlink code, so that userspace can change the iflink value.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ include/linux/netdevice.h |  5 +++++
+ net/core/dev.c            | 15 +++++++++++++++
+ net/core/rtnetlink.c      |  7 +++++++
+ 3 files changed, 27 insertions(+)
+
+diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
+index 55ac223553f8..45eeb6da8583 100644
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1201,6 +1201,8 @@ struct tlsdev_ops;
+  *	TX queue.
+  * int (*ndo_get_iflink)(const struct net_device *dev);
+  *	Called to get the iflink value of this device.
++ * int (*ndo_set_iflink)(struct net_device *dev, int iflink);
++ *	Called to set the iflink value of this device.
+  * void (*ndo_change_proto_down)(struct net_device *dev,
+  *				 bool proto_down);
+  *	This function is used to pass protocol port error state information
+@@ -1415,6 +1417,8 @@ struct net_device_ops {
+ 						      int queue_index,
+ 						      u32 maxrate);
+ 	int			(*ndo_get_iflink)(const struct net_device *dev);
++	int			(*ndo_set_iflink)(struct net_device *dev,
++						  int iflink);
+ 	int			(*ndo_change_proto_down)(struct net_device *dev,
+ 							 bool proto_down);
+ 	int			(*ndo_fill_metadata_dst)(struct net_device *dev,
+@@ -2606,6 +2610,7 @@ void dev_add_offload(struct packet_offload *po);
+ void dev_remove_offload(struct packet_offload *po);
+ 
+ int dev_get_iflink(const struct net_device *dev);
++int dev_set_iflink(struct net_device *dev, int iflink);
+ int dev_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb);
+ struct net_device *__dev_get_by_flags(struct net *net, unsigned short flags,
+ 				      unsigned short mask);
+diff --git a/net/core/dev.c b/net/core/dev.c
+index 49589ed2018d..966bab196694 100644
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -693,6 +693,21 @@ int dev_get_iflink(const struct net_device *dev)
+ }
+ EXPORT_SYMBOL(dev_get_iflink);
+ 
++/**
++ *	dev_set_iflink - set 'iflink' value of an interface
++ *	@dev: target interface
++ *	@iflink: new value
++ *
++ *	Change the interface to which this interface is linked to.
++ */
++int dev_set_iflink(struct net_device *dev, int iflink)
++{
++	if (dev->netdev_ops && dev->netdev_ops->ndo_set_iflink)
++		return dev->netdev_ops->ndo_set_iflink(dev, iflink);
++
++	return -EOPNOTSUPP;
++}
++
+ /**
+  *	dev_fill_metadata_dst - Retrieve tunnel egress information.
+  *	@dev: targeted interface
+diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
+index 1ee6460f8275..106d5e23ae6f 100644
+--- a/net/core/rtnetlink.c
++++ b/net/core/rtnetlink.c
+@@ -2507,6 +2507,13 @@ static int do_setlink(const struct sk_buff *skb,
+ 		status |= DO_SETLINK_MODIFIED;
+ 	}
+ 
++	if (tb[IFLA_LINK]) {
++		err = dev_set_iflink(dev, nla_get_u32(tb[IFLA_LINK]));
++		if (err)
++			goto errout;
++		status |= DO_SETLINK_MODIFIED;
++	}
++
+ 	if (tb[IFLA_CARRIER]) {
+ 		err = dev_change_carrier(dev, nla_get_u8(tb[IFLA_CARRIER]));
+ 		if (err)
+-- 
+2.21.0
+
+
diff --git a/target/linux/generic/hack-5.10/780-3-net-dsa-implement_ndo_set_netlink_for_changing_ports_CPU_port.patch b/target/linux/generic/hack-5.10/780-3-net-dsa-implement_ndo_set_netlink_for_changing_ports_CPU_port.patch
new file mode 100644
index 000000000000..69aebadeabf4
--- /dev/null
+++ b/target/linux/generic/hack-5.10/780-3-net-dsa-implement_ndo_set_netlink_for_changing_ports_CPU_port.patch
@@ -0,0 +1,145 @@
+From mboxrd@z Thu Jan  1 00:00:00 1970
+Return-Path: <SRS0=lHAO=WU=vger.kernel.org=netdev-owner@kernel.org>
+X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
+	aws-us-west-2-korg-lkml-1.web.codeaurora.org
+X-Spam-Level: 
+X-Spam-Status: No, score=-9.9 required=3.0 tests=DKIM_SIGNED,DKIM_VALID,
+	DKIM_VALID_AU,HEADER_FROM_DIFFERENT_DOMAINS,INCLUDES_PATCH,MAILING_LIST_MULTI,
+	SIGNED_OFF_BY,SPF_HELO_NONE,SPF_PASS,USER_AGENT_GIT autolearn=ham
+	autolearn_force=no version=3.4.0
+Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
+	by smtp.lore.kernel.org (Postfix) with ESMTP id B6EF9C3A5A2
+	for <netdev@archiver.kernel.org>; Sat, 24 Aug 2019 02:43:09 +0000 (UTC)
+Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
+	by mail.kernel.org (Postfix) with ESMTP id 8DC852173B
+	for <netdev@archiver.kernel.org>; Sat, 24 Aug 2019 02:43:09 +0000 (UTC)
+Authentication-Results: mail.kernel.org;
+	dkim=pass (1024-bit key) header.d=nic.cz header.i=@nic.cz header.b="LOMQONxV"
+Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
+        id S1726936AbfHXCnH (ORCPT <rfc822;netdev@archiver.kernel.org>);
+        Fri, 23 Aug 2019 22:43:07 -0400
+Received: from mail.nic.cz ([217.31.204.67]:37288 "EHLO mail.nic.cz"
+        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
+        id S1725924AbfHXCnC (ORCPT <rfc822;netdev@vger.kernel.org>);
+        Fri, 23 Aug 2019 22:43:02 -0400
+Received: from dellmb.labs.office.nic.cz (unknown [IPv6:2001:1488:fffe:6:cac7:3539:7f1f:463])
+        by mail.nic.cz (Postfix) with ESMTP id D9A45140D23;
+        Sat, 24 Aug 2019 04:42:59 +0200 (CEST)
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=nic.cz; s=default;
+        t=1566614580; bh=AC+PVQwA6Fix9qcvNMGUHHTWu5CWtzFdGlYjHQ3j5AQ=;
+        h=From:To:Date;
+        b=LOMQONxVq2PFB4CLqpcuBlTBtVaCwpHmEGDYOjWDWTq0PhBYF/GXGsjK8VHv+kbjj
+         fQ9bsLsqog0Ln0Zi9M04t4krFY8xbQySLesWaQGbTjc2coKXUwCvsRH8Z70TLUuz8C
+         sgnXbNcMR6nWd8S/InLWwiTOlkMeAz3jX0ZIw8NE=
+From:   =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+To:     netdev@vger.kernel.org
+Cc:     Andrew Lunn <andrew@lunn.ch>,
+        Vivien Didelot <vivien.didelot@gmail.com>,
+        Florian Fainelli <f.fainelli@gmail.com>,
+        David Ahern <dsahern@gmail.com>,
+        Stephen Hemminger <stephen@networkplumber.org>,
+        =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Subject: [PATCH RFC net-next 3/3] net: dsa: implement ndo_set_netlink for changing port's CPU port
+Date:   Sat, 24 Aug 2019 04:42:50 +0200
+Message-Id: <20190824024251.4542-4-marek.behun@nic.cz>
+X-Mailer: git-send-email 2.21.0
+In-Reply-To: <20190824024251.4542-1-marek.behun@nic.cz>
+References: <20190824024251.4542-1-marek.behun@nic.cz>
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+X-Virus-Scanned: clamav-milter 0.100.3 at mail.nic.cz
+X-Virus-Status: Clean
+Sender: netdev-owner@vger.kernel.org
+Precedence: bulk
+List-ID: <netdev.vger.kernel.org>
+X-Mailing-List: netdev@vger.kernel.org
+Archived-At: <https://lore.kernel.org/netdev/20190824024251.4542-4-marek.behun@nic.cz/>
+List-Archive: <https://lore.kernel.org/netdev/>
+List-Post: <mailto:netdev@vger.kernel.org>
+
+Implement ndo_set_iflink for DSA slave device. In multi-CPU port setup
+this should be used to change to which CPU destination port a given port
+should be connected.
+
+This adds a new operation into the DSA switch operations structure,
+port_change_cpu_port. A driver implementing this function has the
+ability to change CPU destination port of a given port.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ include/net/dsa.h |  6 ++++++
+ net/dsa/slave.c   | 35 +++++++++++++++++++++++++++++++++++
+ 2 files changed, 41 insertions(+)
+
+diff --git a/include/net/dsa.h b/include/net/dsa.h
+index 64bd70608f2f..4f3f0032b886 100644
+--- a/include/net/dsa.h
++++ b/include/net/dsa.h
+@@ -545,6 +545,12 @@ struct dsa_switch_ops {
+ 	int	(*port_change_mtu)(struct dsa_switch *ds, int port,
+ 				   int new_mtu);
+ 	int	(*port_max_mtu)(struct dsa_switch *ds, int port);
++
++	/*
++	 * Multi-CPU port support
++	 */
++	int	(*port_change_cpu_port)(struct dsa_switch *ds, int port,
++					struct dsa_port *new_cpu_dp);
+ };
+ 
+ struct dsa_switch_driver {
+diff --git a/net/dsa/slave.c b/net/dsa/slave.c
+index 33f41178afcc..bafaadeca912 100644
+--- a/net/dsa/slave.c
++++ b/net/dsa/slave.c
+@@ -64,6 +64,37 @@ static int dsa_slave_get_iflink(const struct net_device *dev)
+ 	return dsa_slave_to_master(dev)->ifindex;
+ }
+ 
++static int dsa_slave_set_iflink(struct net_device *dev, int iflink)
++{
++	struct net_device *master = dsa_slave_to_master(dev);
++	struct dsa_port *dp = dsa_slave_to_port(dev);
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct net_device *new_cpu_dev;
++	struct dsa_port *new_cpu_dp;
++	int err;
++
++	new_cpu_dev = dev_get_by_index(dev_net(dev), iflink);
++	if (!new_cpu_dev)
++		return -ENODEV;
++
++	new_cpu_dp = new_cpu_dev->dsa_ptr;
++	if (!new_cpu_dp)
++		return -EINVAL;
++
++	/* new CPU port has to be on the same switch tree */
++	if (new_cpu_dp->dst != dp->cpu_dp->dst)
++		return -EINVAL;
++
++	if (ether_addr_equal(dev->dev_addr, master->dev_addr))
++	 	eth_hw_addr_inherit(dev, new_cpu_dev);
++
++	/* should this be done atomically? */
++	dp->cpu_dp = new_cpu_dp;
++	p->xmit = new_cpu_dp->tag_ops->xmit;
++
++	return 0;
++}
++
+ static int dsa_slave_open(struct net_device *dev)
+ {
+ 	struct net_device *master = dsa_slave_to_master(dev);
+@@ -1176,6 +1210,7 @@ static const struct net_device_ops dsa_slave_netdev_ops = {
+ 	.ndo_fdb_dump		= dsa_slave_fdb_dump,
+ 	.ndo_do_ioctl		= dsa_slave_ioctl,
+ 	.ndo_get_iflink		= dsa_slave_get_iflink,
++	.ndo_set_iflink		= dsa_slave_set_iflink,
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ 	.ndo_netpoll_setup	= dsa_slave_netpoll_setup,
+ 	.ndo_netpoll_cleanup	= dsa_slave_netpoll_cleanup,
+-- 
+2.21.0
+
+
diff --git a/target/linux/generic/hack-5.10/780-4-include-net-add-dsa_cpu_ports-function.patch b/target/linux/generic/hack-5.10/780-4-include-net-add-dsa_cpu_ports-function.patch
new file mode 100644
index 000000000000..b41e9178fc34
--- /dev/null
+++ b/target/linux/generic/hack-5.10/780-4-include-net-add-dsa_cpu_ports-function.patch
@@ -0,0 +1,39 @@
+From 2bf13a906ce96f67eb292c8e519c6d2215501d82 Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Sun, 4 Apr 2021 12:58:50 +0200
+Subject: [PATCH 1/2] include: net: add dsa_cpu_ports function
+
+dsa_cpu_ports can be useful for switch that has multiple cpu port to
+retrieve the cpu mask for ACL and bridge table.
+
+Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
+---
+ include/net/dsa.h | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+diff --git a/include/net/dsa.h b/include/net/dsa.h
+index 4e60d2610f20..9b34273b29c2 100644
+--- a/include/net/dsa.h
++++ b/include/net/dsa.h
+@@ -382,6 +382,18 @@ static inline u32 dsa_user_ports(struct dsa_switch *ds)
+ 	return mask;
+ }
+ 
++static inline u32 dsa_cpu_ports(struct dsa_switch *ds)
++{
++	u32 mask = 0;
++	int p;
++
++	for (p = 0; p < ds->num_ports; p++)
++		if (dsa_is_cpu_port(ds, p))
++			mask |= BIT(p);
++
++	return mask;
++}
++
+ /* Return the local port used to reach an arbitrary switch device */
+ static inline unsigned int dsa_routing_port(struct dsa_switch *ds, int device)
+ {
+-- 
+2.30.2
+
