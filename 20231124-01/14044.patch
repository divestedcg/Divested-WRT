From 5f0dbd24bf9b5ec1d1533a4536c3d416676f7e21 Mon Sep 17 00:00:00 2001
From: Michael Trinidad <trinidude4@hotmail.com>
Date: Tue, 21 Nov 2023 21:46:27 -0500
Subject: [PATCH] mwlwifi: update to version 10.4.10-20231120

Upstream PR 416 improvements:
 -AMPDU Optimization of priority calculation. (8864/8897)
 -8864/8897 fix wpa3
 -Add cypher suite to driver capabilities (all chip)
 -Alignment of pcie_tx_ctrl* (all chip)
 -"feature" normalization for all chips (all chip)
 -Add modprobe parameters (all chip)
 -fix monitoring (all chip)
 -Code separation by chipset (8864/8897 <=> 8997)
 -dump_prob decommissioning (8864/8897/8997)
 -fix amsdu high ping latency (8864/8897/8997)
 -drop debug info in hostcmd_get_hw_spec() (8864/8897)
 -Add wcb_base in debug info (8864)
 -Rewrite AMSDU packets (8864/8897/8997)
 -debug rewrite output mwl_debugfs_sta_read (all chip)
 -Improved encryption interoperability (8864/8897/8997)
 -factorization encrypted packet test (8864/8897/8997)
 -Change 88W8864 firmware to 7.2.9.27 (8864/8897)
 -Fix the AMPDU session lifecycle (8864/8897/8997)
 -Remove the tx done packets mechanism (8864/8897)

Signed-off-by: Michael Trinidad <trinidude4@hotmail.com>
---
 package/kernel/mwlwifi/Makefile               |   8 +-
 ...mpilation-warning-with-64-bit-system.patch |  39 +--
 ...CIe-DT-node-null-pointer-dereference.patch |   2 +-
 .../mwlwifi/patches/005-mac80211_update.patch | 201 ++++++-------
 ...nd-get_fs-calls-from-PCIe-for-Kenel-.patch |   8 +-
 ...-the-deprecated-pci-dma-compat.h-API.patch | 271 +++++++++++-------
 6 files changed, 300 insertions(+), 229 deletions(-)

diff --git a/package/kernel/mwlwifi/Makefile b/package/kernel/mwlwifi/Makefile
index cd1a1b2387368..9244f656c8f02 100644
--- a/package/kernel/mwlwifi/Makefile
+++ b/package/kernel/mwlwifi/Makefile
@@ -8,16 +8,16 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=mwlwifi
-PKG_RELEASE=2
+PKG_RELEASE=1
 
 PKG_LICENSE:=ISC
 PKG_LICENSE_FILES:=
 
 PKG_SOURCE_URL:=https://github.com/kaloz/mwlwifi
 PKG_SOURCE_PROTO:=git
-PKG_SOURCE_DATE:=2023-04-29
-PKG_SOURCE_VERSION:=6a436714d2ea0d0adf39fc4d7d45e6a17fcc9371
-PKG_MIRROR_HASH:=dcc320a8f859b732ff65c7ded0b5199a625bfba05a775a6bed15ed3c10cb2748
+PKG_SOURCE_DATE:=2023-11-20
+PKG_SOURCE_VERSION:=2a5a4ae31a2ad1b432a1dcb6ef6c3298e3330b2c
+PKG_MIRROR_HASH:=b1151051ed6eba063c05916d8dbc4f03f804772d217e8c65b7baa263ded7a961
 
 PKG_MAINTAINER:=Imre Kaloz <kaloz@openwrt.org>
 PKG_BUILD_PARALLEL:=1
diff --git a/package/kernel/mwlwifi/patches/001-Fix-compilation-warning-with-64-bit-system.patch b/package/kernel/mwlwifi/patches/001-Fix-compilation-warning-with-64-bit-system.patch
index 8e71918cf3f82..80e708a5e18ae 100644
--- a/package/kernel/mwlwifi/patches/001-Fix-compilation-warning-with-64-bit-system.patch
+++ b/package/kernel/mwlwifi/patches/001-Fix-compilation-warning-with-64-bit-system.patch
@@ -117,11 +117,9 @@ Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
  hif/pcie/tx_ndp.c | 2 +-
  4 files changed, 5 insertions(+), 5 deletions(-)
 
-diff --git a/debugfs.c b/debugfs.c
-index 39b09fd..42efd28 100644
 --- a/debugfs.c
 +++ b/debugfs.c
-@@ -1332,7 +1332,7 @@ done:
+@@ -1342,7 +1342,7 @@ done:
  				 priv->reg_value);
  	else
  		len += scnprintf(p + len, size - len,
@@ -130,11 +128,9 @@ index 39b09fd..42efd28 100644
  				 ret, priv->reg_type, priv->reg_offset,
  				 priv->reg_value);
  
-diff --git a/hif/fwcmd.c b/hif/fwcmd.c
-index 376b58f..582c8d2 100644
 --- a/hif/fwcmd.c
 +++ b/hif/fwcmd.c
-@@ -3604,7 +3604,7 @@ int mwl_fwcmd_get_fw_core_dump(struct ieee80211_hw *hw,
+@@ -3623,7 +3623,7 @@ int mwl_fwcmd_get_fw_core_dump(struct ie
  	core_dump->size_kb = pcmd->cmd_data.coredump.size_kb;
  	core_dump->flags = pcmd->cmd_data.coredump.flags;
  	memcpy(buff,
@@ -143,11 +139,20 @@ index 376b58f..582c8d2 100644
  	       sizeof(struct hostcmd_cmd_get_fw_core_dump) -
  	       sizeof(struct hostcmd_cmd_get_fw_core_dump_)),
  	       MAX_CORE_DUMP_BUFFER);
-diff --git a/hif/pcie/pcie.c b/hif/pcie/pcie.c
-index 24453b6..5b6c633 100644
+--- a/hif/pcie/8964/tx_ndp.c
++++ b/hif/pcie/8964/tx_ndp.c
+@@ -336,7 +336,7 @@ int pcie_tx_init_ndp(struct ieee80211_hw
+ 
+ 	if (sizeof(struct pcie_tx_ctrl_ndp) >
+ 	    sizeof(tx_info->driver_data)) {
+-		wiphy_err(hw->wiphy, "driver data is not enough: %d (%d)\n",
++		wiphy_err(hw->wiphy, "driver data is not enough: %zu (%zu)\n",
+ 			  sizeof(struct pcie_tx_ctrl_ndp),
+ 			  sizeof(tx_info->driver_data));
+ 		return -ENOMEM;
 --- a/hif/pcie/pcie.c
 +++ b/hif/pcie/pcie.c
-@@ -1320,8 +1320,8 @@ static void pcie_bf_mimo_ctrl_decode(struct mwl_priv *priv,
+@@ -1464,8 +1464,8 @@ static void pcie_bf_mimo_ctrl_decode(str
  			       &fp_data->f_pos);
  		filp_close(fp_data, current->files);
  	} else {
@@ -158,19 +163,3 @@ index 24453b6..5b6c633 100644
  	}
  
  #if LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
-diff --git a/hif/pcie/tx_ndp.c b/hif/pcie/tx_ndp.c
-index 6758cde..3140a2e 100644
---- a/hif/pcie/tx_ndp.c
-+++ b/hif/pcie/tx_ndp.c
-@@ -335,7 +335,7 @@ int pcie_tx_init_ndp(struct ieee80211_hw *hw)
- 
- 	if (sizeof(struct pcie_tx_ctrl_ndp) >
- 	    sizeof(tx_info->status.status_driver_data)) {
--		wiphy_err(hw->wiphy, "driver data is not enough: %d (%d)\n",
-+		wiphy_err(hw->wiphy, "driver data is not enough: %zu (%zu)\n",
- 			  sizeof(struct pcie_tx_ctrl_ndp),
- 			  sizeof(tx_info->status.status_driver_data));
- 		return -ENOMEM;
--- 
-2.39.2
-
diff --git a/package/kernel/mwlwifi/patches/004-mwlwifi-fix-PCIe-DT-node-null-pointer-dereference.patch b/package/kernel/mwlwifi/patches/004-mwlwifi-fix-PCIe-DT-node-null-pointer-dereference.patch
index 3d9ec4dcfb3ac..f37d2f8171a8d 100644
--- a/package/kernel/mwlwifi/patches/004-mwlwifi-fix-PCIe-DT-node-null-pointer-dereference.patch
+++ b/package/kernel/mwlwifi/patches/004-mwlwifi-fix-PCIe-DT-node-null-pointer-dereference.patch
@@ -19,7 +19,7 @@ Signed-off-by: Robert Marko <robert.marko@sartura.hr>
 
 --- a/hif/pcie/pcie.c
 +++ b/hif/pcie/pcie.c
-@@ -573,7 +573,8 @@ static struct device_node *pcie_get_devi
+@@ -685,7 +685,8 @@ static struct device_node *pcie_get_devi
  	struct device_node *dev_node;
  
  	dev_node = pci_bus_to_OF_node(pcie_priv->pdev->bus);
diff --git a/package/kernel/mwlwifi/patches/005-mac80211_update.patch b/package/kernel/mwlwifi/patches/005-mac80211_update.patch
index c11cf8c9469d4..92a8f2f70fd9c 100644
--- a/package/kernel/mwlwifi/patches/005-mac80211_update.patch
+++ b/package/kernel/mwlwifi/patches/005-mac80211_update.patch
@@ -1,6 +1,6 @@
 --- a/core.c
 +++ b/core.c
-@@ -706,7 +706,7 @@ static void mwl_chnl_switch_event(struct
+@@ -718,7 +718,7 @@ static void mwl_chnl_switch_event(struct
  		vif = container_of((void *)mwl_vif, struct ieee80211_vif,
  				   drv_priv);
  
@@ -11,7 +11,7 @@
  	spin_unlock_bh(&priv->vif_lock);
 --- a/debugfs.c
 +++ b/debugfs.c
-@@ -455,9 +455,9 @@ static ssize_t mwl_debugfs_vif_read(stru
+@@ -498,9 +498,9 @@ static ssize_t mwl_debugfs_vif_read(stru
  		switch (vif->type) {
  		case NL80211_IFTYPE_AP:
  			len += scnprintf(p + len, size - len, "type: ap\n");
@@ -24,7 +24,7 @@
  			len += scnprintf(p + len, size - len,
  					 "ssid: %s\n", ssid);
  			len += scnprintf(p + len, size - len,
-@@ -479,8 +479,8 @@ static ssize_t mwl_debugfs_vif_read(stru
+@@ -522,8 +522,8 @@ static ssize_t mwl_debugfs_vif_read(stru
  					 "type: unknown\n");
  			break;
  		}
@@ -35,62 +35,58 @@
  			len += scnprintf(p + len, size - len,
  					 "channel: %d: width: %d\n",
  					 chan_def->chan->hw_value,
-@@ -564,28 +564,28 @@ static ssize_t mwl_debugfs_sta_read(stru
- 					 "amsdu cap: 0x%02x\n",
- 					 sta_info->amsdu_ctrl.cap);
- 		}
--		if (sta->ht_cap.ht_supported) {
-+		if (sta->deflink.ht_cap.ht_supported) {
- 			len += scnprintf(p + len, size - len,
- 					 "ht_cap: 0x%04x, ampdu: %02x, %02x\n",
--					 sta->ht_cap.cap,
--					 sta->ht_cap.ampdu_factor,
--					 sta->ht_cap.ampdu_density);
-+					 sta->deflink.ht_cap.cap,
-+					 sta->deflink.ht_cap.ampdu_factor,
-+					 sta->deflink.ht_cap.ampdu_density);
- 			len += scnprintf(p + len, size - len,
- 					 "rx_mask: 0x%02x, %02x, %02x, %02x\n",
--					 sta->ht_cap.mcs.rx_mask[0],
--					 sta->ht_cap.mcs.rx_mask[1],
--					 sta->ht_cap.mcs.rx_mask[2],
--					 sta->ht_cap.mcs.rx_mask[3]);
-+					 sta->deflink.ht_cap.mcs.rx_mask[0],
-+					 sta->deflink.ht_cap.mcs.rx_mask[1],
-+					 sta->deflink.ht_cap.mcs.rx_mask[2],
-+					 sta->deflink.ht_cap.mcs.rx_mask[3]);
- 		}
--		if (sta->vht_cap.vht_supported) {
-+		if (sta->deflink.vht_cap.vht_supported) {
- 			len += scnprintf(p + len, size - len,
- 					 "vht_cap: 0x%08x, mcs: %02x, %02x\n",
--					 sta->vht_cap.cap,
--					 sta->vht_cap.vht_mcs.rx_mcs_map,
--					 sta->vht_cap.vht_mcs.tx_mcs_map);
-+					 sta->deflink.vht_cap.cap,
-+					 sta->deflink.vht_cap.vht_mcs.rx_mcs_map,
-+					 sta->deflink.vht_cap.vht_mcs.tx_mcs_map);
- 		}
- 		len += scnprintf(p + len, size - len, "rx_bw: %d, rx_nss: %d\n",
--				 sta->bandwidth, sta->rx_nss);
-+				 sta->deflink.bandwidth, sta->deflink.rx_nss);
- 		len += scnprintf(p + len, size - len,
- 				 "tdls: %d, tdls_init: %d\n",
- 				 sta->tdls, sta->tdls_initiator);
+@@ -596,18 +596,18 @@ static ssize_t mwl_debugfs_sta_read(stru
+ 			sta_info->wds ? "true" : "false",
+ 			sta_info->ba_hist.enable ? "enable" : "disable",
+ 			sta_info->is_amsdu_allowed ? sta_info->amsdu_ctrl.cap : 0 ,
+-			sta->ht_cap.ht_supported ? sta->ht_cap.cap : 0,
+-			sta->ht_cap.ht_supported ? sta->ht_cap.ampdu_factor : 0,
+-			sta->ht_cap.ht_supported ? sta->ht_cap.ampdu_density : 0,
+-			sta->ht_cap.ht_supported ? sta->ht_cap.mcs.rx_mask[0] : 0,
+-			sta->ht_cap.ht_supported ? sta->ht_cap.mcs.rx_mask[1] : 0,
+-			sta->ht_cap.ht_supported ? sta->ht_cap.mcs.rx_mask[2] : 0,
+-			sta->ht_cap.ht_supported ? sta->ht_cap.mcs.rx_mask[3] : 0,
+-			sta->vht_cap.vht_supported ? sta->vht_cap.cap : 0,
+-			sta->vht_cap.vht_supported ? sta->vht_cap.vht_mcs.rx_mcs_map : 0,
+-			sta->vht_cap.vht_supported ? sta->vht_cap.vht_mcs.tx_mcs_map : 0,
+-			sta->bandwidth,
+-			sta->rx_nss,
++			sta->deflink.ht_cap.ht_supported ? sta->deflink.ht_cap.cap : 0,
++			sta->deflink.ht_cap.ht_supported ? sta->deflink.ht_cap.ampdu_factor : 0,
++			sta->deflink.ht_cap.ht_supported ? sta->deflink.ht_cap.ampdu_density : 0,
++			sta->deflink.ht_cap.ht_supported ? sta->deflink.ht_cap.mcs.rx_mask[0] : 0,
++			sta->deflink.ht_cap.ht_supported ? sta->deflink.ht_cap.mcs.rx_mask[1] : 0,
++			sta->deflink.ht_cap.ht_supported ? sta->deflink.ht_cap.mcs.rx_mask[2] : 0,
++			sta->deflink.ht_cap.ht_supported ? sta->deflink.ht_cap.mcs.rx_mask[3] : 0,
++			sta->deflink.vht_cap.vht_supported ? sta->deflink.vht_cap.cap : 0,
++			sta->deflink.vht_cap.vht_supported ? sta->deflink.vht_cap.vht_mcs.rx_mcs_map : 0,
++			sta->deflink.vht_cap.vht_supported ? sta->deflink.vht_cap.vht_mcs.tx_mcs_map : 0,
++			sta->deflink.bandwidth,
++			sta->deflink.rx_nss,
+ 			sta->tdls,
+ 			sta->tdls_initiator,
+ 			sta->wme,
 --- a/hif/fwcmd.c
 +++ b/hif/fwcmd.c
-@@ -634,8 +634,9 @@ einval:
+@@ -633,11 +633,15 @@ einval:
+ }
  
  static int mwl_fwcmd_set_ap_beacon(struct mwl_priv *priv,
- 				   struct mwl_vif *mwl_vif,
+-				   struct mwl_vif *mwl_vif,
 -				   struct ieee80211_bss_conf *bss_conf)
 +				   struct ieee80211_vif *vif)
  {
-+	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
  	struct hostcmd_cmd_ap_beacon *pcmd;
  	struct ds_params *phy_ds_param_set;
++	struct mwl_vif *mwl_vif;
++	struct ieee80211_bss_conf *bss_conf;
++
++	mwl_vif = mwl_dev_get_vif(vif);
++	bss_conf = &vif->bss_conf;
  
-@@ -664,7 +665,7 @@ static int mwl_fwcmd_set_ap_beacon(struc
+ 	/* wmm structure of start command is defined less one byte,
+ 	 * due to following field country is not used, add byte one
+@@ -664,7 +668,7 @@ static int mwl_fwcmd_set_ap_beacon(struc
  	pcmd->cmd_hdr.macid = mwl_vif->macid;
  
  	ether_addr_copy(pcmd->start_cmd.sta_mac_addr, mwl_vif->bssid);
@@ -99,16 +95,16 @@
  	if (priv->chip_type == MWL8997)
  		ether_addr_copy(pcmd->start_cmd.bssid, mwl_vif->bssid);
  	pcmd->start_cmd.bss_type = 1;
-@@ -2091,7 +2092,7 @@ int mwl_fwcmd_set_beacon(struct ieee8021
+@@ -2090,7 +2094,7 @@ int mwl_fwcmd_set_beacon(struct ieee8021
  	if (mwl_fwcmd_set_wsc_ie(hw, b_inf->ie_wsc_len, b_inf->ie_wsc_ptr))
  		goto err;
  
 -	if (mwl_fwcmd_set_ap_beacon(priv, mwl_vif, &vif->bss_conf))
-+	if (mwl_fwcmd_set_ap_beacon(priv, mwl_vif, vif))
++	if (mwl_fwcmd_set_ap_beacon(priv, vif))
  		goto err;
  
  	if (b_inf->cap_info & WLAN_CAPABILITY_SPECTRUM_MGMT)
-@@ -2153,38 +2154,38 @@ int mwl_fwcmd_set_new_stn_add(struct iee
+@@ -2152,38 +2156,38 @@ int mwl_fwcmd_set_new_stn_add(struct iee
  	ether_addr_copy(pcmd->mac_addr, sta->addr);
  
  	if (hw->conf.chandef.chan->band == NL80211_BAND_2GHZ)
@@ -161,7 +157,7 @@
  	}
  
  	pcmd->is_qos_sta = sta->wme;
-@@ -2240,38 +2241,38 @@ int mwl_fwcmd_set_new_stn_add_sc4(struct
+@@ -2239,38 +2243,38 @@ int mwl_fwcmd_set_new_stn_add_sc4(struct
  	ether_addr_copy(pcmd->mac_addr, sta->addr);
  
  	if (hw->conf.chandef.chan->band == NL80211_BAND_2GHZ)
@@ -214,7 +210,7 @@
  	}
  
  	pcmd->is_qos_sta = sta->wme;
-@@ -2788,9 +2789,9 @@ int mwl_fwcmd_create_ba(struct ieee80211
+@@ -2787,9 +2791,9 @@ int mwl_fwcmd_create_ba(struct ieee80211
  	pcmd->ba_info.create_params.flags = cpu_to_le32(ba_flags);
  	pcmd->ba_info.create_params.queue_id = stream->idx;
  	pcmd->ba_info.create_params.param_info =
@@ -226,7 +222,7 @@
  		 IEEE80211_HT_AMPDU_PARM_DENSITY);
  	if (direction == BA_FLAG_DIRECTION_UP) {
  		pcmd->ba_info.create_params.reset_seq_no = 0;
-@@ -2800,9 +2801,9 @@ int mwl_fwcmd_create_ba(struct ieee80211
+@@ -2799,9 +2803,9 @@ int mwl_fwcmd_create_ba(struct ieee80211
  		pcmd->ba_info.create_params.current_seq = cpu_to_le16(0);
  	}
  	if (priv->chip_type == MWL8964 &&
@@ -238,9 +234,51 @@
  			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK) >>
  			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT);
  	}
+--- a/hif/pcie/8864/tx.c
++++ b/hif/pcie/8864/tx.c
+@@ -743,7 +743,7 @@ void pcie_8864_tx_xmit(struct ieee80211_
+ 	index = SYSADPT_TX_WMM_QUEUES - index - 1;
+ 	txpriority = index;
+ 
+-	if (sta && sta->ht_cap.ht_supported &&
++	if (sta && sta->deflink.ht_cap.ht_supported &&
+ 	  !(xmitcontrol & EAGLE_TXD_XMITCTRL_USE_MC_RATE) &&
+ 	    ieee80211_is_data_qos(wh->frame_control)) {
+ 		tid = qos & 0xf;
+--- a/hif/pcie/8964/tx_ndp.c
++++ b/hif/pcie/8964/tx_ndp.c
+@@ -607,7 +607,7 @@ void pcie_tx_xmit_ndp(struct ieee80211_h
+ 		pcie_tx_encapsulate_frame(priv, skb, k_conf);
+ 	} else {
+ 		tid = qos & 0x7;
+-		if (sta && sta->ht_cap.ht_supported && !eapol_frame &&
++		if (sta && sta->deflink.ht_cap.ht_supported && !eapol_frame &&
+ 		    qos != 0xFFFF) {
+ 			pcie_tx_count_packet(sta, tid);
+ 			spin_lock_bh(&priv->stream_lock);
+--- a/hif/pcie/8997/tx.c
++++ b/hif/pcie/8997/tx.c
+@@ -81,7 +81,7 @@ static int pcie_txbd_ring_create(struct
+ 	wiphy_info(priv->hw->wiphy,
+ 		   "TX ring: - base: %p, pbase: 0x%x, len: %d\n",
+ 		   pcie_priv->txbd_ring_vbase,
+-		   pcie_priv->txbd_ring_pbase,
++		   (u32)pcie_priv->txbd_ring_pbase,
+ 		   pcie_priv->txbd_ring_size);
+ 
+ 	for (num = 0; num < PCIE_MAX_TXRX_BD; num++) {
+@@ -694,7 +694,7 @@ void pcie_8997_tx_xmit(struct ieee80211_
+ 	index = SYSADPT_TX_WMM_QUEUES - index - 1;
+ 	txpriority = index;
+ 
+-	if (sta && sta->ht_cap.ht_supported &&
++	if (sta && sta->deflink.ht_cap.ht_supported &&
+ 	  !(xmitcontrol & EAGLE_TXD_XMITCTRL_USE_MC_RATE) &&
+ 	    ieee80211_is_data_qos(wh->frame_control)) {
+ 		tid = qos & 0xf;
 --- a/mac80211.c
 +++ b/mac80211.c
-@@ -371,15 +371,15 @@ static void mwl_mac80211_bss_info_change
+@@ -368,15 +368,15 @@ static void mwl_mac80211_bss_info_change
  		}
  	}
  
@@ -259,7 +297,7 @@
  {
  	struct mwl_priv *priv = hw->priv;
  	struct mwl_vif *mwl_vif;
-@@ -429,8 +429,8 @@ static void mwl_mac80211_bss_info_change
+@@ -426,8 +426,8 @@ static void mwl_mac80211_bss_info_change
  	if (changed & (BSS_CHANGED_BEACON_INT | BSS_CHANGED_BEACON)) {
  		struct sk_buff *skb;
  
@@ -270,7 +308,7 @@
  		    (!info->hidden_ssid)) {
  			if (mwl_vif->broadcast_ssid != true) {
  				mwl_fwcmd_broadcast_ssid_enable(hw, vif, true);
-@@ -444,7 +444,7 @@ static void mwl_mac80211_bss_info_change
+@@ -441,7 +441,7 @@ static void mwl_mac80211_bss_info_change
  		}
  
  		if (!mwl_vif->set_beacon) {
@@ -279,7 +317,7 @@
  
  			if (skb) {
  				mwl_fwcmd_set_beacon(hw, vif, skb->data, skb->len);
-@@ -461,7 +461,7 @@ static void mwl_mac80211_bss_info_change
+@@ -458,7 +458,7 @@ static void mwl_mac80211_bss_info_change
  static void mwl_mac80211_bss_info_changed(struct ieee80211_hw *hw,
  					  struct ieee80211_vif *vif,
  					  struct ieee80211_bss_conf *info,
@@ -288,7 +326,7 @@
  {
  	switch (vif->type) {
  	case NL80211_IFTYPE_AP:
-@@ -584,10 +584,10 @@ static int mwl_mac80211_sta_add(struct i
+@@ -583,10 +583,10 @@ static int mwl_mac80211_sta_add(struct i
  	if (vif->type == NL80211_IFTYPE_MESH_POINT)
  		sta_info->is_mesh_node = true;
  
@@ -296,12 +334,12 @@
 +	if (sta->deflink.ht_cap.ht_supported) {
  		sta_info->is_ampdu_allowed = true;
  		sta_info->is_amsdu_allowed = false;
--		if (sta->ht_cap.cap & IEEE80211_HT_CAP_MAX_AMSDU)
-+		if (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_MAX_AMSDU)
+-		if (sta->ht_cap.cap & IEEE80211_HT_CAP_MAX_AMSDU) {
++		if (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_MAX_AMSDU) {
  			sta_info->amsdu_ctrl.cap = MWL_AMSDU_SIZE_8K;
- 		else
- 			sta_info->amsdu_ctrl.cap = MWL_AMSDU_SIZE_4K;
-@@ -669,7 +669,7 @@ static int mwl_mac80211_sta_remove(struc
+ 			sta_info->amsdu_ctrl.amsdu_allow_size = SYSADPT_AMSDU_8K_MAX_SIZE;
+ 		}
+@@ -670,7 +670,7 @@ static int mwl_mac80211_sta_remove(struc
  
  static int mwl_mac80211_conf_tx(struct ieee80211_hw *hw,
  				struct ieee80211_vif *vif,
@@ -310,7 +348,7 @@
  				const struct ieee80211_tx_queue_params *params)
  {
  	struct mwl_priv *priv = hw->priv;
-@@ -928,4 +928,5 @@ const struct ieee80211_ops mwl_mac80211_
+@@ -934,4 +934,5 @@ const struct ieee80211_ops mwl_mac80211_
  	.pre_channel_switch = mwl_mac80211_chnl_switch,
  	.sw_scan_start      = mwl_mac80211_sw_scan_start,
  	.sw_scan_complete   = mwl_mac80211_sw_scan_complete,
@@ -360,34 +398,3 @@
  
  	switch (format) {
  	case TX_RATE_FORMAT_LEGACY:
---- a/hif/pcie/tx.c
-+++ b/hif/pcie/tx.c
-@@ -153,7 +153,7 @@ static int pcie_txbd_ring_create(struct
- 	wiphy_info(priv->hw->wiphy,
- 		   "TX ring: - base: %p, pbase: 0x%x, len: %d\n",
- 		   pcie_priv->txbd_ring_vbase,
--		   pcie_priv->txbd_ring_pbase,
-+		   (u32)pcie_priv->txbd_ring_pbase,
- 		   pcie_priv->txbd_ring_size);
- 
- 	for (num = 0; num < PCIE_MAX_TXRX_BD; num++) {
-@@ -1091,7 +1091,7 @@ void pcie_tx_xmit(struct ieee80211_hw *h
- 	index = SYSADPT_TX_WMM_QUEUES - index - 1;
- 	txpriority = index;
- 
--	if (sta && sta->ht_cap.ht_supported && !eapol_frame &&
-+	if (sta && sta->deflink.ht_cap.ht_supported && !eapol_frame &&
- 	    ieee80211_is_data_qos(wh->frame_control)) {
- 		tid = qos & 0xf;
- 		pcie_tx_count_packet(sta, tid);
---- a/hif/pcie/tx_ndp.c
-+++ b/hif/pcie/tx_ndp.c
-@@ -602,7 +602,7 @@ void pcie_tx_xmit_ndp(struct ieee80211_h
- 		pcie_tx_encapsulate_frame(priv, skb, k_conf, NULL);
- 	} else {
- 		tid = qos & 0x7;
--		if (sta && sta->ht_cap.ht_supported && !eapol_frame &&
-+		if (sta && sta->deflink.ht_cap.ht_supported && !eapol_frame &&
- 		    qos != 0xFFFF) {
- 			pcie_tx_count_packet(sta, tid);
- 			spin_lock_bh(&priv->stream_lock);
diff --git a/package/kernel/mwlwifi/patches/006-remove-uaccess-and-get_fs-calls-from-PCIe-for-Kenel-.patch b/package/kernel/mwlwifi/patches/006-remove-uaccess-and-get_fs-calls-from-PCIe-for-Kenel-.patch
index c81561a149daa..2a49daa94321e 100644
--- a/package/kernel/mwlwifi/patches/006-remove-uaccess-and-get_fs-calls-from-PCIe-for-Kenel-.patch
+++ b/package/kernel/mwlwifi/patches/006-remove-uaccess-and-get_fs-calls-from-PCIe-for-Kenel-.patch
@@ -19,11 +19,9 @@ Signed-off-by: Stefan Kalscheuer <stefan@stklcode.de>
  hif/pcie/pcie.c | 6 ++++--
  1 file changed, 4 insertions(+), 2 deletions(-)
 
-diff --git a/hif/pcie/pcie.c b/hif/pcie/pcie.c
-index 24453b6..bee1cc5 100644
 --- a/hif/pcie/pcie.c
 +++ b/hif/pcie/pcie.c
-@@ -1294,7 +1294,9 @@ static void pcie_bf_mimo_ctrl_decode(struct mwl_priv *priv,
+@@ -1439,7 +1439,9 @@ static void pcie_bf_mimo_ctrl_decode(str
  	const char filename[] = "/tmp/BF_MIMO_Ctrl_Field_Output.txt";
  	char str_buf[256];
  	char *buf = &str_buf[0];
@@ -33,7 +31,7 @@ index 24453b6..bee1cc5 100644
  
  #if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
  	oldfs = get_fs();
-@@ -1302,7 +1304,7 @@ static void pcie_bf_mimo_ctrl_decode(struct mwl_priv *priv,
+@@ -1447,7 +1449,7 @@ static void pcie_bf_mimo_ctrl_decode(str
  #elif LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
  	oldfs = get_fs();
  	set_fs(KERNEL_DS);
@@ -42,7 +40,7 @@ index 24453b6..bee1cc5 100644
  	oldfs = force_uaccess_begin();
  #endif
  
-@@ -1326,7 +1328,7 @@ static void pcie_bf_mimo_ctrl_decode(struct mwl_priv *priv,
+@@ -1471,7 +1473,7 @@ static void pcie_bf_mimo_ctrl_decode(str
  
  #if LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
  	set_fs(oldfs);
diff --git a/package/kernel/mwlwifi/patches/007-replace-usage-of-the-deprecated-pci-dma-compat.h-API.patch b/package/kernel/mwlwifi/patches/007-replace-usage-of-the-deprecated-pci-dma-compat.h-API.patch
index 1faff18c840b5..b752d72f782b6 100644
--- a/package/kernel/mwlwifi/patches/007-replace-usage-of-the-deprecated-pci-dma-compat.h-API.patch
+++ b/package/kernel/mwlwifi/patches/007-replace-usage-of-the-deprecated-pci-dma-compat.h-API.patch
@@ -24,11 +24,9 @@ Signed-off-by: Stefan Kalscheuer <stefan@stklcode.de>
  hif/pcie/tx_ndp.c | 14 +++++++-------
  5 files changed, 39 insertions(+), 39 deletions(-)
 
-diff --git a/hif/pcie/pcie.c b/hif/pcie/pcie.c
-index bee1cc5..d85c29e 100644
 --- a/hif/pcie/pcie.c
 +++ b/hif/pcie/pcie.c
-@@ -1556,7 +1556,7 @@ static int pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+@@ -1701,7 +1701,7 @@ static int pcie_probe(struct pci_dev *pd
  		return rc;
  	}
  
@@ -37,11 +35,9 @@ index bee1cc5..d85c29e 100644
  	if (rc) {
  		pr_err("%s: 32-bit PCI DMA not supported\n",
  		       PCIE_DRV_NAME);
-diff --git a/hif/pcie/rx.c b/hif/pcie/rx.c
-index 91eb984..2857c0f 100644
---- a/hif/pcie/rx.c
-+++ b/hif/pcie/rx.c
-@@ -107,11 +107,11 @@ static int pcie_rx_ring_init(struct mwl_priv *priv)
+--- a/hif/pcie/8864/rx.c
++++ b/hif/pcie/8864/rx.c
+@@ -107,11 +107,11 @@ static int pcie_rx_ring_init(struct mwl_
  			desc->prx_ring[i].rssi = 0x00;
  			desc->prx_ring[i].pkt_len =
  				cpu_to_le16(SYSADPT_MAX_AGGR_SIZE);
@@ -56,7 +52,7 @@ index 91eb984..2857c0f 100644
  				wiphy_err(priv->hw->wiphy,
  					  "failed to map pci memory!\n");
  				return -ENOMEM;
-@@ -153,11 +153,11 @@ static void pcie_rx_ring_cleanup(struct mwl_priv *priv)
+@@ -153,11 +153,11 @@ static void pcie_rx_ring_cleanup(struct
  			if (!rx_hndl->psk_buff)
  				continue;
  
@@ -70,12 +66,12 @@ index 91eb984..2857c0f 100644
  
  			dev_kfree_skb_any(rx_hndl->psk_buff);
  
-@@ -335,11 +335,11 @@ static inline int pcie_rx_refill(struct mwl_priv *priv,
+@@ -332,11 +332,11 @@ static inline int pcie_rx_refill(struct
  	rx_hndl->pdesc->rssi = 0x00;
  	rx_hndl->pdesc->pkt_len = cpu_to_le16(desc->rx_buf_size);
  
 -	dma = pci_map_single(pcie_priv->pdev,
-+	dma = dma_map_single(&(pcie_priv->pdev)->dev,
++	dma = dma_map_single(&pcie_priv->pdev->dev,
  			     rx_hndl->psk_buff->data,
  			     desc->rx_buf_size,
 -			     PCI_DMA_FROMDEVICE);
@@ -85,7 +81,7 @@ index 91eb984..2857c0f 100644
  		dev_kfree_skb_any(rx_hndl->psk_buff);
  		wiphy_err(priv->hw->wiphy,
  			  "failed to map pci memory!\n");
-@@ -413,10 +413,10 @@ void pcie_rx_recv(unsigned long data)
+@@ -410,10 +410,10 @@ void pcie_8864_rx_recv(unsigned long dat
  		prx_skb = curr_hndl->psk_buff;
  		if (!prx_skb)
  			goto out;
@@ -98,11 +94,58 @@ index 91eb984..2857c0f 100644
  		pkt_len = le16_to_cpu(curr_hndl->pdesc->pkt_len);
  
  		if (skb_tailroom(prx_skb) < pkt_len) {
-diff --git a/hif/pcie/rx_ndp.c b/hif/pcie/rx_ndp.c
-index 228075d..106d559 100644
---- a/hif/pcie/rx_ndp.c
-+++ b/hif/pcie/rx_ndp.c
-@@ -86,11 +86,11 @@ static int pcie_rx_ring_init_ndp(struct mwl_priv *priv)
+--- a/hif/pcie/8864/tx.c
++++ b/hif/pcie/8864/tx.c
+@@ -171,11 +171,11 @@ static void pcie_tx_ring_cleanup(struct
+ 					    desc->tx_hndl[i].psk_buff->data,
+ 					    le32_to_cpu(
+ 					    desc->ptx_ring[i].pkt_ptr));
+-				pci_unmap_single(pcie_priv->pdev,
++				dma_unmap_single(&(pcie_priv->pdev)->dev,
+ 						 le32_to_cpu(
+ 						 desc->ptx_ring[i].pkt_ptr),
+ 						 desc->tx_hndl[i].psk_buff->len,
+-						 PCI_DMA_TODEVICE);
++						 DMA_TO_DEVICE);
+ 				dev_kfree_skb_any(desc->tx_hndl[i].psk_buff);
+ 				desc->ptx_ring[i].status =
+ 					cpu_to_le32(EAGLE_TXD_STATUS_IDLE);
+@@ -291,9 +291,9 @@ static inline void pcie_tx_skb(struct mw
+ 	tx_desc->type = tx_ctrl->type;
+ 	tx_desc->xmit_control = tx_ctrl->xmit_control;
+ 	tx_desc->sap_pkt_info = 0;
+-	dma = pci_map_single(pcie_priv->pdev, tx_skb->data,
+-			     tx_skb->len, PCI_DMA_TODEVICE);
+-	if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
++	dma = dma_map_single(&(pcie_priv->pdev)->dev, tx_skb->data,
++			     tx_skb->len, DMA_TO_DEVICE);
++	if (dma_mapping_error(&(pcie_priv->pdev)->dev, dma)) {
+ 		dev_kfree_skb_any(tx_skb);
+ 		wiphy_err(priv->hw->wiphy,
+ 			  "failed to map pci memory!\n");
+@@ -447,10 +447,10 @@ static void pcie_non_pfu_tx_done(struct
+ 		       (tx_desc->status & cpu_to_le32(EAGLE_TXD_STATUS_OK)) &&
+ 		       (!(tx_desc->status &
+ 		       cpu_to_le32(EAGLE_TXD_STATUS_FW_OWNED)))) {
+-			pci_unmap_single(pcie_priv->pdev,
++			dma_unmap_single(&(pcie_priv->pdev)->dev,
+ 					 le32_to_cpu(tx_desc->pkt_ptr),
+ 					 le16_to_cpu(tx_desc->pkt_len),
+-					 PCI_DMA_TODEVICE);
++					 DMA_TO_DEVICE);
+ 			done_skb = tx_hndl->psk_buff;
+ 			rate = le32_to_cpu(tx_desc->rate_info);
+ 			tx_desc->pkt_ptr = 0;
+@@ -925,4 +925,4 @@ void pcie_8864_tx_del_sta_amsdu_pkts(str
+ 		}
+ 	}
+ 	spin_unlock_bh(&sta_info->amsdu_lock);
+-}
+\ No newline at end of file
++}
+--- a/hif/pcie/8964/rx_ndp.c
++++ b/hif/pcie/8964/rx_ndp.c
+@@ -86,11 +86,11 @@ static int pcie_rx_ring_init_ndp(struct
  			}
  			skb_reserve(psk_buff, MIN_BYTES_RX_HEADROOM);
  
@@ -117,7 +160,7 @@ index 228075d..106d559 100644
  				wiphy_err(priv->hw->wiphy,
  					  "failed to map pci memory!\n");
  				return -ENOMEM;
-@@ -120,11 +120,11 @@ static void pcie_rx_ring_cleanup_ndp(struct mwl_priv *priv)
+@@ -120,11 +120,11 @@ static void pcie_rx_ring_cleanup_ndp(str
  	if (desc->prx_ring) {
  		for (i = 0; i < MAX_NUM_RX_DESC; i++) {
  			if (desc->rx_vbuflist[i]) {
@@ -131,7 +174,7 @@ index 228075d..106d559 100644
  				desc->rx_vbuflist[i] = NULL;
  			}
  		}
-@@ -400,11 +400,11 @@ static inline int pcie_rx_refill_ndp(struct mwl_priv *priv, u32 buf_idx)
+@@ -411,11 +411,11 @@ static inline int pcie_rx_refill_ndp(str
  		return -ENOMEM;
  	skb_reserve(psk_buff, MIN_BYTES_RX_HEADROOM);
  
@@ -146,7 +189,7 @@ index 228075d..106d559 100644
  		wiphy_err(priv->hw->wiphy,
  			  "refill: failed to map pci memory!\n");
  		return -ENOMEM;
-@@ -509,10 +509,10 @@ recheck:
+@@ -520,10 +520,10 @@ recheck:
  			break;
  		}
  
@@ -159,25 +202,109 @@ index 228075d..106d559 100644
  
  		bad_mic = false;
  		ctrl = le32_to_cpu(prx_ring_done->ctrl);
-diff --git a/hif/pcie/tx.c b/hif/pcie/tx.c
-index 62a34a8..8f3c828 100644
---- a/hif/pcie/tx.c
-+++ b/hif/pcie/tx.c
-@@ -243,11 +243,11 @@ static void pcie_tx_ring_cleanup(struct mwl_priv *priv)
- 					    desc->tx_hndl[i].psk_buff->data,
- 					    le32_to_cpu(
- 					    desc->ptx_ring[i].pkt_ptr));
--				pci_unmap_single(pcie_priv->pdev,
-+				dma_unmap_single(&(pcie_priv->pdev)->dev,
- 						 le32_to_cpu(
- 						 desc->ptx_ring[i].pkt_ptr),
- 						 desc->tx_hndl[i].psk_buff->len,
--						 PCI_DMA_TODEVICE);
-+						 DMA_TO_DEVICE);
- 				dev_kfree_skb_any(desc->tx_hndl[i].psk_buff);
- 				desc->ptx_ring[i].status =
- 					cpu_to_le32(EAGLE_TXD_STATUS_IDLE);
-@@ -305,10 +305,10 @@ static void pcie_txbd_ring_delete(struct mwl_priv *priv)
+--- a/hif/pcie/8964/tx_ndp.c
++++ b/hif/pcie/8964/tx_ndp.c
+@@ -132,10 +132,10 @@ static void pcie_tx_ring_cleanup_ndp(str
+ 	for (i = 0; i < MAX_TX_RING_SEND_SIZE; i++) {
+ 		tx_skb = desc->tx_vbuflist[i];
+ 		if (tx_skb) {
+-			pci_unmap_single(pcie_priv->pdev,
++			dma_unmap_single(&(pcie_priv->pdev)->dev,
+ 					 desc->pphys_tx_buflist[i],
+ 					 tx_skb->len,
+-					 PCI_DMA_TODEVICE);
++					 DMA_TO_DEVICE);
+ 			dev_kfree_skb_any(tx_skb);
+ 			desc->pphys_tx_buflist[i] = 0;
+ 			desc->tx_vbuflist[i] = NULL;
+@@ -267,9 +267,9 @@ static inline int pcie_tx_skb_ndp(struct
+ 			(TXRING_CTRL_TAG_MGMT << TXRING_CTRL_TAG_SHIFT));
+ 	}
+ 
+-	dma = pci_map_single(pcie_priv->pdev, tx_skb->data,
+-			     tx_skb->len, PCI_DMA_TODEVICE);
+-	if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
++	dma = dma_map_single(&(pcie_priv->pdev)->dev, tx_skb->data,
++			     tx_skb->len, DMA_TO_DEVICE);
++	if (dma_mapping_error(&(pcie_priv->pdev)->dev, dma)) {
+ 		dev_kfree_skb_any(tx_skb);
+ 		wiphy_err(priv->hw->wiphy,
+ 			  "failed to map pci memory!\n");
+@@ -451,10 +451,10 @@ void pcie_tx_done_ndp(struct ieee80211_h
+ 				  "buffer is NULL for tx done ring\n");
+ 			break;
+ 		}
+-		pci_unmap_single(pcie_priv->pdev,
++		dma_unmap_single(&(pcie_priv->pdev)->dev,
+ 				 desc->pphys_tx_buflist[index],
+ 				 skb->len,
+-				 PCI_DMA_TODEVICE);
++				 DMA_TO_DEVICE);
+ 		desc->pphys_tx_buflist[index] = 0;
+ 		desc->tx_vbuflist[index] = NULL;
+ 
+--- a/hif/pcie/8997/rx.c
++++ b/hif/pcie/8997/rx.c
+@@ -107,11 +107,11 @@ static int pcie_rx_ring_init(struct mwl_
+ 			desc->prx_ring[i].rssi = 0x00;
+ 			desc->prx_ring[i].pkt_len =
+ 				cpu_to_le16(SYSADPT_MAX_AGGR_SIZE);
+-			dma = pci_map_single(pcie_priv->pdev,
++			dma = dma_map_single(&(pcie_priv->pdev)->dev,
+ 					     rx_hndl->psk_buff->data,
+ 					     desc->rx_buf_size,
+-					     PCI_DMA_FROMDEVICE);
+-			if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
++					     DMA_FROM_DEVICE);
++			if (dma_mapping_error(&(pcie_priv->pdev)->dev, dma)) {
+ 				wiphy_err(priv->hw->wiphy,
+ 					  "failed to map pci memory!\n");
+ 				return -ENOMEM;
+@@ -153,11 +153,11 @@ static void pcie_rx_ring_cleanup(struct
+ 			if (!rx_hndl->psk_buff)
+ 				continue;
+ 
+-			pci_unmap_single(pcie_priv->pdev,
++			dma_unmap_single(&(pcie_priv->pdev)->dev,
+ 					 le32_to_cpu
+ 					 (rx_hndl->pdesc->pphys_buff_data),
+ 					 desc->rx_buf_size,
+-					 PCI_DMA_FROMDEVICE);
++					 DMA_FROM_DEVICE);
+ 
+ 			dev_kfree_skb_any(rx_hndl->psk_buff);
+ 
+@@ -332,11 +332,11 @@ static inline int pcie_rx_refill(struct
+ 	rx_hndl->pdesc->rssi = 0x00;
+ 	rx_hndl->pdesc->pkt_len = cpu_to_le16(desc->rx_buf_size);
+ 
+-	dma = pci_map_single(pcie_priv->pdev,
++	dma = dma_map_single(&pcie_priv->pdev->dev,
+ 			     rx_hndl->psk_buff->data,
+ 			     desc->rx_buf_size,
+-			     PCI_DMA_FROMDEVICE);
+-	if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
++			     DMA_FROM_DEVICE);
++	if (dma_mapping_error(&(pcie_priv->pdev)->dev, dma)) {
+ 		dev_kfree_skb_any(rx_hndl->psk_buff);
+ 		wiphy_err(priv->hw->wiphy,
+ 			  "failed to map pci memory!\n");
+@@ -410,10 +410,10 @@ void pcie_8997_rx_recv(unsigned long dat
+ 		prx_skb = curr_hndl->psk_buff;
+ 		if (!prx_skb)
+ 			goto out;
+-		pci_unmap_single(pcie_priv->pdev,
++		dma_unmap_single(&(pcie_priv->pdev)->dev,
+ 				 le32_to_cpu(curr_hndl->pdesc->pphys_buff_data),
+ 				 desc->rx_buf_size,
+-				 PCI_DMA_FROMDEVICE);
++				 DMA_FROM_DEVICE);
+ 		pkt_len = le16_to_cpu(curr_hndl->pdesc->pkt_len);
+ 
+ 		if (skb_tailroom(prx_skb) < pkt_len) {
+--- a/hif/pcie/8997/tx.c
++++ b/hif/pcie/8997/tx.c
+@@ -139,10 +139,10 @@ static void pcie_txbd_ring_delete(struct
  			skb = pcie_priv->tx_buf_list[num];
  			tx_desc = (struct pcie_tx_desc *)skb->data;
  
@@ -190,7 +317,7 @@ index 62a34a8..8f3c828 100644
  			dev_kfree_skb_any(skb);
  		}
  		pcie_priv->tx_buf_list[num] = NULL;
-@@ -453,9 +453,9 @@ static inline void pcie_tx_skb(struct mwl_priv *priv, int desc_num,
+@@ -222,9 +222,9 @@ static inline void pcie_tx_skb(struct mw
  	tx_desc->type = tx_ctrl->type;
  	tx_desc->xmit_control = tx_ctrl->xmit_control;
  	tx_desc->sap_pkt_info = 0;
@@ -203,7 +330,7 @@ index 62a34a8..8f3c828 100644
  		dev_kfree_skb_any(tx_skb);
  		wiphy_err(priv->hw->wiphy,
  			  "failed to map pci memory!\n");
-@@ -676,10 +676,10 @@ static void pcie_pfu_tx_done(struct mwl_priv *priv)
+@@ -401,10 +401,10 @@ static void pcie_pfu_tx_done(struct mwl_
  			pfu_dma = (struct pcie_pfu_dma_data *)done_skb->data;
  			tx_desc = &pfu_dma->tx_desc;
  			dma_data = &pfu_dma->dma_data;
@@ -216,60 +343,10 @@ index 62a34a8..8f3c828 100644
  			tx_desc->pkt_ptr = 0;
  			tx_desc->pkt_len = 0;
  			tx_desc->status = cpu_to_le32(EAGLE_TXD_STATUS_IDLE);
-@@ -768,10 +768,10 @@ static void pcie_non_pfu_tx_done(struct mwl_priv *priv)
- 		       (tx_desc->status & cpu_to_le32(EAGLE_TXD_STATUS_OK)) &&
- 		       (!(tx_desc->status &
- 		       cpu_to_le32(EAGLE_TXD_STATUS_FW_OWNED)))) {
--			pci_unmap_single(pcie_priv->pdev,
-+			dma_unmap_single(&(pcie_priv->pdev)->dev,
- 					 le32_to_cpu(tx_desc->pkt_ptr),
- 					 le16_to_cpu(tx_desc->pkt_len),
--					 PCI_DMA_TODEVICE);
-+					 DMA_TO_DEVICE);
- 			done_skb = tx_hndl->psk_buff;
- 			rate = le32_to_cpu(tx_desc->rate_info);
- 			tx_desc->pkt_ptr = 0;
-diff --git a/hif/pcie/tx_ndp.c b/hif/pcie/tx_ndp.c
-index 6758cde..f4256c2 100644
---- a/hif/pcie/tx_ndp.c
-+++ b/hif/pcie/tx_ndp.c
-@@ -131,10 +131,10 @@ static void pcie_tx_ring_cleanup_ndp(struct mwl_priv *priv)
- 	for (i = 0; i < MAX_TX_RING_SEND_SIZE; i++) {
- 		tx_skb = desc->tx_vbuflist[i];
- 		if (tx_skb) {
--			pci_unmap_single(pcie_priv->pdev,
-+			dma_unmap_single(&(pcie_priv->pdev)->dev,
- 					 desc->pphys_tx_buflist[i],
- 					 tx_skb->len,
--					 PCI_DMA_TODEVICE);
-+					 DMA_TO_DEVICE);
- 			dev_kfree_skb_any(tx_skb);
- 			desc->pphys_tx_buflist[i] = 0;
- 			desc->tx_vbuflist[i] = NULL;
-@@ -266,9 +266,9 @@ static inline int pcie_tx_skb_ndp(struct mwl_priv *priv,
- 			(TXRING_CTRL_TAG_MGMT << TXRING_CTRL_TAG_SHIFT));
- 	}
- 
--	dma = pci_map_single(pcie_priv->pdev, tx_skb->data,
--			     tx_skb->len, PCI_DMA_TODEVICE);
--	if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
-+	dma = dma_map_single(&(pcie_priv->pdev)->dev, tx_skb->data,
-+			     tx_skb->len, DMA_TO_DEVICE);
-+	if (dma_mapping_error(&(pcie_priv->pdev)->dev, dma)) {
- 		dev_kfree_skb_any(tx_skb);
- 		wiphy_err(priv->hw->wiphy,
- 			  "failed to map pci memory!\n");
-@@ -450,10 +450,10 @@ void pcie_tx_done_ndp(struct ieee80211_hw *hw)
- 				  "buffer is NULL for tx done ring\n");
- 			break;
+@@ -875,4 +875,4 @@ void pcie_8997_tx_del_sta_amsdu_pkts(str
  		}
--		pci_unmap_single(pcie_priv->pdev,
-+		dma_unmap_single(&(pcie_priv->pdev)->dev,
- 				 desc->pphys_tx_buflist[index],
- 				 skb->len,
--				 PCI_DMA_TODEVICE);
-+				 DMA_TO_DEVICE);
- 		desc->pphys_tx_buflist[index] = 0;
- 		desc->tx_vbuflist[index] = NULL;
- 
-
+ 	}
+ 	spin_unlock_bh(&sta_info->amsdu_lock);
+-}
+\ No newline at end of file
++}
