From 4871b78f5862cecd4212a337bcb011fcd9086dcd Mon Sep 17 00:00:00 2001
From: Rui Salvaterra <rsalvaterra@gmail.com>
Date: Mon, 22 Feb 2021 08:59:34 +0000
Subject: [PATCH] mvebu: refresh 5.10 kconfigs/patches

Also delete already upstreamed patches/changes.

Signed-off-by: Rui Salvaterra <rsalvaterra@gmail.com>
Tested-by: Tad <tad@spotco.us>
---
 target/linux/mvebu/config-5.10                |  17 +-
 target/linux/mvebu/cortexa53/config-5.10      |  10 +-
 target/linux/mvebu/cortexa72/config-5.10      |  10 +-
 ...t-for-endpoint-to-be-ready-before-tr.patch |  50 ---
 ...-t-rely-on-jiffies-while-holding-spi.patch |  54 ---
 ...ntroduce-mvneta_update_stats-routine.patch |  95 ------
 ...duce-page-pool-API-for-sw-buffer-man.patch | 181 ----------
 ...on-build_skb-in-mvneta_rx_swbm-poll-.patch | 303 -----------------
 ...006-net-mvneta-add-basic-XDP-support.patch | 311 ------------------
 ...avoid_error_message_for_optional_IRQ.patch |  31 --
 ...header-prefetch-in-mvneta_swbm_rx_fr.patch |  43 ---
 ...mvneta-make-tx-buffer-array-agnostic.patch | 210 ------------
 .../009-net-mvneta-add-XDP_TX-support.patch   | 175 ----------
 ...fix-build-skb-for-bm-capable-devices.patch |  41 ---
 ...-arm64-dts-uDPU-remove-i2c-fast-mode.patch |  31 --
 ...ts-uDPU-SFP-cages-support-3W-modules.patch |  34 --
 ...on-page_pool_recycle_direct-in-mvnet.patch |  39 ---
 ...sallow-XDP-program-on-hardware-buffe.patch |  53 ---
 ...DP-support-if-sw-bm-is-used-as-fallb.patch |  67 ----
 ...in-link-immediately-after-enabling-t.patch |  60 ----
 ...7-PCI-aardvark-Improve-link-training.patch | 208 ------------
 ...18-PCI-aardvark-Issue-PERST-via-GPIO.patch | 123 -------
 .../019-PCI-aardvark-Add-PHY-support.patch    | 152 ---------
 ...l-armada-37xx-Set-pcie_reset_pin-to-.patch |  93 ------
 ...l-armada-37xx-Move-PCIe-comphy-handl.patch |  57 ----
 ...l-armada-37xx-Move-PCIe-max-link-spe.patch |  44 ---
 ...-arm64-dts-add-uDPU-i2c-bus-recovery.patch |  53 ---
 ...-t-touch-PCIe-registers-if-no-card-c.patch |  50 ---
 ...add-driver-for-LinkStation-power-off.patch | 207 ------------
 ...-initialization-with-old-Marvell-s-A.patch |  44 ---
 ...l-espressobin-Add-ethernet-switch-al.patch |  88 -----
 ...Mangle-bootloader-s-kernel-arguments.patch |  22 +-
 ...-mvebu-armada-38x-enable-libata-leds.patch |   4 +-
 ...l-armada-3720-espressobin-add-ports-.patch |  26 --
 .../patches-5.10/400-find_active_root.patch   |   2 +-
 .../700-mvneta-tx-queue-workaround.patch      |   6 +-
 ...-pci-mvebu-time-out-reset-on-link-up.patch |   6 +-
 37 files changed, 33 insertions(+), 2967 deletions(-)
 delete mode 100644 target/linux/mvebu/patches-5.10/001-PCI-aardvark-Wait-for-endpoint-to-be-ready-before-tr.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/002-PCI-aardvark-Don-t-rely-on-jiffies-while-holding-spi.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/003-net-mvneta-introduce-mvneta_update_stats-routine.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/004-net-mvneta-introduce-page-pool-API-for-sw-buffer-man.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/005-net-mvneta-rely-on-build_skb-in-mvneta_rx_swbm-poll-.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/006-net-mvneta-add-basic-XDP-support.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/007-gpio-mvebu-avoid_error_message_for_optional_IRQ.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/007-net-mvneta-move-header-prefetch-in-mvneta_swbm_rx_fr.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/008-net-mvneta-make-tx-buffer-array-agnostic.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/009-net-mvneta-add-XDP_TX-support.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/010-net-mvneta-fix-build-skb-for-bm-capable-devices.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/011-arm64-dts-uDPU-remove-i2c-fast-mode.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/012-arm64-dts-uDPU-SFP-cages-support-3W-modules.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/013-net-mvneta-rely-on-page_pool_recycle_direct-in-mvnet.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/014-mvneta-driver-disallow-XDP-program-on-hardware-buffe.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/015-net-mvneta-fix-XDP-support-if-sw-bm-is-used-as-fallb.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/016-PCI-aardvark-Train-link-immediately-after-enabling-t.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/017-PCI-aardvark-Improve-link-training.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/018-PCI-aardvark-Issue-PERST-via-GPIO.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/019-PCI-aardvark-Add-PHY-support.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/020-arm64-dts-marvell-armada-37xx-Set-pcie_reset_pin-to-.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/021-arm64-dts-marvell-armada-37xx-Move-PCIe-comphy-handl.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/022-arm64-dts-marvell-armada-37xx-Move-PCIe-max-link-spe.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/023-arm64-dts-add-uDPU-i2c-bus-recovery.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/024-PCI-aardvark-Don-t-touch-PCIe-registers-if-no-card-c.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/025-power-reset-add-driver-for-LinkStation-power-off.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/026-PCI-aardvark-Fix-initialization-with-old-Marvell-s-A.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/027-arm64-dts-marvell-espressobin-Add-ethernet-switch-al.patch
 delete mode 100644 target/linux/mvebu/patches-5.10/315-arm64-dts-marvell-armada-3720-espressobin-add-ports-.patch

diff --git a/target/linux/mvebu/config-5.10 b/target/linux/mvebu/config-5.10
index beeecd138e..4b0e9b16ab 100644
--- a/target/linux/mvebu/config-5.10
+++ b/target/linux/mvebu/config-5.10
@@ -1,7 +1,6 @@
 CONFIG_AHCI_MVEBU=y
 CONFIG_ALIGNMENT_TRAP=y
 CONFIG_ARCH_32BIT_OFF_T=y
-CONFIG_ARCH_CLOCKSOURCE_DATA=y
 CONFIG_ARCH_HIBERNATION_POSSIBLE=y
 CONFIG_ARCH_KEEP_MEMBLOCK=y
 CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
@@ -12,6 +11,8 @@ CONFIG_ARCH_MVEBU=y
 CONFIG_ARCH_NR_GPIO=0
 CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
 CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_ARM=y
 CONFIG_ARMADA_370_CLK=y
@@ -22,6 +23,8 @@ CONFIG_ARMADA_38X_CLK=y
 CONFIG_ARMADA_THERMAL=y
 CONFIG_ARMADA_XP_CLK=y
 CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
 # CONFIG_ARM_ARMADA_37XX_CPUFREQ is not set
 # CONFIG_ARM_ARMADA_8K_CPUFREQ is not set
 CONFIG_ARM_ATAG_DTB_COMPAT=y
@@ -107,6 +110,7 @@ CONFIG_CRYPTO_CRC32C=y
 CONFIG_CRYPTO_CRYPTD=y
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_DEV_MARVELL=y
 CONFIG_CRYPTO_DEV_MARVELL_CESA=y
 CONFIG_CRYPTO_ESSIV=y
 CONFIG_CRYPTO_HASH=y
@@ -135,9 +139,7 @@ CONFIG_DEBUG_MVEBU_UART0=y
 # CONFIG_DEBUG_MVEBU_UART0_ALTERNATE is not set
 # CONFIG_DEBUG_MVEBU_UART1_ALTERNATE is not set
 CONFIG_DEBUG_UART_8250=y
-# CONFIG_DEBUG_UART_8250_FLOW_CONTROL is not set
 CONFIG_DEBUG_UART_8250_SHIFT=2
-# CONFIG_DEBUG_UART_8250_WORD is not set
 CONFIG_DEBUG_UART_PHYS=0xd0012000
 CONFIG_DEBUG_UART_VIRT=0xfec12000
 CONFIG_DEBUG_UNCOMPRESS=y
@@ -146,6 +148,7 @@ CONFIG_DMADEVICES=y
 CONFIG_DMA_ENGINE=y
 CONFIG_DMA_ENGINE_RAID=y
 CONFIG_DMA_OF=y
+CONFIG_DMA_OPS=y
 CONFIG_DMA_REMAP=y
 CONFIG_DTC=y
 CONFIG_EARLY_PRINTK=y
@@ -166,6 +169,7 @@ CONFIG_GENERIC_CLOCKEVENTS=y
 CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
 CONFIG_GENERIC_CPU_AUTOPROBE=y
 CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
 CONFIG_GENERIC_IDLE_POLL_SETUP=y
 CONFIG_GENERIC_IRQ_CHIP=y
 CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
@@ -182,6 +186,7 @@ CONFIG_GENERIC_SMP_IDLE_THREAD=y
 CONFIG_GENERIC_STRNCPY_FROM_USER=y
 CONFIG_GENERIC_STRNLEN_USER=y
 CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_VDSO_32=y
 CONFIG_GLOB=y
 CONFIG_GPIOLIB=y
 CONFIG_GPIOLIB_IRQCHIP=y
@@ -226,6 +231,7 @@ CONFIG_LEDS_PCA963X=y
 CONFIG_LEDS_TLC591XX=y
 CONFIG_LEDS_TRIGGER_DISK=y
 CONFIG_LIBFDT=y
+CONFIG_LLD_VERSION=0
 CONFIG_LOCK_DEBUGGING_SUPPORT=y
 CONFIG_LOCK_SPIN_ON_OWNER=y
 CONFIG_LZO_COMPRESS=y
@@ -259,6 +265,7 @@ CONFIG_MMC_SDHCI_PXAV3=y
 CONFIG_MODULES_USE_ELF_REL=y
 CONFIG_MTD_CFI_STAA=y
 CONFIG_MTD_NAND_CORE=y
+CONFIG_MTD_NAND_ECC=y
 CONFIG_MTD_NAND_ECC_SW_HAMMING=y
 CONFIG_MTD_NAND_MARVELL=y
 CONFIG_MTD_RAW_NAND=y
@@ -286,7 +293,6 @@ CONFIG_NET_DEVLINK=y
 CONFIG_NET_DSA=y
 CONFIG_NET_DSA_MV88E6XXX=y
 CONFIG_NET_DSA_MV88E6XXX_GLOBAL2=y
-# CONFIG_NET_DSA_MV88E6XXX_PTP is not set
 CONFIG_NET_DSA_TAG_DSA=y
 CONFIG_NET_DSA_TAG_EDSA=y
 CONFIG_NET_FLOW_LIMIT=y
@@ -343,7 +349,6 @@ CONFIG_PWM_SYSFS=y
 CONFIG_RATIONAL=y
 CONFIG_RCU_NEED_SEGCBLIST=y
 CONFIG_RCU_STALL_COMMON=y
-CONFIG_REFCOUNT_FULL=y
 CONFIG_REGMAP=y
 CONFIG_REGMAP_I2C=y
 CONFIG_REGMAP_MMIO=y
@@ -358,10 +363,10 @@ CONFIG_RTC_I2C_AND_SPI=y
 CONFIG_RTC_MC146818_LIB=y
 CONFIG_RWSEM_SPIN_ON_OWNER=y
 CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_SATA_HOST=y
 CONFIG_SATA_MV=y
 CONFIG_SATA_PMP=y
 CONFIG_SCSI=y
-# CONFIG_SENSORS_DRIVETEMP is not set
 CONFIG_SENSORS_PWM_FAN=y
 CONFIG_SENSORS_TMP421=y
 CONFIG_SERIAL_8250_DW=y
diff --git a/target/linux/mvebu/cortexa53/config-5.10 b/target/linux/mvebu/cortexa53/config-5.10
index 79d53932d0..a3de912b99 100644
--- a/target/linux/mvebu/cortexa53/config-5.10
+++ b/target/linux/mvebu/cortexa53/config-5.10
@@ -5,19 +5,16 @@ CONFIG_ARCH_MMAP_RND_BITS_MAX=24
 CONFIG_ARCH_MMAP_RND_BITS_MIN=18
 CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
 CONFIG_ARCH_PROC_KCORE_TEXT=y
-CONFIG_ARCH_SELECT_MEMORY_MODEL=y
 CONFIG_ARCH_SPARSEMEM_DEFAULT=y
-CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_STACKWALK=y
 CONFIG_ARM64=y
 CONFIG_ARM64_4K_PAGES=y
-CONFIG_ARM64_CONT_SHIFT=4
 # CONFIG_ARM64_ERRATUM_1165522 is not set
 # CONFIG_ARM64_ERRATUM_1286807 is not set
 CONFIG_ARM64_PAGE_SHIFT=12
 CONFIG_ARM64_PA_BITS=48
 CONFIG_ARM64_PA_BITS_48=y
 CONFIG_ARM64_PTR_AUTH=y
-CONFIG_ARM64_SSBD=y
 CONFIG_ARM64_SVE=y
 CONFIG_ARM64_TAGGED_ADDR_ABI=y
 CONFIG_ARM64_VA_BITS=39
@@ -27,8 +24,6 @@ CONFIG_ARMADA_AP806_SYSCON=y
 CONFIG_ARMADA_AP_CP_HELPER=y
 CONFIG_ARMADA_CP110_SYSCON=y
 CONFIG_ARM_AMBA=y
-CONFIG_ARM_ARCH_TIMER=y
-CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
 CONFIG_ARM_ARMADA_37XX_CPUFREQ=y
 CONFIG_ARM_GIC_V2M=y
 CONFIG_ARM_GIC_V3=y
@@ -40,16 +35,13 @@ CONFIG_ARM_PSCI_FW=y
 CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
 # CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
 CONFIG_CC_HAVE_STACKPROTECTOR_SYSREG=y
-# CONFIG_DEBUG_ALIGN_RODATA is not set
 CONFIG_DMA_DIRECT_REMAP=y
-CONFIG_DRM_RCAR_WRITEBACK=y
 # CONFIG_FLATMEM_MANUAL is not set
 CONFIG_FRAME_POINTER=y
 # CONFIG_FUJITSU_ERRATUM_010001 is not set
 CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
 CONFIG_GENERIC_CPU_VULNERABILITIES=y
 CONFIG_GENERIC_CSUM=y
-CONFIG_GENERIC_GETTIMEOFDAY=y
 CONFIG_GENERIC_PINCONF=y
 CONFIG_HOLES_IN_ZONE=y
 CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
diff --git a/target/linux/mvebu/cortexa72/config-5.10 b/target/linux/mvebu/cortexa72/config-5.10
index db50baf1a9..6ffe6c9f13 100644
--- a/target/linux/mvebu/cortexa72/config-5.10
+++ b/target/linux/mvebu/cortexa72/config-5.10
@@ -5,19 +5,16 @@ CONFIG_ARCH_MMAP_RND_BITS_MAX=24
 CONFIG_ARCH_MMAP_RND_BITS_MIN=18
 CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
 CONFIG_ARCH_PROC_KCORE_TEXT=y
-CONFIG_ARCH_SELECT_MEMORY_MODEL=y
 CONFIG_ARCH_SPARSEMEM_DEFAULT=y
-CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_STACKWALK=y
 CONFIG_ARM64=y
 CONFIG_ARM64_4K_PAGES=y
-CONFIG_ARM64_CONT_SHIFT=4
 # CONFIG_ARM64_ERRATUM_1165522 is not set
 # CONFIG_ARM64_ERRATUM_1286807 is not set
 CONFIG_ARM64_PAGE_SHIFT=12
 CONFIG_ARM64_PA_BITS=48
 CONFIG_ARM64_PA_BITS_48=y
 # CONFIG_ARM64_PTR_AUTH is not set
-CONFIG_ARM64_SSBD=y
 CONFIG_ARM64_SVE=y
 # CONFIG_ARM64_TAGGED_ADDR_ABI is not set
 CONFIG_ARM64_VA_BITS=39
@@ -27,8 +24,6 @@ CONFIG_ARMADA_AP806_SYSCON=y
 CONFIG_ARMADA_AP_CP_HELPER=y
 CONFIG_ARMADA_CP110_SYSCON=y
 CONFIG_ARM_AMBA=y
-CONFIG_ARM_ARCH_TIMER=y
-CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
 CONFIG_ARM_GIC_V2M=y
 CONFIG_ARM_GIC_V3=y
 CONFIG_ARM_GIC_V3_ITS=y
@@ -39,16 +34,13 @@ CONFIG_ARM_PSCI_FW=y
 CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
 # CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
 CONFIG_CC_HAVE_STACKPROTECTOR_SYSREG=y
-# CONFIG_DEBUG_ALIGN_RODATA is not set
 CONFIG_DMA_DIRECT_REMAP=y
-CONFIG_DRM_RCAR_WRITEBACK=y
 # CONFIG_FLATMEM_MANUAL is not set
 CONFIG_FRAME_POINTER=y
 # CONFIG_FUJITSU_ERRATUM_010001 is not set
 CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
 CONFIG_GENERIC_CPU_VULNERABILITIES=y
 CONFIG_GENERIC_CSUM=y
-CONFIG_GENERIC_GETTIMEOFDAY=y
 CONFIG_GENERIC_PINCONF=y
 CONFIG_HOLES_IN_ZONE=y
 CONFIG_HW_RANDOM_OMAP=y
diff --git a/target/linux/mvebu/patches-5.10/001-PCI-aardvark-Wait-for-endpoint-to-be-ready-before-tr.patch b/target/linux/mvebu/patches-5.10/001-PCI-aardvark-Wait-for-endpoint-to-be-ready-before-tr.patch
deleted file mode 100644
index 95abbce002..0000000000
--- a/target/linux/mvebu/patches-5.10/001-PCI-aardvark-Wait-for-endpoint-to-be-ready-before-tr.patch
+++ /dev/null
@@ -1,50 +0,0 @@
-From f4c7d053d7f77cd5c1a1ba7c7ce085ddba13d1d7 Mon Sep 17 00:00:00 2001
-From: Remi Pommarel <repk@triplefau.lt>
-Date: Wed, 22 May 2019 23:33:50 +0200
-Subject: [PATCH] PCI: aardvark: Wait for endpoint to be ready before training
- link
-
-When configuring pcie reset pin from gpio (e.g. initially set by
-u-boot) to pcie function this pin goes low for a brief moment
-asserting the PERST# signal. Thus connected device enters fundamental
-reset process and link configuration can only begin after a minimal
-100ms delay (see [1]).
-
-Because the pin configuration comes from the "default" pinctrl it is
-implicitly configured before the probe callback is called:
-
-driver_probe_device()
-  really_probe()
-    ...
-    pinctrl_bind_pins() /* Here pin goes from gpio to PCIE reset
-                           function and PERST# is asserted */
-    ...
-    drv->probe()
-
-[1] "PCI Express Base Specification", REV. 4.0
-    PCI Express, February 19 2014, 6.6.1 Conventional Reset
-
-Signed-off-by: Remi Pommarel <repk@triplefau.lt>
-Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
-Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
----
- drivers/pci/controller/pci-aardvark.c | 8 ++++++++
- 1 file changed, 8 insertions(+)
-
---- a/drivers/pci/controller/pci-aardvark.c
-+++ b/drivers/pci/controller/pci-aardvark.c
-@@ -337,6 +337,14 @@ static void advk_pcie_setup_hw(struct ad
- 	reg |= PIO_CTRL_ADDR_WIN_DISABLE;
- 	advk_writel(pcie, reg, PIO_CTRL);
- 
-+	/*
-+	 * PERST# signal could have been asserted by pinctrl subsystem before
-+	 * probe() callback has been called, making the endpoint going into
-+	 * fundamental reset. As required by PCI Express spec a delay for at
-+	 * least 100ms after such a reset before link training is needed.
-+	 */
-+	msleep(PCI_PM_D3COLD_WAIT);
-+
- 	/* Start link training */
- 	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
- 	reg |= PCIE_CORE_LINK_TRAINING;
diff --git a/target/linux/mvebu/patches-5.10/002-PCI-aardvark-Don-t-rely-on-jiffies-while-holding-spi.patch b/target/linux/mvebu/patches-5.10/002-PCI-aardvark-Don-t-rely-on-jiffies-while-holding-spi.patch
deleted file mode 100644
index db4afd22a2..0000000000
--- a/target/linux/mvebu/patches-5.10/002-PCI-aardvark-Don-t-rely-on-jiffies-while-holding-spi.patch
+++ /dev/null
@@ -1,54 +0,0 @@
-From 7fbcb5da811be7d47468417c7795405058abb3da Mon Sep 17 00:00:00 2001
-From: Remi Pommarel <repk@triplefau.lt>
-Date: Fri, 27 Sep 2019 10:55:02 +0200
-Subject: [PATCH] PCI: aardvark: Don't rely on jiffies while holding spinlock
-
-advk_pcie_wait_pio() can be called while holding a spinlock (from
-pci_bus_read_config_dword()), then depends on jiffies in order to
-timeout while polling on PIO state registers. In the case the PIO
-transaction failed, the timeout will never happen and will also cause
-the cpu to stall.
-
-This decrements a variable and wait instead of using jiffies.
-
-Signed-off-by: Remi Pommarel <repk@triplefau.lt>
-Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
-Reviewed-by: Andrew Murray <andrew.murray@arm.com>
-Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
----
- drivers/pci/controller/pci-aardvark.c | 10 +++++-----
- 1 file changed, 5 insertions(+), 5 deletions(-)
-
---- a/drivers/pci/controller/pci-aardvark.c
-+++ b/drivers/pci/controller/pci-aardvark.c
-@@ -175,7 +175,8 @@
- 	(PCIE_CONF_BUS(bus) | PCIE_CONF_DEV(PCI_SLOT(devfn))	| \
- 	 PCIE_CONF_FUNC(PCI_FUNC(devfn)) | PCIE_CONF_REG(where))
- 
--#define PIO_TIMEOUT_MS			1
-+#define PIO_RETRY_CNT			500
-+#define PIO_RETRY_DELAY			2 /* 2 us*/
- 
- #define LINK_WAIT_MAX_RETRIES		10
- #define LINK_WAIT_USLEEP_MIN		90000
-@@ -400,17 +401,16 @@ static void advk_pcie_check_pio_status(s
- static int advk_pcie_wait_pio(struct advk_pcie *pcie)
- {
- 	struct device *dev = &pcie->pdev->dev;
--	unsigned long timeout;
-+	int i;
- 
--	timeout = jiffies + msecs_to_jiffies(PIO_TIMEOUT_MS);
--
--	while (time_before(jiffies, timeout)) {
-+	for (i = 0; i < PIO_RETRY_CNT; i++) {
- 		u32 start, isr;
- 
- 		start = advk_readl(pcie, PIO_START);
- 		isr = advk_readl(pcie, PIO_ISR);
- 		if (!start && isr)
- 			return 0;
-+		udelay(PIO_RETRY_DELAY);
- 	}
- 
- 	dev_err(dev, "config read/write timed out\n");
diff --git a/target/linux/mvebu/patches-5.10/003-net-mvneta-introduce-mvneta_update_stats-routine.patch b/target/linux/mvebu/patches-5.10/003-net-mvneta-introduce-mvneta_update_stats-routine.patch
deleted file mode 100644
index f6ce6163cf..0000000000
--- a/target/linux/mvebu/patches-5.10/003-net-mvneta-introduce-mvneta_update_stats-routine.patch
+++ /dev/null
@@ -1,95 +0,0 @@
-From ff519e2acd463bff6c5bb4e8d7ed350c9bae885b Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Sat, 19 Oct 2019 10:13:21 +0200
-Subject: [PATCH 1/7] net: mvneta: introduce mvneta_update_stats routine
-
-Introduce mvneta_update_stats routine to collect {rx/tx} statistics
-(packets and bytes). This is a preliminary patch to add XDP support to
-mvneta driver
-
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 43 ++++++++++++++-------------
- 1 file changed, 22 insertions(+), 21 deletions(-)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -1913,6 +1913,23 @@ static void mvneta_rxq_drop_pkts(struct
- 	}
- }
- 
-+static void
-+mvneta_update_stats(struct mvneta_port *pp, u32 pkts,
-+		    u32 len, bool tx)
-+{
-+	struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
-+
-+	u64_stats_update_begin(&stats->syncp);
-+	if (tx) {
-+		stats->tx_packets += pkts;
-+		stats->tx_bytes += len;
-+	} else {
-+		stats->rx_packets += pkts;
-+		stats->rx_bytes += len;
-+	}
-+	u64_stats_update_end(&stats->syncp);
-+}
-+
- static inline
- int mvneta_rx_refill_queue(struct mvneta_port *pp, struct mvneta_rx_queue *rxq)
- {
-@@ -2093,14 +2110,8 @@ static int mvneta_rx_swbm(struct napi_st
- 		rxq->left_size = 0;
- 	}
- 
--	if (rcvd_pkts) {
--		struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
--
--		u64_stats_update_begin(&stats->syncp);
--		stats->rx_packets += rcvd_pkts;
--		stats->rx_bytes   += rcvd_bytes;
--		u64_stats_update_end(&stats->syncp);
--	}
-+	if (rcvd_pkts)
-+		mvneta_update_stats(pp, rcvd_pkts, rcvd_bytes, false);
- 
- 	/* return some buffers to hardware queue, one at a time is too slow */
- 	refill = mvneta_rx_refill_queue(pp, rxq);
-@@ -2223,14 +2234,8 @@ err_drop_frame:
- 		napi_gro_receive(napi, skb);
- 	}
- 
--	if (rcvd_pkts) {
--		struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
--
--		u64_stats_update_begin(&stats->syncp);
--		stats->rx_packets += rcvd_pkts;
--		stats->rx_bytes   += rcvd_bytes;
--		u64_stats_update_end(&stats->syncp);
--	}
-+	if (rcvd_pkts)
-+		mvneta_update_stats(pp, rcvd_pkts, rcvd_bytes, false);
- 
- 	/* Update rxq management counters */
- 	mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_done);
-@@ -2476,7 +2481,6 @@ static netdev_tx_t mvneta_tx(struct sk_b
- 
- out:
- 	if (frags > 0) {
--		struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
- 		struct netdev_queue *nq = netdev_get_tx_queue(dev, txq_id);
- 
- 		netdev_tx_sent_queue(nq, len);
-@@ -2491,10 +2495,7 @@ out:
- 		else
- 			txq->pending += frags;
- 
--		u64_stats_update_begin(&stats->syncp);
--		stats->tx_packets++;
--		stats->tx_bytes  += len;
--		u64_stats_update_end(&stats->syncp);
-+		mvneta_update_stats(pp, 1, len, true);
- 	} else {
- 		dev->stats.tx_dropped++;
- 		dev_kfree_skb_any(skb);
diff --git a/target/linux/mvebu/patches-5.10/004-net-mvneta-introduce-page-pool-API-for-sw-buffer-man.patch b/target/linux/mvebu/patches-5.10/004-net-mvneta-introduce-page-pool-API-for-sw-buffer-man.patch
deleted file mode 100644
index fbcae20f74..0000000000
--- a/target/linux/mvebu/patches-5.10/004-net-mvneta-introduce-page-pool-API-for-sw-buffer-man.patch
+++ /dev/null
@@ -1,181 +0,0 @@
-From 568a3fa24a95476d40afe3f8616bafb543bc4182 Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Sat, 19 Oct 2019 10:13:22 +0200
-Subject: [PATCH 2/7] net: mvneta: introduce page pool API for sw buffer
- manager
-
-Use the page_pool api for allocations and DMA handling instead of
-__dev_alloc_page()/dma_map_page() and free_page()/dma_unmap_page().
-Pages are unmapped using page_pool_release_page before packets
-go into the network stack.
-
-The page_pool API offers buffer recycling capabilities for XDP but
-allocates one page per packet, unless the driver splits and manages
-the allocated page.
-This is a preliminary patch to add XDP support to mvneta driver
-
-Signed-off-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
-Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/Kconfig  |  1 +
- drivers/net/ethernet/marvell/mvneta.c | 83 +++++++++++++++++++++------
- 2 files changed, 65 insertions(+), 19 deletions(-)
-
---- a/drivers/net/ethernet/marvell/Kconfig
-+++ b/drivers/net/ethernet/marvell/Kconfig
-@@ -61,6 +61,7 @@ config MVNETA
- 	depends on ARCH_MVEBU || COMPILE_TEST
- 	select MVMDIO
- 	select PHYLINK
-+	select PAGE_POOL
- 	---help---
- 	  This driver supports the network interface units in the
- 	  Marvell ARMADA XP, ARMADA 370, ARMADA 38x and
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -37,6 +37,7 @@
- #include <net/ip.h>
- #include <net/ipv6.h>
- #include <net/tso.h>
-+#include <net/page_pool.h>
- 
- /* Registers */
- #define MVNETA_RXQ_CONFIG_REG(q)                (0x1400 + ((q) << 2))
-@@ -607,6 +608,10 @@ struct mvneta_rx_queue {
- 	u32 pkts_coal;
- 	u32 time_coal;
- 
-+	/* page_pool */
-+	struct page_pool *page_pool;
-+	struct xdp_rxq_info xdp_rxq;
-+
- 	/* Virtual address of the RX buffer */
- 	void  **buf_virt_addr;
- 
-@@ -1825,23 +1830,21 @@ static int mvneta_rx_refill(struct mvnet
- 			    struct mvneta_rx_queue *rxq,
- 			    gfp_t gfp_mask)
- {
-+	enum dma_data_direction dma_dir;
- 	dma_addr_t phys_addr;
- 	struct page *page;
- 
--	page = __dev_alloc_page(gfp_mask);
-+	page = page_pool_alloc_pages(rxq->page_pool,
-+				     gfp_mask | __GFP_NOWARN);
- 	if (!page)
- 		return -ENOMEM;
- 
--	/* map page for use */
--	phys_addr = dma_map_page(pp->dev->dev.parent, page, 0, PAGE_SIZE,
--				 DMA_FROM_DEVICE);
--	if (unlikely(dma_mapping_error(pp->dev->dev.parent, phys_addr))) {
--		__free_page(page);
--		return -ENOMEM;
--	}
--
--	phys_addr += pp->rx_offset_correction;
-+	phys_addr = page_pool_get_dma_addr(page) + pp->rx_offset_correction;
-+	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
-+	dma_sync_single_for_device(pp->dev->dev.parent, phys_addr,
-+				   PAGE_SIZE, dma_dir);
- 	mvneta_rx_desc_fill(rx_desc, phys_addr, page, rxq);
-+
- 	return 0;
- }
- 
-@@ -1907,10 +1910,12 @@ static void mvneta_rxq_drop_pkts(struct
- 		if (!data || !(rx_desc->buf_phys_addr))
- 			continue;
- 
--		dma_unmap_page(pp->dev->dev.parent, rx_desc->buf_phys_addr,
--			       PAGE_SIZE, DMA_FROM_DEVICE);
--		__free_page(data);
-+		page_pool_put_page(rxq->page_pool, data, false);
- 	}
-+	if (xdp_rxq_info_is_reg(&rxq->xdp_rxq))
-+		xdp_rxq_info_unreg(&rxq->xdp_rxq);
-+	page_pool_destroy(rxq->page_pool);
-+	rxq->page_pool = NULL;
- }
- 
- static void
-@@ -2047,8 +2052,7 @@ static int mvneta_rx_swbm(struct napi_st
- 				skb_add_rx_frag(rxq->skb, frag_num, page,
- 						frag_offset, frag_size,
- 						PAGE_SIZE);
--				dma_unmap_page(dev->dev.parent, phys_addr,
--					       PAGE_SIZE, DMA_FROM_DEVICE);
-+				page_pool_release_page(rxq->page_pool, page);
- 				rxq->left_size -= frag_size;
- 			}
- 		} else {
-@@ -2078,9 +2082,7 @@ static int mvneta_rx_swbm(struct napi_st
- 						frag_offset, frag_size,
- 						PAGE_SIZE);
- 
--				dma_unmap_page(dev->dev.parent, phys_addr,
--					       PAGE_SIZE, DMA_FROM_DEVICE);
--
-+				page_pool_release_page(rxq->page_pool, page);
- 				rxq->left_size -= frag_size;
- 			}
- 		} /* Middle or Last descriptor */
-@@ -2847,11 +2849,54 @@ static int mvneta_poll(struct napi_struc
- 	return rx_done;
- }
- 
-+static int mvneta_create_page_pool(struct mvneta_port *pp,
-+				   struct mvneta_rx_queue *rxq, int size)
-+{
-+	struct page_pool_params pp_params = {
-+		.order = 0,
-+		.flags = PP_FLAG_DMA_MAP,
-+		.pool_size = size,
-+		.nid = cpu_to_node(0),
-+		.dev = pp->dev->dev.parent,
-+		.dma_dir = DMA_FROM_DEVICE,
-+	};
-+	int err;
-+
-+	rxq->page_pool = page_pool_create(&pp_params);
-+	if (IS_ERR(rxq->page_pool)) {
-+		err = PTR_ERR(rxq->page_pool);
-+		rxq->page_pool = NULL;
-+		return err;
-+	}
-+
-+	err = xdp_rxq_info_reg(&rxq->xdp_rxq, pp->dev, rxq->id);
-+	if (err < 0)
-+		goto err_free_pp;
-+
-+	err = xdp_rxq_info_reg_mem_model(&rxq->xdp_rxq, MEM_TYPE_PAGE_POOL,
-+					 rxq->page_pool);
-+	if (err)
-+		goto err_unregister_rxq;
-+
-+	return 0;
-+
-+err_unregister_rxq:
-+	xdp_rxq_info_unreg(&rxq->xdp_rxq);
-+err_free_pp:
-+	page_pool_destroy(rxq->page_pool);
-+	rxq->page_pool = NULL;
-+	return err;
-+}
-+
- /* Handle rxq fill: allocates rxq skbs; called when initializing a port */
- static int mvneta_rxq_fill(struct mvneta_port *pp, struct mvneta_rx_queue *rxq,
- 			   int num)
- {
--	int i;
-+	int i, err;
-+
-+	err = mvneta_create_page_pool(pp, rxq, num);
-+	if (err < 0)
-+		return err;
- 
- 	for (i = 0; i < num; i++) {
- 		memset(rxq->descs + i, 0, sizeof(struct mvneta_rx_desc));
diff --git a/target/linux/mvebu/patches-5.10/005-net-mvneta-rely-on-build_skb-in-mvneta_rx_swbm-poll-.patch b/target/linux/mvebu/patches-5.10/005-net-mvneta-rely-on-build_skb-in-mvneta_rx_swbm-poll-.patch
deleted file mode 100644
index 9038ca8ca8..0000000000
--- a/target/linux/mvebu/patches-5.10/005-net-mvneta-rely-on-build_skb-in-mvneta_rx_swbm-poll-.patch
+++ /dev/null
@@ -1,303 +0,0 @@
-From 8dc9a0888f4c8e27b25e48ff1b4bc2b3a845cc2d Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Sat, 19 Oct 2019 10:13:23 +0200
-Subject: [PATCH 3/7] net: mvneta: rely on build_skb in mvneta_rx_swbm poll
- routine
-
-Refactor mvneta_rx_swbm code introducing mvneta_swbm_rx_frame and
-mvneta_swbm_add_rx_fragment routines. Rely on build_skb in oreder to
-allocate skb since the previous patch introduced buffer recycling using
-the page_pool API.
-This patch fixes even an issue in the original driver where dma buffers
-are accessed before dma sync.
-mvneta driver can run on not cache coherent devices so it is
-necessary to sync DMA buffers before sending them to the device
-in order to avoid memory corruptions. Running perf analysis we can
-see a performance cost associated with this DMA-sync (anyway it is
-already there in the original driver code). In follow up patches we
-will add more logic to reduce DMA-sync as much as possible.
-
-Signed-off-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
-Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 185 +++++++++++++-------------
- 1 file changed, 95 insertions(+), 90 deletions(-)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -325,6 +325,11 @@
- 	      ETH_HLEN + ETH_FCS_LEN,			     \
- 	      cache_line_size())
- 
-+#define MVNETA_SKB_PAD	(SKB_DATA_ALIGN(sizeof(struct skb_shared_info) + \
-+			 NET_SKB_PAD))
-+#define MVNETA_SKB_SIZE(len)	(SKB_DATA_ALIGN(len) + MVNETA_SKB_PAD)
-+#define MVNETA_MAX_RX_BUF_SIZE	(PAGE_SIZE - MVNETA_SKB_PAD)
-+
- #define IS_TSO_HEADER(txq, addr) \
- 	((addr >= txq->tso_hdrs_phys) && \
- 	 (addr < txq->tso_hdrs_phys + txq->size * TSO_HEADER_SIZE))
-@@ -650,7 +655,6 @@ static int txq_number = 8;
- static int rxq_def;
- 
- static int rx_copybreak __read_mostly = 256;
--static int rx_header_size __read_mostly = 128;
- 
- /* HW BM need that each port be identify by a unique ID */
- static int global_port_id;
-@@ -1842,7 +1846,7 @@ static int mvneta_rx_refill(struct mvnet
- 	phys_addr = page_pool_get_dma_addr(page) + pp->rx_offset_correction;
- 	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
- 	dma_sync_single_for_device(pp->dev->dev.parent, phys_addr,
--				   PAGE_SIZE, dma_dir);
-+				   MVNETA_MAX_RX_BUF_SIZE, dma_dir);
- 	mvneta_rx_desc_fill(rx_desc, phys_addr, page, rxq);
- 
- 	return 0;
-@@ -1960,30 +1964,102 @@ int mvneta_rx_refill_queue(struct mvneta
- 	return i;
- }
- 
-+static int
-+mvneta_swbm_rx_frame(struct mvneta_port *pp,
-+		     struct mvneta_rx_desc *rx_desc,
-+		     struct mvneta_rx_queue *rxq,
-+		     struct page *page)
-+{
-+	unsigned char *data = page_address(page);
-+	int data_len = -MVNETA_MH_SIZE, len;
-+	struct net_device *dev = pp->dev;
-+	enum dma_data_direction dma_dir;
-+
-+	if (MVNETA_SKB_SIZE(rx_desc->data_size) > PAGE_SIZE) {
-+		len = MVNETA_MAX_RX_BUF_SIZE;
-+		data_len += len;
-+	} else {
-+		len = rx_desc->data_size;
-+		data_len += len - ETH_FCS_LEN;
-+	}
-+
-+	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
-+	dma_sync_single_for_cpu(dev->dev.parent,
-+				rx_desc->buf_phys_addr,
-+				len, dma_dir);
-+
-+	rxq->skb = build_skb(data, PAGE_SIZE);
-+	if (unlikely(!rxq->skb)) {
-+		netdev_err(dev,
-+			   "Can't allocate skb on queue %d\n",
-+			   rxq->id);
-+		dev->stats.rx_dropped++;
-+		rxq->skb_alloc_err++;
-+		return -ENOMEM;
-+	}
-+	page_pool_release_page(rxq->page_pool, page);
-+
-+	skb_reserve(rxq->skb, MVNETA_MH_SIZE + NET_SKB_PAD);
-+	skb_put(rxq->skb, data_len);
-+	mvneta_rx_csum(pp, rx_desc->status, rxq->skb);
-+
-+	rxq->left_size = rx_desc->data_size - len;
-+	rx_desc->buf_phys_addr = 0;
-+
-+	return 0;
-+}
-+
-+static void
-+mvneta_swbm_add_rx_fragment(struct mvneta_port *pp,
-+			    struct mvneta_rx_desc *rx_desc,
-+			    struct mvneta_rx_queue *rxq,
-+			    struct page *page)
-+{
-+	struct net_device *dev = pp->dev;
-+	enum dma_data_direction dma_dir;
-+	int data_len, len;
-+
-+	if (rxq->left_size > MVNETA_MAX_RX_BUF_SIZE) {
-+		len = MVNETA_MAX_RX_BUF_SIZE;
-+		data_len = len;
-+	} else {
-+		len = rxq->left_size;
-+		data_len = len - ETH_FCS_LEN;
-+	}
-+	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
-+	dma_sync_single_for_cpu(dev->dev.parent,
-+				rx_desc->buf_phys_addr,
-+				len, dma_dir);
-+	if (data_len > 0) {
-+		/* refill descriptor with new buffer later */
-+		skb_add_rx_frag(rxq->skb,
-+				skb_shinfo(rxq->skb)->nr_frags,
-+				page, NET_SKB_PAD, data_len,
-+				PAGE_SIZE);
-+	}
-+	page_pool_release_page(rxq->page_pool, page);
-+	rx_desc->buf_phys_addr = 0;
-+	rxq->left_size -= len;
-+}
-+
- /* Main rx processing when using software buffer management */
- static int mvneta_rx_swbm(struct napi_struct *napi,
- 			  struct mvneta_port *pp, int budget,
- 			  struct mvneta_rx_queue *rxq)
- {
-+	int rcvd_pkts = 0, rcvd_bytes = 0, rx_proc = 0;
- 	struct net_device *dev = pp->dev;
--	int rx_todo, rx_proc;
--	int refill = 0;
--	u32 rcvd_pkts = 0;
--	u32 rcvd_bytes = 0;
-+	int rx_todo, refill;
- 
- 	/* Get number of received packets */
- 	rx_todo = mvneta_rxq_busy_desc_num_get(pp, rxq);
--	rx_proc = 0;
- 
- 	/* Fairness NAPI loop */
--	while ((rcvd_pkts < budget) && (rx_proc < rx_todo)) {
-+	while (rx_proc < budget && rx_proc < rx_todo) {
- 		struct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);
-+		u32 rx_status, index;
- 		unsigned char *data;
- 		struct page *page;
--		dma_addr_t phys_addr;
--		u32 rx_status, index;
--		int rx_bytes, skb_size, copy_size;
--		int frag_num, frag_size, frag_offset;
- 
- 		index = rx_desc - rxq->descs;
- 		page = (struct page *)rxq->buf_virt_addr[index];
-@@ -1991,100 +2067,30 @@ static int mvneta_rx_swbm(struct napi_st
- 		/* Prefetch header */
- 		prefetch(data);
- 
--		phys_addr = rx_desc->buf_phys_addr;
- 		rx_status = rx_desc->status;
- 		rx_proc++;
- 		rxq->refill_num++;
- 
- 		if (rx_status & MVNETA_RXD_FIRST_DESC) {
-+			int err;
-+
- 			/* Check errors only for FIRST descriptor */
- 			if (rx_status & MVNETA_RXD_ERR_SUMMARY) {
- 				mvneta_rx_error(pp, rx_desc);
- 				/* leave the descriptor untouched */
- 				continue;
- 			}
--			rx_bytes = rx_desc->data_size -
--				   (ETH_FCS_LEN + MVNETA_MH_SIZE);
--
--			/* Allocate small skb for each new packet */
--			skb_size = max(rx_copybreak, rx_header_size);
--			rxq->skb = netdev_alloc_skb_ip_align(dev, skb_size);
--			if (unlikely(!rxq->skb)) {
--				struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
--
--				netdev_err(dev,
--					   "Can't allocate skb on queue %d\n",
--					   rxq->id);
--
--				rxq->skb_alloc_err++;
- 
--				u64_stats_update_begin(&stats->syncp);
--				stats->rx_dropped++;
--				u64_stats_update_end(&stats->syncp);
-+			err = mvneta_swbm_rx_frame(pp, rx_desc, rxq, page);
-+			if (err)
- 				continue;
--			}
--			copy_size = min(skb_size, rx_bytes);
--
--			/* Copy data from buffer to SKB, skip Marvell header */
--			memcpy(rxq->skb->data, data + MVNETA_MH_SIZE,
--			       copy_size);
--			skb_put(rxq->skb, copy_size);
--			rxq->left_size = rx_bytes - copy_size;
--
--			mvneta_rx_csum(pp, rx_status, rxq->skb);
--			if (rxq->left_size == 0) {
--				int size = copy_size + MVNETA_MH_SIZE;
--
--				dma_sync_single_range_for_cpu(dev->dev.parent,
--							      phys_addr, 0,
--							      size,
--							      DMA_FROM_DEVICE);
--
--				/* leave the descriptor and buffer untouched */
--			} else {
--				/* refill descriptor with new buffer later */
--				rx_desc->buf_phys_addr = 0;
--
--				frag_num = 0;
--				frag_offset = copy_size + MVNETA_MH_SIZE;
--				frag_size = min(rxq->left_size,
--						(int)(PAGE_SIZE - frag_offset));
--				skb_add_rx_frag(rxq->skb, frag_num, page,
--						frag_offset, frag_size,
--						PAGE_SIZE);
--				page_pool_release_page(rxq->page_pool, page);
--				rxq->left_size -= frag_size;
--			}
- 		} else {
--			/* Middle or Last descriptor */
- 			if (unlikely(!rxq->skb)) {
- 				pr_debug("no skb for rx_status 0x%x\n",
- 					 rx_status);
- 				continue;
- 			}
--			if (!rxq->left_size) {
--				/* last descriptor has only FCS */
--				/* and can be discarded */
--				dma_sync_single_range_for_cpu(dev->dev.parent,
--							      phys_addr, 0,
--							      ETH_FCS_LEN,
--							      DMA_FROM_DEVICE);
--				/* leave the descriptor and buffer untouched */
--			} else {
--				/* refill descriptor with new buffer later */
--				rx_desc->buf_phys_addr = 0;
--
--				frag_num = skb_shinfo(rxq->skb)->nr_frags;
--				frag_offset = 0;
--				frag_size = min(rxq->left_size,
--						(int)(PAGE_SIZE - frag_offset));
--				skb_add_rx_frag(rxq->skb, frag_num, page,
--						frag_offset, frag_size,
--						PAGE_SIZE);
--
--				page_pool_release_page(rxq->page_pool, page);
--				rxq->left_size -= frag_size;
--			}
-+			mvneta_swbm_add_rx_fragment(pp, rx_desc, rxq, page);
- 		} /* Middle or Last descriptor */
- 
- 		if (!(rx_status & MVNETA_RXD_LAST_DESC))
-@@ -2109,7 +2115,6 @@ static int mvneta_rx_swbm(struct napi_st
- 
- 		/* clean uncomplete skb pointer in queue */
- 		rxq->skb = NULL;
--		rxq->left_size = 0;
- 	}
- 
- 	if (rcvd_pkts)
-@@ -2970,7 +2975,7 @@ static void mvneta_rxq_hw_init(struct mv
- 		/* Set Offset */
- 		mvneta_rxq_offset_set(pp, rxq, 0);
- 		mvneta_rxq_buf_size_set(pp, rxq, PAGE_SIZE < SZ_64K ?
--					PAGE_SIZE :
-+					MVNETA_MAX_RX_BUF_SIZE :
- 					MVNETA_RX_BUF_SIZE(pp->pkt_size));
- 		mvneta_rxq_bm_disable(pp, rxq);
- 		mvneta_rxq_fill(pp, rxq, rxq->size);
-@@ -4708,7 +4713,7 @@ static int mvneta_probe(struct platform_
- 	SET_NETDEV_DEV(dev, &pdev->dev);
- 
- 	pp->id = global_port_id++;
--	pp->rx_offset_correction = 0; /* not relevant for SW BM */
-+	pp->rx_offset_correction = NET_SKB_PAD;
- 
- 	/* Obtain access to BM resources if enabled and already initialized */
- 	bm_node = of_parse_phandle(dn, "buffer-manager", 0);
diff --git a/target/linux/mvebu/patches-5.10/006-net-mvneta-add-basic-XDP-support.patch b/target/linux/mvebu/patches-5.10/006-net-mvneta-add-basic-XDP-support.patch
deleted file mode 100644
index 163632df51..0000000000
--- a/target/linux/mvebu/patches-5.10/006-net-mvneta-add-basic-XDP-support.patch
+++ /dev/null
@@ -1,311 +0,0 @@
-From 0db51da7a8e99f0803ec3a8e25c1a66234a219cb Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Sat, 19 Oct 2019 10:13:24 +0200
-Subject: [PATCH 4/7] net: mvneta: add basic XDP support
-
-Add basic XDP support to mvneta driver for devices that rely on software
-buffer management. Currently supported verdicts are:
-- XDP_DROP
-- XDP_PASS
-- XDP_REDIRECT
-- XDP_ABORTED
-
-- iptables drop:
-$iptables -t raw -I PREROUTING -p udp --dport 9 -j DROP
-$nstat -n && sleep 1 && nstat
-IpInReceives		151169		0.0
-IpExtInOctets		6953544		0.0
-IpExtInNoECTPkts	151165		0.0
-
-- XDP_DROP via xdp1
-$./samples/bpf/xdp1 3
-proto 0:	421419 pkt/s
-proto 0:	421444 pkt/s
-proto 0:	421393 pkt/s
-proto 0:	421440 pkt/s
-proto 0:	421184 pkt/s
-
-Tested-by: Matteo Croce <mcroce@redhat.com>
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 148 ++++++++++++++++++++++++--
- 1 file changed, 139 insertions(+), 9 deletions(-)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -38,6 +38,7 @@
- #include <net/ipv6.h>
- #include <net/tso.h>
- #include <net/page_pool.h>
-+#include <linux/bpf_trace.h>
- 
- /* Registers */
- #define MVNETA_RXQ_CONFIG_REG(q)                (0x1400 + ((q) << 2))
-@@ -325,8 +326,10 @@
- 	      ETH_HLEN + ETH_FCS_LEN,			     \
- 	      cache_line_size())
- 
-+#define MVNETA_SKB_HEADROOM	(max(XDP_PACKET_HEADROOM, NET_SKB_PAD) + \
-+				 NET_IP_ALIGN)
- #define MVNETA_SKB_PAD	(SKB_DATA_ALIGN(sizeof(struct skb_shared_info) + \
--			 NET_SKB_PAD))
-+			 MVNETA_SKB_HEADROOM))
- #define MVNETA_SKB_SIZE(len)	(SKB_DATA_ALIGN(len) + MVNETA_SKB_PAD)
- #define MVNETA_MAX_RX_BUF_SIZE	(PAGE_SIZE - MVNETA_SKB_PAD)
- 
-@@ -354,6 +357,11 @@ struct mvneta_statistic {
- #define T_REG_64	64
- #define T_SW		1
- 
-+#define MVNETA_XDP_PASS		BIT(0)
-+#define MVNETA_XDP_DROPPED	BIT(1)
-+#define MVNETA_XDP_TX		BIT(2)
-+#define MVNETA_XDP_REDIR	BIT(3)
-+
- static const struct mvneta_statistic mvneta_statistics[] = {
- 	{ 0x3000, T_REG_64, "good_octets_received", },
- 	{ 0x3010, T_REG_32, "good_frames_received", },
-@@ -435,6 +443,8 @@ struct mvneta_port {
- 	u32 cause_rx_tx;
- 	struct napi_struct napi;
- 
-+	struct bpf_prog *xdp_prog;
-+
- 	/* Core clock */
- 	struct clk *clk;
- 	/* AXI clock */
-@@ -1965,10 +1975,50 @@ int mvneta_rx_refill_queue(struct mvneta
- }
- 
- static int
-+mvneta_run_xdp(struct mvneta_port *pp, struct mvneta_rx_queue *rxq,
-+	       struct bpf_prog *prog, struct xdp_buff *xdp)
-+{
-+	u32 ret, act = bpf_prog_run_xdp(prog, xdp);
-+
-+	switch (act) {
-+	case XDP_PASS:
-+		ret = MVNETA_XDP_PASS;
-+		break;
-+	case XDP_REDIRECT: {
-+		int err;
-+
-+		err = xdp_do_redirect(pp->dev, xdp, prog);
-+		if (err) {
-+			ret = MVNETA_XDP_DROPPED;
-+			xdp_return_buff(xdp);
-+		} else {
-+			ret = MVNETA_XDP_REDIR;
-+		}
-+		break;
-+	}
-+	default:
-+		bpf_warn_invalid_xdp_action(act);
-+		/* fall through */
-+	case XDP_ABORTED:
-+		trace_xdp_exception(pp->dev, prog, act);
-+		/* fall through */
-+	case XDP_DROP:
-+		page_pool_recycle_direct(rxq->page_pool,
-+					 virt_to_head_page(xdp->data));
-+		ret = MVNETA_XDP_DROPPED;
-+		break;
-+	}
-+
-+	return ret;
-+}
-+
-+static int
- mvneta_swbm_rx_frame(struct mvneta_port *pp,
- 		     struct mvneta_rx_desc *rx_desc,
- 		     struct mvneta_rx_queue *rxq,
--		     struct page *page)
-+		     struct xdp_buff *xdp,
-+		     struct bpf_prog *xdp_prog,
-+		     struct page *page, u32 *xdp_ret)
- {
- 	unsigned char *data = page_address(page);
- 	int data_len = -MVNETA_MH_SIZE, len;
-@@ -1988,7 +2038,26 @@ mvneta_swbm_rx_frame(struct mvneta_port
- 				rx_desc->buf_phys_addr,
- 				len, dma_dir);
- 
--	rxq->skb = build_skb(data, PAGE_SIZE);
-+	xdp->data_hard_start = data;
-+	xdp->data = data + MVNETA_SKB_HEADROOM + MVNETA_MH_SIZE;
-+	xdp->data_end = xdp->data + data_len;
-+	xdp_set_data_meta_invalid(xdp);
-+
-+	if (xdp_prog) {
-+		u32 ret;
-+
-+		ret = mvneta_run_xdp(pp, rxq, xdp_prog, xdp);
-+		if (ret != MVNETA_XDP_PASS) {
-+			mvneta_update_stats(pp, 1,
-+					    xdp->data_end - xdp->data,
-+					    false);
-+			rx_desc->buf_phys_addr = 0;
-+			*xdp_ret |= ret;
-+			return ret;
-+		}
-+	}
-+
-+	rxq->skb = build_skb(xdp->data_hard_start, PAGE_SIZE);
- 	if (unlikely(!rxq->skb)) {
- 		netdev_err(dev,
- 			   "Can't allocate skb on queue %d\n",
-@@ -1999,8 +2068,9 @@ mvneta_swbm_rx_frame(struct mvneta_port
- 	}
- 	page_pool_release_page(rxq->page_pool, page);
- 
--	skb_reserve(rxq->skb, MVNETA_MH_SIZE + NET_SKB_PAD);
--	skb_put(rxq->skb, data_len);
-+	skb_reserve(rxq->skb,
-+		    xdp->data - xdp->data_hard_start);
-+	skb_put(rxq->skb, xdp->data_end - xdp->data);
- 	mvneta_rx_csum(pp, rx_desc->status, rxq->skb);
- 
- 	rxq->left_size = rx_desc->data_size - len;
-@@ -2034,7 +2104,7 @@ mvneta_swbm_add_rx_fragment(struct mvnet
- 		/* refill descriptor with new buffer later */
- 		skb_add_rx_frag(rxq->skb,
- 				skb_shinfo(rxq->skb)->nr_frags,
--				page, NET_SKB_PAD, data_len,
-+				page, MVNETA_SKB_HEADROOM, data_len,
- 				PAGE_SIZE);
- 	}
- 	page_pool_release_page(rxq->page_pool, page);
-@@ -2049,11 +2119,18 @@ static int mvneta_rx_swbm(struct napi_st
- {
- 	int rcvd_pkts = 0, rcvd_bytes = 0, rx_proc = 0;
- 	struct net_device *dev = pp->dev;
-+	struct bpf_prog *xdp_prog;
-+	struct xdp_buff xdp_buf;
- 	int rx_todo, refill;
-+	u32 xdp_ret = 0;
- 
- 	/* Get number of received packets */
- 	rx_todo = mvneta_rxq_busy_desc_num_get(pp, rxq);
- 
-+	rcu_read_lock();
-+	xdp_prog = READ_ONCE(pp->xdp_prog);
-+	xdp_buf.rxq = &rxq->xdp_rxq;
-+
- 	/* Fairness NAPI loop */
- 	while (rx_proc < budget && rx_proc < rx_todo) {
- 		struct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);
-@@ -2081,7 +2158,8 @@ static int mvneta_rx_swbm(struct napi_st
- 				continue;
- 			}
- 
--			err = mvneta_swbm_rx_frame(pp, rx_desc, rxq, page);
-+			err = mvneta_swbm_rx_frame(pp, rx_desc, rxq, &xdp_buf,
-+						   xdp_prog, page, &xdp_ret);
- 			if (err)
- 				continue;
- 		} else {
-@@ -2116,6 +2194,10 @@ static int mvneta_rx_swbm(struct napi_st
- 		/* clean uncomplete skb pointer in queue */
- 		rxq->skb = NULL;
- 	}
-+	rcu_read_unlock();
-+
-+	if (xdp_ret & MVNETA_XDP_REDIR)
-+		xdp_do_flush_map();
- 
- 	if (rcvd_pkts)
- 		mvneta_update_stats(pp, rcvd_pkts, rcvd_bytes, false);
-@@ -2857,13 +2939,14 @@ static int mvneta_poll(struct napi_struc
- static int mvneta_create_page_pool(struct mvneta_port *pp,
- 				   struct mvneta_rx_queue *rxq, int size)
- {
-+	struct bpf_prog *xdp_prog = READ_ONCE(pp->xdp_prog);
- 	struct page_pool_params pp_params = {
- 		.order = 0,
- 		.flags = PP_FLAG_DMA_MAP,
- 		.pool_size = size,
- 		.nid = cpu_to_node(0),
- 		.dev = pp->dev->dev.parent,
--		.dma_dir = DMA_FROM_DEVICE,
-+		.dma_dir = xdp_prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE,
- 	};
- 	int err;
- 
-@@ -3364,6 +3447,11 @@ static int mvneta_change_mtu(struct net_
- 		mtu = ALIGN(MVNETA_RX_PKT_SIZE(mtu), 8);
- 	}
- 
-+	if (pp->xdp_prog && mtu > MVNETA_MAX_RX_BUF_SIZE) {
-+		netdev_info(dev, "Illegal MTU value %d for XDP mode\n", mtu);
-+		return -EINVAL;
-+	}
-+
- 	dev->mtu = mtu;
- 
- 	if (!netif_running(dev)) {
-@@ -4029,6 +4117,47 @@ static int mvneta_ioctl(struct net_devic
- 	return phylink_mii_ioctl(pp->phylink, ifr, cmd);
- }
- 
-+static int mvneta_xdp_setup(struct net_device *dev, struct bpf_prog *prog,
-+			    struct netlink_ext_ack *extack)
-+{
-+	bool need_update, running = netif_running(dev);
-+	struct mvneta_port *pp = netdev_priv(dev);
-+	struct bpf_prog *old_prog;
-+
-+	if (prog && dev->mtu > MVNETA_MAX_RX_BUF_SIZE) {
-+		NL_SET_ERR_MSG_MOD(extack, "Jumbo frames not supported on XDP");
-+		return -EOPNOTSUPP;
-+	}
-+
-+	need_update = !!pp->xdp_prog != !!prog;
-+	if (running && need_update)
-+		mvneta_stop(dev);
-+
-+	old_prog = xchg(&pp->xdp_prog, prog);
-+	if (old_prog)
-+		bpf_prog_put(old_prog);
-+
-+	if (running && need_update)
-+		return mvneta_open(dev);
-+
-+	return 0;
-+}
-+
-+static int mvneta_xdp(struct net_device *dev, struct netdev_bpf *xdp)
-+{
-+	struct mvneta_port *pp = netdev_priv(dev);
-+
-+	switch (xdp->command) {
-+	case XDP_SETUP_PROG:
-+		return mvneta_xdp_setup(dev, xdp->prog, xdp->extack);
-+	case XDP_QUERY_PROG:
-+		xdp->prog_id = pp->xdp_prog ? pp->xdp_prog->aux->id : 0;
-+		return 0;
-+	default:
-+		return -EINVAL;
-+	}
-+}
-+
- /* Ethtool methods */
- 
- /* Set link ksettings (phy address, speed) for ethtools */
-@@ -4425,6 +4554,7 @@ static const struct net_device_ops mvnet
- 	.ndo_fix_features    = mvneta_fix_features,
- 	.ndo_get_stats64     = mvneta_get_stats64,
- 	.ndo_do_ioctl        = mvneta_ioctl,
-+	.ndo_bpf             = mvneta_xdp,
- };
- 
- static const struct ethtool_ops mvneta_eth_tool_ops = {
-@@ -4713,7 +4843,7 @@ static int mvneta_probe(struct platform_
- 	SET_NETDEV_DEV(dev, &pdev->dev);
- 
- 	pp->id = global_port_id++;
--	pp->rx_offset_correction = NET_SKB_PAD;
-+	pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
- 
- 	/* Obtain access to BM resources if enabled and already initialized */
- 	bm_node = of_parse_phandle(dn, "buffer-manager", 0);
diff --git a/target/linux/mvebu/patches-5.10/007-gpio-mvebu-avoid_error_message_for_optional_IRQ.patch b/target/linux/mvebu/patches-5.10/007-gpio-mvebu-avoid_error_message_for_optional_IRQ.patch
deleted file mode 100644
index 00d2b30d58..0000000000
--- a/target/linux/mvebu/patches-5.10/007-gpio-mvebu-avoid_error_message_for_optional_IRQ.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From 525b0858ff2fdb78defec2d4d6d63baaa423d5fd Mon Sep 17 00:00:00 2001
-From: Chris Packham <chris.packham@alliedtelesis.co.nz>
-Date: Fri, 13 Mar 2020 16:42:44 +1300
-Subject: [PATCH] gpio: mvebu: avoid error message for optional IRQ
-
-platform_get_irq() will generate an error message if the requested irq
-is not present
-
-  mvebu-gpio f1010140.gpio: IRQ index 3 not found
-
-use platform_get_irq_optional() to avoid the error message being
-generated.
-
-Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
-Acked-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
-Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
----
- drivers/gpio/gpio-mvebu.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/gpio/gpio-mvebu.c
-+++ b/drivers/gpio/gpio-mvebu.c
-@@ -1248,7 +1248,7 @@ static int mvebu_gpio_probe(struct platf
- 	 * pins.
- 	 */
- 	for (i = 0; i < 4; i++) {
--		int irq = platform_get_irq(pdev, i);
-+		int irq = platform_get_irq_optional(pdev, i);
- 
- 		if (irq < 0)
- 			continue;
diff --git a/target/linux/mvebu/patches-5.10/007-net-mvneta-move-header-prefetch-in-mvneta_swbm_rx_fr.patch b/target/linux/mvebu/patches-5.10/007-net-mvneta-move-header-prefetch-in-mvneta_swbm_rx_fr.patch
deleted file mode 100644
index e075796e41..0000000000
--- a/target/linux/mvebu/patches-5.10/007-net-mvneta-move-header-prefetch-in-mvneta_swbm_rx_fr.patch
+++ /dev/null
@@ -1,43 +0,0 @@
-From fa383f6b77a2ed788266fa8fbfb659aa284d2f58 Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Sat, 19 Oct 2019 10:13:25 +0200
-Subject: [PATCH 5/7] net: mvneta: move header prefetch in mvneta_swbm_rx_frame
-
-Move data buffer prefetch in mvneta_swbm_rx_frame after
-dma_sync_single_range_for_cpu
-
-Signed-off-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
-Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 7 +++----
- 1 file changed, 3 insertions(+), 4 deletions(-)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -2038,6 +2038,9 @@ mvneta_swbm_rx_frame(struct mvneta_port
- 				rx_desc->buf_phys_addr,
- 				len, dma_dir);
- 
-+	/* Prefetch header */
-+	prefetch(data);
-+
- 	xdp->data_hard_start = data;
- 	xdp->data = data + MVNETA_SKB_HEADROOM + MVNETA_MH_SIZE;
- 	xdp->data_end = xdp->data + data_len;
-@@ -2135,14 +2138,10 @@ static int mvneta_rx_swbm(struct napi_st
- 	while (rx_proc < budget && rx_proc < rx_todo) {
- 		struct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);
- 		u32 rx_status, index;
--		unsigned char *data;
- 		struct page *page;
- 
- 		index = rx_desc - rxq->descs;
- 		page = (struct page *)rxq->buf_virt_addr[index];
--		data = page_address(page);
--		/* Prefetch header */
--		prefetch(data);
- 
- 		rx_status = rx_desc->status;
- 		rx_proc++;
diff --git a/target/linux/mvebu/patches-5.10/008-net-mvneta-make-tx-buffer-array-agnostic.patch b/target/linux/mvebu/patches-5.10/008-net-mvneta-make-tx-buffer-array-agnostic.patch
deleted file mode 100644
index e79aa816b8..0000000000
--- a/target/linux/mvebu/patches-5.10/008-net-mvneta-make-tx-buffer-array-agnostic.patch
+++ /dev/null
@@ -1,210 +0,0 @@
-From 9e58c8b410650b5a6eb5b8fad8474bd8425a4023 Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Sat, 19 Oct 2019 10:13:26 +0200
-Subject: [PATCH 6/7] net: mvneta: make tx buffer array agnostic
-
-Allow tx buffer array to contain both skb and xdp buffers in order to
-enable xdp frame recycling adding XDP_TX verdict support
-
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 66 +++++++++++++++++----------
- 1 file changed, 43 insertions(+), 23 deletions(-)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -565,6 +565,20 @@ struct mvneta_rx_desc {
- };
- #endif
- 
-+enum mvneta_tx_buf_type {
-+	MVNETA_TYPE_SKB,
-+	MVNETA_TYPE_XDP_TX,
-+	MVNETA_TYPE_XDP_NDO,
-+};
-+
-+struct mvneta_tx_buf {
-+	enum mvneta_tx_buf_type type;
-+	union {
-+		struct xdp_frame *xdpf;
-+		struct sk_buff *skb;
-+	};
-+};
-+
- struct mvneta_tx_queue {
- 	/* Number of this TX queue, in the range 0-7 */
- 	u8 id;
-@@ -580,8 +594,8 @@ struct mvneta_tx_queue {
- 	int tx_stop_threshold;
- 	int tx_wake_threshold;
- 
--	/* Array of transmitted skb */
--	struct sk_buff **tx_skb;
-+	/* Array of transmitted buffers */
-+	struct mvneta_tx_buf *buf;
- 
- 	/* Index of last TX DMA descriptor that was inserted */
- 	int txq_put_index;
-@@ -1793,14 +1807,9 @@ static void mvneta_txq_bufs_free(struct
- 	int i;
- 
- 	for (i = 0; i < num; i++) {
-+		struct mvneta_tx_buf *buf = &txq->buf[txq->txq_get_index];
- 		struct mvneta_tx_desc *tx_desc = txq->descs +
- 			txq->txq_get_index;
--		struct sk_buff *skb = txq->tx_skb[txq->txq_get_index];
--
--		if (skb) {
--			bytes_compl += skb->len;
--			pkts_compl++;
--		}
- 
- 		mvneta_txq_inc_get(txq);
- 
-@@ -1808,9 +1817,12 @@ static void mvneta_txq_bufs_free(struct
- 			dma_unmap_single(pp->dev->dev.parent,
- 					 tx_desc->buf_phys_addr,
- 					 tx_desc->data_size, DMA_TO_DEVICE);
--		if (!skb)
-+		if (!buf->skb)
- 			continue;
--		dev_kfree_skb_any(skb);
-+
-+		bytes_compl += buf->skb->len;
-+		pkts_compl++;
-+		dev_kfree_skb_any(buf->skb);
- 	}
- 
- 	netdev_tx_completed_queue(nq, pkts_compl, bytes_compl);
-@@ -2335,16 +2347,19 @@ static inline void
- mvneta_tso_put_hdr(struct sk_buff *skb,
- 		   struct mvneta_port *pp, struct mvneta_tx_queue *txq)
- {
--	struct mvneta_tx_desc *tx_desc;
- 	int hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
-+	struct mvneta_tx_buf *buf = &txq->buf[txq->txq_put_index];
-+	struct mvneta_tx_desc *tx_desc;
- 
--	txq->tx_skb[txq->txq_put_index] = NULL;
- 	tx_desc = mvneta_txq_next_desc_get(txq);
- 	tx_desc->data_size = hdr_len;
- 	tx_desc->command = mvneta_skb_tx_csum(pp, skb);
- 	tx_desc->command |= MVNETA_TXD_F_DESC;
- 	tx_desc->buf_phys_addr = txq->tso_hdrs_phys +
- 				 txq->txq_put_index * TSO_HEADER_SIZE;
-+	buf->type = MVNETA_TYPE_SKB;
-+	buf->skb = NULL;
-+
- 	mvneta_txq_inc_put(txq);
- }
- 
-@@ -2353,6 +2368,7 @@ mvneta_tso_put_data(struct net_device *d
- 		    struct sk_buff *skb, char *data, int size,
- 		    bool last_tcp, bool is_last)
- {
-+	struct mvneta_tx_buf *buf = &txq->buf[txq->txq_put_index];
- 	struct mvneta_tx_desc *tx_desc;
- 
- 	tx_desc = mvneta_txq_next_desc_get(txq);
-@@ -2366,7 +2382,8 @@ mvneta_tso_put_data(struct net_device *d
- 	}
- 
- 	tx_desc->command = 0;
--	txq->tx_skb[txq->txq_put_index] = NULL;
-+	buf->type = MVNETA_TYPE_SKB;
-+	buf->skb = NULL;
- 
- 	if (last_tcp) {
- 		/* last descriptor in the TCP packet */
-@@ -2374,7 +2391,7 @@ mvneta_tso_put_data(struct net_device *d
- 
- 		/* last descriptor in SKB */
- 		if (is_last)
--			txq->tx_skb[txq->txq_put_index] = skb;
-+			buf->skb = skb;
- 	}
- 	mvneta_txq_inc_put(txq);
- 	return 0;
-@@ -2459,6 +2476,7 @@ static int mvneta_tx_frag_process(struct
- 	int i, nr_frags = skb_shinfo(skb)->nr_frags;
- 
- 	for (i = 0; i < nr_frags; i++) {
-+		struct mvneta_tx_buf *buf = &txq->buf[txq->txq_put_index];
- 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
- 		void *addr = skb_frag_address(frag);
- 
-@@ -2478,12 +2496,13 @@ static int mvneta_tx_frag_process(struct
- 		if (i == nr_frags - 1) {
- 			/* Last descriptor */
- 			tx_desc->command = MVNETA_TXD_L_DESC | MVNETA_TXD_Z_PAD;
--			txq->tx_skb[txq->txq_put_index] = skb;
-+			buf->skb = skb;
- 		} else {
- 			/* Descriptor in the middle: Not First, Not Last */
- 			tx_desc->command = 0;
--			txq->tx_skb[txq->txq_put_index] = NULL;
-+			buf->skb = NULL;
- 		}
-+		buf->type = MVNETA_TYPE_SKB;
- 		mvneta_txq_inc_put(txq);
- 	}
- 
-@@ -2511,6 +2530,7 @@ static netdev_tx_t mvneta_tx(struct sk_b
- 	struct mvneta_port *pp = netdev_priv(dev);
- 	u16 txq_id = skb_get_queue_mapping(skb);
- 	struct mvneta_tx_queue *txq = &pp->txqs[txq_id];
-+	struct mvneta_tx_buf *buf = &txq->buf[txq->txq_put_index];
- 	struct mvneta_tx_desc *tx_desc;
- 	int len = skb->len;
- 	int frags = 0;
-@@ -2543,16 +2563,17 @@ static netdev_tx_t mvneta_tx(struct sk_b
- 		goto out;
- 	}
- 
-+	buf->type = MVNETA_TYPE_SKB;
- 	if (frags == 1) {
- 		/* First and Last descriptor */
- 		tx_cmd |= MVNETA_TXD_FLZ_DESC;
- 		tx_desc->command = tx_cmd;
--		txq->tx_skb[txq->txq_put_index] = skb;
-+		buf->skb = skb;
- 		mvneta_txq_inc_put(txq);
- 	} else {
- 		/* First but not Last */
- 		tx_cmd |= MVNETA_TXD_F_DESC;
--		txq->tx_skb[txq->txq_put_index] = NULL;
-+		buf->skb = NULL;
- 		mvneta_txq_inc_put(txq);
- 		tx_desc->command = tx_cmd;
- 		/* Continue with other skb fragments */
-@@ -3138,9 +3159,8 @@ static int mvneta_txq_sw_init(struct mvn
- 
- 	txq->last_desc = txq->size - 1;
- 
--	txq->tx_skb = kmalloc_array(txq->size, sizeof(*txq->tx_skb),
--				    GFP_KERNEL);
--	if (!txq->tx_skb) {
-+	txq->buf = kmalloc_array(txq->size, sizeof(*txq->buf), GFP_KERNEL);
-+	if (!txq->buf) {
- 		dma_free_coherent(pp->dev->dev.parent,
- 				  txq->size * MVNETA_DESC_ALIGNED_SIZE,
- 				  txq->descs, txq->descs_phys);
-@@ -3152,7 +3172,7 @@ static int mvneta_txq_sw_init(struct mvn
- 					   txq->size * TSO_HEADER_SIZE,
- 					   &txq->tso_hdrs_phys, GFP_KERNEL);
- 	if (!txq->tso_hdrs) {
--		kfree(txq->tx_skb);
-+		kfree(txq->buf);
- 		dma_free_coherent(pp->dev->dev.parent,
- 				  txq->size * MVNETA_DESC_ALIGNED_SIZE,
- 				  txq->descs, txq->descs_phys);
-@@ -3205,7 +3225,7 @@ static void mvneta_txq_sw_deinit(struct
- {
- 	struct netdev_queue *nq = netdev_get_tx_queue(pp->dev, txq->id);
- 
--	kfree(txq->tx_skb);
-+	kfree(txq->buf);
- 
- 	if (txq->tso_hdrs)
- 		dma_free_coherent(pp->dev->dev.parent,
diff --git a/target/linux/mvebu/patches-5.10/009-net-mvneta-add-XDP_TX-support.patch b/target/linux/mvebu/patches-5.10/009-net-mvneta-add-XDP_TX-support.patch
deleted file mode 100644
index c971030a1e..0000000000
--- a/target/linux/mvebu/patches-5.10/009-net-mvneta-add-XDP_TX-support.patch
+++ /dev/null
@@ -1,175 +0,0 @@
-From b0a43db9087a21d96e1a0b716b8d9963064b2d58 Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Sat, 19 Oct 2019 10:13:27 +0200
-Subject: [PATCH 7/7] net: mvneta: add XDP_TX support
-
-Implement XDP_TX verdict and ndo_xdp_xmit net_device_ops function
-pointer
-
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 128 ++++++++++++++++++++++++--
- 1 file changed, 121 insertions(+), 7 deletions(-)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -1813,16 +1813,19 @@ static void mvneta_txq_bufs_free(struct
- 
- 		mvneta_txq_inc_get(txq);
- 
--		if (!IS_TSO_HEADER(txq, tx_desc->buf_phys_addr))
-+		if (!IS_TSO_HEADER(txq, tx_desc->buf_phys_addr) &&
-+		    buf->type != MVNETA_TYPE_XDP_TX)
- 			dma_unmap_single(pp->dev->dev.parent,
- 					 tx_desc->buf_phys_addr,
- 					 tx_desc->data_size, DMA_TO_DEVICE);
--		if (!buf->skb)
--			continue;
--
--		bytes_compl += buf->skb->len;
--		pkts_compl++;
--		dev_kfree_skb_any(buf->skb);
-+		if (buf->type == MVNETA_TYPE_SKB && buf->skb) {
-+			bytes_compl += buf->skb->len;
-+			pkts_compl++;
-+			dev_kfree_skb_any(buf->skb);
-+		} else if (buf->type == MVNETA_TYPE_XDP_TX ||
-+			   buf->type == MVNETA_TYPE_XDP_NDO) {
-+			xdp_return_frame(buf->xdpf);
-+		}
- 	}
- 
- 	netdev_tx_completed_queue(nq, pkts_compl, bytes_compl);
-@@ -1987,6 +1990,111 @@ int mvneta_rx_refill_queue(struct mvneta
- }
- 
- static int
-+mvneta_xdp_submit_frame(struct mvneta_port *pp, struct mvneta_tx_queue *txq,
-+			struct xdp_frame *xdpf, bool dma_map)
-+{
-+	struct mvneta_tx_desc *tx_desc;
-+	struct mvneta_tx_buf *buf;
-+	dma_addr_t dma_addr;
-+
-+	if (txq->count >= txq->tx_stop_threshold)
-+		return MVNETA_XDP_DROPPED;
-+
-+	tx_desc = mvneta_txq_next_desc_get(txq);
-+
-+	buf = &txq->buf[txq->txq_put_index];
-+	if (dma_map) {
-+		/* ndo_xdp_xmit */
-+		dma_addr = dma_map_single(pp->dev->dev.parent, xdpf->data,
-+					  xdpf->len, DMA_TO_DEVICE);
-+		if (dma_mapping_error(pp->dev->dev.parent, dma_addr)) {
-+			mvneta_txq_desc_put(txq);
-+			return MVNETA_XDP_DROPPED;
-+		}
-+		buf->type = MVNETA_TYPE_XDP_NDO;
-+	} else {
-+		struct page *page = virt_to_page(xdpf->data);
-+
-+		dma_addr = page_pool_get_dma_addr(page) +
-+			   sizeof(*xdpf) + xdpf->headroom;
-+		dma_sync_single_for_device(pp->dev->dev.parent, dma_addr,
-+					   xdpf->len, DMA_BIDIRECTIONAL);
-+		buf->type = MVNETA_TYPE_XDP_TX;
-+	}
-+	buf->xdpf = xdpf;
-+
-+	tx_desc->command = MVNETA_TXD_FLZ_DESC;
-+	tx_desc->buf_phys_addr = dma_addr;
-+	tx_desc->data_size = xdpf->len;
-+
-+	mvneta_update_stats(pp, 1, xdpf->len, true);
-+	mvneta_txq_inc_put(txq);
-+	txq->pending++;
-+	txq->count++;
-+
-+	return MVNETA_XDP_TX;
-+}
-+
-+static int
-+mvneta_xdp_xmit_back(struct mvneta_port *pp, struct xdp_buff *xdp)
-+{
-+	struct mvneta_tx_queue *txq;
-+	struct netdev_queue *nq;
-+	struct xdp_frame *xdpf;
-+	int cpu;
-+	u32 ret;
-+
-+	xdpf = convert_to_xdp_frame(xdp);
-+	if (unlikely(!xdpf))
-+		return MVNETA_XDP_DROPPED;
-+
-+	cpu = smp_processor_id();
-+	txq = &pp->txqs[cpu % txq_number];
-+	nq = netdev_get_tx_queue(pp->dev, txq->id);
-+
-+	__netif_tx_lock(nq, cpu);
-+	ret = mvneta_xdp_submit_frame(pp, txq, xdpf, false);
-+	if (ret == MVNETA_XDP_TX)
-+		mvneta_txq_pend_desc_add(pp, txq, 0);
-+	__netif_tx_unlock(nq);
-+
-+	return ret;
-+}
-+
-+static int
-+mvneta_xdp_xmit(struct net_device *dev, int num_frame,
-+		struct xdp_frame **frames, u32 flags)
-+{
-+	struct mvneta_port *pp = netdev_priv(dev);
-+	int cpu = smp_processor_id();
-+	struct mvneta_tx_queue *txq;
-+	struct netdev_queue *nq;
-+	int i, drops = 0;
-+	u32 ret;
-+
-+	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))
-+		return -EINVAL;
-+
-+	txq = &pp->txqs[cpu % txq_number];
-+	nq = netdev_get_tx_queue(pp->dev, txq->id);
-+
-+	__netif_tx_lock(nq, cpu);
-+	for (i = 0; i < num_frame; i++) {
-+		ret = mvneta_xdp_submit_frame(pp, txq, frames[i], true);
-+		if (ret != MVNETA_XDP_TX) {
-+			xdp_return_frame_rx_napi(frames[i]);
-+			drops++;
-+		}
-+	}
-+
-+	if (unlikely(flags & XDP_XMIT_FLUSH))
-+		mvneta_txq_pend_desc_add(pp, txq, 0);
-+	__netif_tx_unlock(nq);
-+
-+	return num_frame - drops;
-+}
-+
-+static int
- mvneta_run_xdp(struct mvneta_port *pp, struct mvneta_rx_queue *rxq,
- 	       struct bpf_prog *prog, struct xdp_buff *xdp)
- {
-@@ -2008,6 +2116,11 @@ mvneta_run_xdp(struct mvneta_port *pp, s
- 		}
- 		break;
- 	}
-+	case XDP_TX:
-+		ret = mvneta_xdp_xmit_back(pp, xdp);
-+		if (ret != MVNETA_XDP_TX)
-+			xdp_return_buff(xdp);
-+		break;
- 	default:
- 		bpf_warn_invalid_xdp_action(act);
- 		/* fall through */
-@@ -4574,6 +4687,7 @@ static const struct net_device_ops mvnet
- 	.ndo_get_stats64     = mvneta_get_stats64,
- 	.ndo_do_ioctl        = mvneta_ioctl,
- 	.ndo_bpf             = mvneta_xdp,
-+	.ndo_xdp_xmit        = mvneta_xdp_xmit,
- };
- 
- static const struct ethtool_ops mvneta_eth_tool_ops = {
diff --git a/target/linux/mvebu/patches-5.10/010-net-mvneta-fix-build-skb-for-bm-capable-devices.patch b/target/linux/mvebu/patches-5.10/010-net-mvneta-fix-build-skb-for-bm-capable-devices.patch
deleted file mode 100644
index adfa51e4e8..0000000000
--- a/target/linux/mvebu/patches-5.10/010-net-mvneta-fix-build-skb-for-bm-capable-devices.patch
+++ /dev/null
@@ -1,41 +0,0 @@
-From b37fa92e20ef28aada852cbf03b368d29a20478c Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Thu, 14 Nov 2019 01:25:55 +0200
-Subject: [PATCH] net: mvneta: fix build skb for bm capable devices
-
-Fix build_skb for bm capable devices when they fall-back using swbm path
-(e.g. when bm properties are configured in device tree but
-CONFIG_MVNETA_BM_ENABLE is not set). In this case rx_offset_correction is
-overwritten so we need to use it building skb instead of
-MVNETA_SKB_HEADROOM directly
-
-Fixes: 8dc9a0888f4c ("net: mvneta: rely on build_skb in mvneta_rx_swbm poll routine")
-Fixes: 0db51da7a8e9 ("net: mvneta: add basic XDP support")
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Reported-by: Andrew Lunn <andrew@lunn.ch>
-Tested-by: Andrew Lunn <andrew@lunn.ch>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -2167,7 +2167,7 @@ mvneta_swbm_rx_frame(struct mvneta_port
- 	prefetch(data);
- 
- 	xdp->data_hard_start = data;
--	xdp->data = data + MVNETA_SKB_HEADROOM + MVNETA_MH_SIZE;
-+	xdp->data = data + pp->rx_offset_correction + MVNETA_MH_SIZE;
- 	xdp->data_end = xdp->data + data_len;
- 	xdp_set_data_meta_invalid(xdp);
- 
-@@ -2232,7 +2232,7 @@ mvneta_swbm_add_rx_fragment(struct mvnet
- 		/* refill descriptor with new buffer later */
- 		skb_add_rx_frag(rxq->skb,
- 				skb_shinfo(rxq->skb)->nr_frags,
--				page, MVNETA_SKB_HEADROOM, data_len,
-+				page, pp->rx_offset_correction, data_len,
- 				PAGE_SIZE);
- 	}
- 	page_pool_release_page(rxq->page_pool, page);
diff --git a/target/linux/mvebu/patches-5.10/011-arm64-dts-uDPU-remove-i2c-fast-mode.patch b/target/linux/mvebu/patches-5.10/011-arm64-dts-uDPU-remove-i2c-fast-mode.patch
deleted file mode 100644
index 2922d49f44..0000000000
--- a/target/linux/mvebu/patches-5.10/011-arm64-dts-uDPU-remove-i2c-fast-mode.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From fe3ec631a77ded87817f449691710a436a80caa7 Mon Sep 17 00:00:00 2001
-From: Russell King <rmk+kernel@armlinux.org.uk>
-Date: Sat, 16 Nov 2019 11:07:01 +0000
-Subject: [PATCH] arm64: dts: uDPU: remove i2c-fast-mode
-
-The I2C bus violates the timing specifications when run in fast mode
-on the uDPU, so switch to 100kHz mode.
-
-Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
-Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
----
- arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
-@@ -119,12 +119,14 @@
- 	status = "okay";
- 	pinctrl-names = "default";
- 	pinctrl-0 = <&i2c1_pins>;
-+	/delete-property/mrvl,i2c-fast-mode;
- };
- 
- &i2c1 {
- 	status = "okay";
- 	pinctrl-names = "default";
- 	pinctrl-0 = <&i2c2_pins>;
-+	/delete-property/mrvl,i2c-fast-mode;
- 
- 	lm75@48 {
- 		status = "okay";
diff --git a/target/linux/mvebu/patches-5.10/012-arm64-dts-uDPU-SFP-cages-support-3W-modules.patch b/target/linux/mvebu/patches-5.10/012-arm64-dts-uDPU-SFP-cages-support-3W-modules.patch
deleted file mode 100644
index 1884def2c6..0000000000
--- a/target/linux/mvebu/patches-5.10/012-arm64-dts-uDPU-SFP-cages-support-3W-modules.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From cd592187f9de3c6305d6c1c66f7fac084cb5b846 Mon Sep 17 00:00:00 2001
-From: Russell King <rmk+kernel@armlinux.org.uk>
-Date: Tue, 19 Nov 2019 22:53:04 +0000
-Subject: [PATCH] arm64: dts: uDPU: SFP cages support 3W modules
-
-The SFP cages are designed to support up to 3W modules, such as G.hn,
-G.fast and MoCA modules. Although there is no way for such modules to
-declare to software that they consume 3W, we document in DT that this
-is the designed power level for these cages.
-
-Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
-Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
----
- arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
-@@ -69,6 +69,7 @@
- 		mod-def0-gpio = <&gpiosb 3 GPIO_ACTIVE_LOW>;
- 		tx-disable-gpio = <&gpiosb 4 GPIO_ACTIVE_HIGH>;
- 		tx-fault-gpio = <&gpiosb 5 GPIO_ACTIVE_HIGH>;
-+		maximum-power-milliwatt = <3000>;
- 	};
- 
- 	sfp_eth1: sfp-eth1 {
-@@ -78,6 +79,7 @@
- 		mod-def0-gpio = <&gpiosb 8 GPIO_ACTIVE_LOW>;
- 		tx-disable-gpio = <&gpiosb 9 GPIO_ACTIVE_HIGH>;
- 		tx-fault-gpio = <&gpiosb 10 GPIO_ACTIVE_HIGH>;
-+		maximum-power-milliwatt = <3000>;
- 	};
- };
- 
diff --git a/target/linux/mvebu/patches-5.10/013-net-mvneta-rely-on-page_pool_recycle_direct-in-mvnet.patch b/target/linux/mvebu/patches-5.10/013-net-mvneta-rely-on-page_pool_recycle_direct-in-mvnet.patch
deleted file mode 100644
index 6e79aeb358..0000000000
--- a/target/linux/mvebu/patches-5.10/013-net-mvneta-rely-on-page_pool_recycle_direct-in-mvnet.patch
+++ /dev/null
@@ -1,39 +0,0 @@
-From f383b2950070ce4f34e74db94f70bb565b746e97 Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Wed, 20 Nov 2019 16:54:17 +0200
-Subject: [PATCH] net: mvneta: rely on page_pool_recycle_direct in
- mvneta_run_xdp
-
-Rely on page_pool_recycle_direct and not on xdp_return_buff in
-mvneta_run_xdp. This is a preliminary patch to limit the dma sync len
-to the one strictly necessary
-
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -2110,7 +2110,8 @@ mvneta_run_xdp(struct mvneta_port *pp, s
- 		err = xdp_do_redirect(pp->dev, xdp, prog);
- 		if (err) {
- 			ret = MVNETA_XDP_DROPPED;
--			xdp_return_buff(xdp);
-+			page_pool_recycle_direct(rxq->page_pool,
-+						 virt_to_head_page(xdp->data));
- 		} else {
- 			ret = MVNETA_XDP_REDIR;
- 		}
-@@ -2119,7 +2120,8 @@ mvneta_run_xdp(struct mvneta_port *pp, s
- 	case XDP_TX:
- 		ret = mvneta_xdp_xmit_back(pp, xdp);
- 		if (ret != MVNETA_XDP_TX)
--			xdp_return_buff(xdp);
-+			page_pool_recycle_direct(rxq->page_pool,
-+						 virt_to_head_page(xdp->data));
- 		break;
- 	default:
- 		bpf_warn_invalid_xdp_action(act);
diff --git a/target/linux/mvebu/patches-5.10/014-mvneta-driver-disallow-XDP-program-on-hardware-buffe.patch b/target/linux/mvebu/patches-5.10/014-mvneta-driver-disallow-XDP-program-on-hardware-buffe.patch
deleted file mode 100644
index e8a41d9eb2..0000000000
--- a/target/linux/mvebu/patches-5.10/014-mvneta-driver-disallow-XDP-program-on-hardware-buffe.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From 79572c98c554dcdb080bca547c871a51716dcdf8 Mon Sep 17 00:00:00 2001
-From: Sven Auhagen <sven.auhagen@voleatech.de>
-Date: Sat, 25 Jan 2020 08:07:03 +0000
-Subject: [PATCH] mvneta driver disallow XDP program on hardware buffer
- management
-
-Recently XDP Support was added to the mvneta driver
-for software buffer management only.
-It is still possible to attach an XDP program if
-hardware buffer management is used.
-It is not doing anything at that point.
-
-The patch disallows attaching XDP programs to mvneta
-if hardware buffer management is used.
-
-I am sorry about that. It is my first submission and I am having
-some troubles with the format of my emails.
-
-v4 -> v5:
-- Remove extra tabs
-
-v3 -> v4:
-- Please ignore v3 I accidentally submitted
-  my other patch with git-send-mail and v4 is correct
-
-v2 -> v3:
-- My mailserver corrupted the patch
-  resubmission with git-send-email
-
-v1 -> v2:
-- Fixing the patches indentation
-
-Signed-off-by: Sven Auhagen <sven.auhagen@voleatech.de>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 6 ++++++
- 1 file changed, 6 insertions(+)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -4263,6 +4263,12 @@ static int mvneta_xdp_setup(struct net_d
- 		return -EOPNOTSUPP;
- 	}
- 
-+	if (pp->bm_priv) {
-+		NL_SET_ERR_MSG_MOD(extack,
-+				   "Hardware Buffer Management not supported on XDP");
-+		return -EOPNOTSUPP;
-+	}
-+
- 	need_update = !!pp->xdp_prog != !!prog;
- 	if (running && need_update)
- 		mvneta_stop(dev);
diff --git a/target/linux/mvebu/patches-5.10/015-net-mvneta-fix-XDP-support-if-sw-bm-is-used-as-fallb.patch b/target/linux/mvebu/patches-5.10/015-net-mvneta-fix-XDP-support-if-sw-bm-is-used-as-fallb.patch
deleted file mode 100644
index 86bffa538a..0000000000
--- a/target/linux/mvebu/patches-5.10/015-net-mvneta-fix-XDP-support-if-sw-bm-is-used-as-fallb.patch
+++ /dev/null
@@ -1,67 +0,0 @@
-From 44efc78d0e464ce70b45b165c005f8bedc17952e Mon Sep 17 00:00:00 2001
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Wed, 29 Jan 2020 12:50:53 +0100
-Subject: [PATCH] net: mvneta: fix XDP support if sw bm is used as fallback
-
-In order to fix XDP support if sw buffer management is used as fallback
-for hw bm devices, define MVNETA_SKB_HEADROOM as maximum between
-XDP_PACKET_HEADROOM and NET_SKB_PAD and let the hw aligns the IP header
-to 4-byte boundary.
-Fix rx_offset_correction initialization if mvneta_bm_port_init fails in
-mvneta_resume routine
-
-Fixes: 0db51da7a8e9 ("net: mvneta: add basic XDP support")
-Tested-by: Sven Auhagen <sven.auhagen@voleatech.de>
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/ethernet/marvell/mvneta.c | 10 +++++++---
- 1 file changed, 7 insertions(+), 3 deletions(-)
-
---- a/drivers/net/ethernet/marvell/mvneta.c
-+++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -326,8 +326,7 @@
- 	      ETH_HLEN + ETH_FCS_LEN,			     \
- 	      cache_line_size())
- 
--#define MVNETA_SKB_HEADROOM	(max(XDP_PACKET_HEADROOM, NET_SKB_PAD) + \
--				 NET_IP_ALIGN)
-+#define MVNETA_SKB_HEADROOM	max(XDP_PACKET_HEADROOM, NET_SKB_PAD)
- #define MVNETA_SKB_PAD	(SKB_DATA_ALIGN(sizeof(struct skb_shared_info) + \
- 			 MVNETA_SKB_HEADROOM))
- #define MVNETA_SKB_SIZE(len)	(SKB_DATA_ALIGN(len) + MVNETA_SKB_PAD)
-@@ -1174,6 +1173,7 @@ bm_mtu_err:
- 	mvneta_bm_pool_destroy(pp->bm_priv, pp->pool_short, 1 << pp->id);
- 
- 	pp->bm_priv = NULL;
-+	pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
- 	mvreg_write(pp, MVNETA_ACC_MODE, MVNETA_ACC_MODE_EXT1);
- 	netdev_info(pp->dev, "fail to update MTU, fall back to software BM\n");
- }
-@@ -4984,7 +4984,6 @@ static int mvneta_probe(struct platform_
- 	SET_NETDEV_DEV(dev, &pdev->dev);
- 
- 	pp->id = global_port_id++;
--	pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
- 
- 	/* Obtain access to BM resources if enabled and already initialized */
- 	bm_node = of_parse_phandle(dn, "buffer-manager", 0);
-@@ -5009,6 +5008,10 @@ static int mvneta_probe(struct platform_
- 	}
- 	of_node_put(bm_node);
- 
-+	/* sw buffer management */
-+	if (!pp->bm_priv)
-+		pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
-+
- 	err = mvneta_init(&pdev->dev, pp);
- 	if (err < 0)
- 		goto err_netdev;
-@@ -5166,6 +5169,7 @@ static int mvneta_resume(struct device *
- 		err = mvneta_bm_port_init(pdev, pp);
- 		if (err < 0) {
- 			dev_info(&pdev->dev, "use SW buffer management\n");
-+			pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
- 			pp->bm_priv = NULL;
- 		}
- 	}
diff --git a/target/linux/mvebu/patches-5.10/016-PCI-aardvark-Train-link-immediately-after-enabling-t.patch b/target/linux/mvebu/patches-5.10/016-PCI-aardvark-Train-link-immediately-after-enabling-t.patch
deleted file mode 100644
index c9e49ac2f1..0000000000
--- a/target/linux/mvebu/patches-5.10/016-PCI-aardvark-Train-link-immediately-after-enabling-t.patch
+++ /dev/null
@@ -1,60 +0,0 @@
-From 6964494582f56a3882c2c53b0edbfe99eb32b2e1 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
-Date: Thu, 30 Apr 2020 10:06:14 +0200
-Subject: [PATCH] PCI: aardvark: Train link immediately after enabling training
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Adding even 100ms (PCI_PM_D3COLD_WAIT) delay between enabling link
-training and starting link training causes detection issues with some
-buggy cards (such as Compex WLE900VX).
-
-Move the code which enables link training immediately before the one
-which starts link traning.
-
-This fixes detection issues of Compex WLE900VX card on Turris MOX after
-cold boot.
-
-Link: https://lore.kernel.org/r/20200430080625.26070-2-pali@kernel.org
-Fixes: f4c7d053d7f7 ("PCI: aardvark: Wait for endpoint to be ready...")
-Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
-Signed-off-by: Pali RohÃ¡r <pali@kernel.org>
-Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
-Acked-by: Rob Herring <robh@kernel.org>
-Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
----
- drivers/pci/controller/pci-aardvark.c | 15 +++++++++------
- 1 file changed, 9 insertions(+), 6 deletions(-)
-
---- a/drivers/pci/controller/pci-aardvark.c
-+++ b/drivers/pci/controller/pci-aardvark.c
-@@ -300,11 +300,6 @@ static void advk_pcie_setup_hw(struct ad
- 	reg |= LANE_COUNT_1;
- 	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
- 
--	/* Enable link training */
--	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
--	reg |= LINK_TRAINING_EN;
--	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
--
- 	/* Enable MSI */
- 	reg = advk_readl(pcie, PCIE_CORE_CTRL2_REG);
- 	reg |= PCIE_CORE_CTRL2_MSI_ENABLE;
-@@ -346,7 +341,15 @@ static void advk_pcie_setup_hw(struct ad
- 	 */
- 	msleep(PCI_PM_D3COLD_WAIT);
- 
--	/* Start link training */
-+	/* Enable link training */
-+	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
-+	reg |= LINK_TRAINING_EN;
-+	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
-+
-+	/*
-+	 * Start link training immediately after enabling it.
-+	 * This solves problems for some buggy cards.
-+	 */
- 	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
- 	reg |= PCIE_CORE_LINK_TRAINING;
- 	advk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);
diff --git a/target/linux/mvebu/patches-5.10/017-PCI-aardvark-Improve-link-training.patch b/target/linux/mvebu/patches-5.10/017-PCI-aardvark-Improve-link-training.patch
deleted file mode 100644
index 2bf838432f..0000000000
--- a/target/linux/mvebu/patches-5.10/017-PCI-aardvark-Improve-link-training.patch
+++ /dev/null
@@ -1,208 +0,0 @@
-From 43fc679ced18006b12d918d7a8a4af392b7fbfe7 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
-Date: Thu, 30 Apr 2020 10:06:17 +0200
-Subject: [PATCH] PCI: aardvark: Improve link training
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Currently the aardvark driver trains link in PCIe gen2 mode. This may
-cause some buggy gen1 cards (such as Compex WLE900VX) to be unstable or
-even not detected. Moreover when ASPM code tries to retrain link second
-time, these cards may stop responding and link goes down. If gen1 is
-used this does not happen.
-
-Unconditionally forcing gen1 is not a good solution since it may have
-performance impact on gen2 cards.
-
-To overcome this, read 'max-link-speed' property (as defined in PCI
-device tree bindings) and use this as max gen mode. Then iteratively try
-link training at this mode or lower until successful. After successful
-link training choose final controller gen based on Negotiated Link Speed
-from Link Status register, which should match card speed.
-
-Link: https://lore.kernel.org/r/20200430080625.26070-5-pali@kernel.org
-Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
-Signed-off-by: Pali RohÃ¡r <pali@kernel.org>
-Signed-off-by: Marek BehÃºn <marek.behun@nic.cz>
-Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
-Reviewed-by: Rob Herring <robh@kernel.org>
-Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
----
- drivers/pci/controller/pci-aardvark.c | 114 ++++++++++++++++++++------
- 1 file changed, 89 insertions(+), 25 deletions(-)
-
---- a/drivers/pci/controller/pci-aardvark.c
-+++ b/drivers/pci/controller/pci-aardvark.c
-@@ -39,6 +39,7 @@
- #define PCIE_CORE_LINK_CTRL_STAT_REG				0xd0
- #define     PCIE_CORE_LINK_L0S_ENTRY				BIT(0)
- #define     PCIE_CORE_LINK_TRAINING				BIT(5)
-+#define     PCIE_CORE_LINK_SPEED_SHIFT				16
- #define     PCIE_CORE_LINK_WIDTH_SHIFT				20
- #define PCIE_CORE_ERR_CAPCTL_REG				0x118
- #define     PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX			BIT(5)
-@@ -201,6 +202,7 @@ struct advk_pcie {
- 	struct mutex msi_used_lock;
- 	u16 msi_msg;
- 	int root_bus_nr;
-+	int link_gen;
- 	struct pci_bridge_emul bridge;
- };
- 
-@@ -225,20 +227,16 @@ static int advk_pcie_link_up(struct advk
- 
- static int advk_pcie_wait_for_link(struct advk_pcie *pcie)
- {
--	struct device *dev = &pcie->pdev->dev;
- 	int retries;
- 
- 	/* check if the link is up or not */
- 	for (retries = 0; retries < LINK_WAIT_MAX_RETRIES; retries++) {
--		if (advk_pcie_link_up(pcie)) {
--			dev_info(dev, "link up\n");
-+		if (advk_pcie_link_up(pcie))
- 			return 0;
--		}
- 
- 		usleep_range(LINK_WAIT_USLEEP_MIN, LINK_WAIT_USLEEP_MAX);
- 	}
- 
--	dev_err(dev, "link never came up\n");
- 	return -ETIMEDOUT;
- }
- 
-@@ -253,6 +251,85 @@ static void advk_pcie_wait_for_retrain(s
- 	}
- }
- 
-+static int advk_pcie_train_at_gen(struct advk_pcie *pcie, int gen)
-+{
-+	int ret, neg_gen;
-+	u32 reg;
-+
-+	/* Setup link speed */
-+	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
-+	reg &= ~PCIE_GEN_SEL_MSK;
-+	if (gen == 3)
-+		reg |= SPEED_GEN_3;
-+	else if (gen == 2)
-+		reg |= SPEED_GEN_2;
-+	else
-+		reg |= SPEED_GEN_1;
-+	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
-+
-+	/*
-+	 * Enable link training. This is not needed in every call to this
-+	 * function, just once suffices, but it does not break anything either.
-+	 */
-+	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
-+	reg |= LINK_TRAINING_EN;
-+	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
-+
-+	/*
-+	 * Start link training immediately after enabling it.
-+	 * This solves problems for some buggy cards.
-+	 */
-+	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
-+	reg |= PCIE_CORE_LINK_TRAINING;
-+	advk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);
-+
-+	ret = advk_pcie_wait_for_link(pcie);
-+	if (ret)
-+		return ret;
-+
-+	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
-+	neg_gen = (reg >> PCIE_CORE_LINK_SPEED_SHIFT) & 0xf;
-+
-+	return neg_gen;
-+}
-+
-+static void advk_pcie_train_link(struct advk_pcie *pcie)
-+{
-+	struct device *dev = &pcie->pdev->dev;
-+	int neg_gen = -1, gen;
-+
-+	/*
-+	 * Try link training at link gen specified by device tree property
-+	 * 'max-link-speed'. If this fails, iteratively train at lower gen.
-+	 */
-+	for (gen = pcie->link_gen; gen > 0; --gen) {
-+		neg_gen = advk_pcie_train_at_gen(pcie, gen);
-+		if (neg_gen > 0)
-+			break;
-+	}
-+
-+	if (neg_gen < 0)
-+		goto err;
-+
-+	/*
-+	 * After successful training if negotiated gen is lower than requested,
-+	 * train again on negotiated gen. This solves some stability issues for
-+	 * some buggy gen1 cards.
-+	 */
-+	if (neg_gen < gen) {
-+		gen = neg_gen;
-+		neg_gen = advk_pcie_train_at_gen(pcie, gen);
-+	}
-+
-+	if (neg_gen == gen) {
-+		dev_info(dev, "link up at gen %i\n", gen);
-+		return;
-+	}
-+
-+err:
-+	dev_err(dev, "link never came up\n");
-+}
-+
- static void advk_pcie_setup_hw(struct advk_pcie *pcie)
- {
- 	u32 reg;
-@@ -288,12 +365,6 @@ static void advk_pcie_setup_hw(struct ad
- 		PCIE_CORE_CTRL2_TD_ENABLE;
- 	advk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);
- 
--	/* Set GEN2 */
--	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
--	reg &= ~PCIE_GEN_SEL_MSK;
--	reg |= SPEED_GEN_2;
--	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
--
- 	/* Set lane X1 */
- 	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
- 	reg &= ~LANE_CNT_MSK;
-@@ -341,20 +412,7 @@ static void advk_pcie_setup_hw(struct ad
- 	 */
- 	msleep(PCI_PM_D3COLD_WAIT);
- 
--	/* Enable link training */
--	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
--	reg |= LINK_TRAINING_EN;
--	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
--
--	/*
--	 * Start link training immediately after enabling it.
--	 * This solves problems for some buggy cards.
--	 */
--	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
--	reg |= PCIE_CORE_LINK_TRAINING;
--	advk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);
--
--	advk_pcie_wait_for_link(pcie);
-+	advk_pcie_train_link(pcie);
- 
- 	reg = advk_readl(pcie, PCIE_CORE_CMD_STATUS_REG);
- 	reg |= PCIE_CORE_CMD_MEM_ACCESS_EN |
-@@ -1035,6 +1093,12 @@ static int advk_pcie_probe(struct platfo
- 		return ret;
- 	}
- 
-+	ret = of_pci_get_max_link_speed(dev->of_node);
-+	if (ret <= 0 || ret > 3)
-+		pcie->link_gen = 3;
-+	else
-+		pcie->link_gen = ret;
-+
- 	advk_pcie_setup_hw(pcie);
- 
- 	ret = advk_sw_pci_bridge_init(pcie);
diff --git a/target/linux/mvebu/patches-5.10/018-PCI-aardvark-Issue-PERST-via-GPIO.patch b/target/linux/mvebu/patches-5.10/018-PCI-aardvark-Issue-PERST-via-GPIO.patch
deleted file mode 100644
index 83212ec475..0000000000
--- a/target/linux/mvebu/patches-5.10/018-PCI-aardvark-Issue-PERST-via-GPIO.patch
+++ /dev/null
@@ -1,123 +0,0 @@
-From 5169a9851daaa2782a7bd2bb83d5b1bd224b2879 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
-Date: Thu, 30 Apr 2020 10:06:18 +0200
-Subject: [PATCH] PCI: aardvark: Issue PERST via GPIO
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Add support for issuing PERST via GPIO specified in 'reset-gpios'
-property (as described in PCI device tree bindings).
-
-Some buggy cards (e.g. Compex WLE900VX or WLE1216) are not detected
-after reboot when PERST is not issued during driver initialization.
-
-If bootloader already enabled link training then issuing PERST has no
-effect for some buggy cards (e.g. Compex WLE900VX) and these cards are
-not detected. We therefore clear the LINK_TRAINING_EN register before.
-
-It was observed that Compex WLE900VX card needs to be in PERST reset
-for at least 10ms if bootloader enabled link training.
-
-Tested on Turris MOX.
-
-Link: https://lore.kernel.org/r/20200430080625.26070-6-pali@kernel.org
-Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
-Signed-off-by: Pali RohÃ¡r <pali@kernel.org>
-Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
-Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
----
- drivers/pci/controller/pci-aardvark.c | 43 ++++++++++++++++++++++++++-
- 1 file changed, 42 insertions(+), 1 deletion(-)
-
---- a/drivers/pci/controller/pci-aardvark.c
-+++ b/drivers/pci/controller/pci-aardvark.c
-@@ -9,6 +9,7 @@
-  */
- 
- #include <linux/delay.h>
-+#include <linux/gpio.h>
- #include <linux/interrupt.h>
- #include <linux/irq.h>
- #include <linux/irqdomain.h>
-@@ -17,6 +18,7 @@
- #include <linux/init.h>
- #include <linux/platform_device.h>
- #include <linux/of_address.h>
-+#include <linux/of_gpio.h>
- #include <linux/of_pci.h>
- 
- #include "../pci.h"
-@@ -204,6 +206,7 @@ struct advk_pcie {
- 	int root_bus_nr;
- 	int link_gen;
- 	struct pci_bridge_emul bridge;
-+	struct gpio_desc *reset_gpio;
- };
- 
- static inline void advk_writel(struct advk_pcie *pcie, u32 val, u64 reg)
-@@ -330,10 +333,31 @@ err:
- 	dev_err(dev, "link never came up\n");
- }
- 
-+static void advk_pcie_issue_perst(struct advk_pcie *pcie)
-+{
-+	u32 reg;
-+
-+	if (!pcie->reset_gpio)
-+		return;
-+
-+	/* PERST does not work for some cards when link training is enabled */
-+	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
-+	reg &= ~LINK_TRAINING_EN;
-+	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
-+
-+	/* 10ms delay is needed for some cards */
-+	dev_info(&pcie->pdev->dev, "issuing PERST via reset GPIO for 10ms\n");
-+	gpiod_set_value_cansleep(pcie->reset_gpio, 1);
-+	usleep_range(10000, 11000);
-+	gpiod_set_value_cansleep(pcie->reset_gpio, 0);
-+}
-+
- static void advk_pcie_setup_hw(struct advk_pcie *pcie)
- {
- 	u32 reg;
- 
-+	advk_pcie_issue_perst(pcie);
-+
- 	/* Set to Direct mode */
- 	reg = advk_readl(pcie, CTRL_CONFIG_REG);
- 	reg &= ~(CTRL_MODE_MASK << CTRL_MODE_SHIFT);
-@@ -406,7 +430,8 @@ static void advk_pcie_setup_hw(struct ad
- 
- 	/*
- 	 * PERST# signal could have been asserted by pinctrl subsystem before
--	 * probe() callback has been called, making the endpoint going into
-+	 * probe() callback has been called or issued explicitly by reset gpio
-+	 * function advk_pcie_issue_perst(), making the endpoint going into
- 	 * fundamental reset. As required by PCI Express spec a delay for at
- 	 * least 100ms after such a reset before link training is needed.
- 	 */
-@@ -1093,6 +1118,22 @@ static int advk_pcie_probe(struct platfo
- 		return ret;
- 	}
- 
-+	pcie->reset_gpio = devm_gpiod_get_from_of_node(dev, dev->of_node,
-+						       "reset-gpios", 0,
-+						       GPIOD_OUT_LOW,
-+						       "pcie1-reset");
-+	ret = PTR_ERR_OR_ZERO(pcie->reset_gpio);
-+	if (ret) {
-+		if (ret == -ENOENT) {
-+			pcie->reset_gpio = NULL;
-+		} else {
-+			if (ret != -EPROBE_DEFER)
-+				dev_err(dev, "Failed to get reset-gpio: %i\n",
-+					ret);
-+			return ret;
-+		}
-+	}
-+
- 	ret = of_pci_get_max_link_speed(dev->of_node);
- 	if (ret <= 0 || ret > 3)
- 		pcie->link_gen = 3;
diff --git a/target/linux/mvebu/patches-5.10/019-PCI-aardvark-Add-PHY-support.patch b/target/linux/mvebu/patches-5.10/019-PCI-aardvark-Add-PHY-support.patch
deleted file mode 100644
index fa04861e80..0000000000
--- a/target/linux/mvebu/patches-5.10/019-PCI-aardvark-Add-PHY-support.patch
+++ /dev/null
@@ -1,152 +0,0 @@
-From 366697018c9a2aa67d457bfdc495115cface6ae8 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
-Date: Thu, 30 Apr 2020 10:06:20 +0200
-Subject: [PATCH] PCI: aardvark: Add PHY support
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-With recent proposed changes for U-Boot it is possible that bootloader
-won't initialize the PHY for this controller (currently the PHY is
-initialized regardless whether PCI is used in U-Boot, but with these
-proposed changes the PHY is initialized only on request).
-
-Since the mvebu-a3700-comphy driver by MiquÃ¨l Raynal supports enabling
-PCIe PHY, and since Linux' functionality should be independent on what
-bootloader did, add code for enabling generic PHY if found in device OF
-node.
-
-The mvebu-a3700-comphy driver does PHY powering via SMC calls to ARM
-Trusted Firmware. The corresponding code in ARM Trusted Firmware skips
-one register write which U-Boot does not: step 7 ("Enable TX"), see [1].
-Instead ARM Trusted Firmware expects PCIe driver to do this step,
-probably because the register is in PCIe controller address space,
-instead of PHY address space. We therefore add this step into the
-advk_pcie_setup_hw function.
-
-[1] https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/drivers/marvell/comphy/phy-comphy-3700.c?h=v2.3-rc2#n836
-
-Link: https://lore.kernel.org/r/20200430080625.26070-8-pali@kernel.org
-Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
-Signed-off-by: Marek BehÃºn <marek.behun@nic.cz>
-Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
-Reviewed-by: Rob Herring <robh@kernel.org>
-Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
-Cc: MiquÃ¨l Raynal <miquel.raynal@bootlin.com>
----
- drivers/pci/controller/pci-aardvark.c | 69 +++++++++++++++++++++++++++
- 1 file changed, 69 insertions(+)
-
---- a/drivers/pci/controller/pci-aardvark.c
-+++ b/drivers/pci/controller/pci-aardvark.c
-@@ -16,6 +16,7 @@
- #include <linux/kernel.h>
- #include <linux/pci.h>
- #include <linux/init.h>
-+#include <linux/phy/phy.h>
- #include <linux/platform_device.h>
- #include <linux/of_address.h>
- #include <linux/of_gpio.h>
-@@ -103,6 +104,8 @@
- #define     PCIE_CORE_CTRL2_STRICT_ORDER_ENABLE	BIT(5)
- #define     PCIE_CORE_CTRL2_OB_WIN_ENABLE	BIT(6)
- #define     PCIE_CORE_CTRL2_MSI_ENABLE		BIT(10)
-+#define PCIE_CORE_REF_CLK_REG			(CONTROL_BASE_ADDR + 0x14)
-+#define     PCIE_CORE_REF_CLK_TX_ENABLE		BIT(1)
- #define PCIE_MSG_LOG_REG			(CONTROL_BASE_ADDR + 0x30)
- #define PCIE_ISR0_REG				(CONTROL_BASE_ADDR + 0x40)
- #define PCIE_MSG_PM_PME_MASK			BIT(7)
-@@ -207,6 +210,7 @@ struct advk_pcie {
- 	int link_gen;
- 	struct pci_bridge_emul bridge;
- 	struct gpio_desc *reset_gpio;
-+	struct phy *phy;
- };
- 
- static inline void advk_writel(struct advk_pcie *pcie, u32 val, u64 reg)
-@@ -358,6 +362,11 @@ static void advk_pcie_setup_hw(struct ad
- 
- 	advk_pcie_issue_perst(pcie);
- 
-+	/* Enable TX */
-+	reg = advk_readl(pcie, PCIE_CORE_REF_CLK_REG);
-+	reg |= PCIE_CORE_REF_CLK_TX_ENABLE;
-+	advk_writel(pcie, reg, PCIE_CORE_REF_CLK_REG);
-+
- 	/* Set to Direct mode */
- 	reg = advk_readl(pcie, CTRL_CONFIG_REG);
- 	reg &= ~(CTRL_MODE_MASK << CTRL_MODE_SHIFT);
-@@ -1083,6 +1092,62 @@ out_release_res:
- 	return err;
- }
- 
-+static void __maybe_unused advk_pcie_disable_phy(struct advk_pcie *pcie)
-+{
-+	phy_power_off(pcie->phy);
-+	phy_exit(pcie->phy);
-+}
-+
-+static int advk_pcie_enable_phy(struct advk_pcie *pcie)
-+{
-+	int ret;
-+
-+	if (!pcie->phy)
-+		return 0;
-+
-+	ret = phy_init(pcie->phy);
-+	if (ret)
-+		return ret;
-+
-+	ret = phy_set_mode(pcie->phy, PHY_MODE_PCIE);
-+	if (ret) {
-+		phy_exit(pcie->phy);
-+		return ret;
-+	}
-+
-+	ret = phy_power_on(pcie->phy);
-+	if (ret) {
-+		phy_exit(pcie->phy);
-+		return ret;
-+	}
-+
-+	return 0;
-+}
-+
-+static int advk_pcie_setup_phy(struct advk_pcie *pcie)
-+{
-+	struct device *dev = &pcie->pdev->dev;
-+	struct device_node *node = dev->of_node;
-+	int ret = 0;
-+
-+	pcie->phy = devm_of_phy_get(dev, node, NULL);
-+	if (IS_ERR(pcie->phy) && (PTR_ERR(pcie->phy) == -EPROBE_DEFER))
-+		return PTR_ERR(pcie->phy);
-+
-+	/* Old bindings miss the PHY handle */
-+	if (IS_ERR(pcie->phy)) {
-+		dev_warn(dev, "PHY unavailable (%ld)\n", PTR_ERR(pcie->phy));
-+		pcie->phy = NULL;
-+		return 0;
-+	}
-+
-+	ret = advk_pcie_enable_phy(pcie);
-+	if (ret)
-+		dev_err(dev, "Failed to initialize PHY (%d)\n", ret);
-+
-+	return ret;
-+}
-+
- static int advk_pcie_probe(struct platform_device *pdev)
- {
- 	struct device *dev = &pdev->dev;
-@@ -1140,6 +1205,10 @@ static int advk_pcie_probe(struct platfo
- 	else
- 		pcie->link_gen = ret;
- 
-+	ret = advk_pcie_setup_phy(pcie);
-+	if (ret)
-+		return ret;
-+
- 	advk_pcie_setup_hw(pcie);
- 
- 	ret = advk_sw_pci_bridge_init(pcie);
diff --git a/target/linux/mvebu/patches-5.10/020-arm64-dts-marvell-armada-37xx-Set-pcie_reset_pin-to-.patch b/target/linux/mvebu/patches-5.10/020-arm64-dts-marvell-armada-37xx-Set-pcie_reset_pin-to-.patch
deleted file mode 100644
index 87247b63ad..0000000000
--- a/target/linux/mvebu/patches-5.10/020-arm64-dts-marvell-armada-37xx-Set-pcie_reset_pin-to-.patch
+++ /dev/null
@@ -1,93 +0,0 @@
-From 715878016984b2617f6c1f177c50039e12e7bd5b Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
-Date: Thu, 30 Apr 2020 10:06:23 +0200
-Subject: [PATCH] arm64: dts: marvell: armada-37xx: Set pcie_reset_pin to gpio
- function
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-We found out that we are unable to control the PERST# signal via the
-default pin dedicated to be PERST# pin (GPIO2[3] pin) on A3700 SOC when
-this pin is in EP_PCIE1_Resetn mode. There is a register in the PCIe
-register space called PERSTN_GPIO_EN (D0088004[3]), but changing the
-value of this register does not change the pin output when measuring
-with voltmeter.
-
-We do not know if this is a bug in the SOC, or if it works only when
-PCIe controller is in a certain state.
-
-Commit f4c7d053d7f7 ("PCI: aardvark: Wait for endpoint to be ready
-before training link") says that when this pin changes pinctrl mode
-from EP_PCIE1_Resetn to GPIO, the PERST# signal is asserted for a brief
-moment.
-
-So currently the situation is that on A3700 boards the PERST# signal is
-asserted in U-Boot (because the code in U-Boot issues reset via this pin
-via GPIO mode), and then in Linux by the obscure and undocumented
-mechanism described by the above mentioned commit.
-
-We want to issue PERST# signal in a known way, therefore this patch
-changes the pcie_reset_pin function from "pcie" to "gpio" and adds the
-reset-gpios property to the PCIe node in device tree files of
-EspressoBin and Armada 3720 Dev Board (Turris Mox device tree already
-has this property and uDPU does not have a PCIe port).
-
-Signed-off-by: Marek BehÃºn <marek.behun@nic.cz>
-Cc: Remi Pommarel <repk@triplefau.lt>
-Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
-Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
-Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
----
- arch/arm64/boot/dts/marvell/armada-3720-db.dts           | 3 +++
- arch/arm64/boot/dts/marvell/armada-3720-espressobin.dtsi | 1 +
- arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts   | 4 ----
- arch/arm64/boot/dts/marvell/armada-37xx.dtsi             | 2 +-
- 4 files changed, 5 insertions(+), 5 deletions(-)
-
---- a/arch/arm64/boot/dts/marvell/armada-3720-db.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-db.dts
-@@ -128,6 +128,9 @@
- 
- /* CON15(V2.0)/CON17(V1.4) : PCIe / CON15(V2.0)/CON12(V1.4) :mini-PCIe */
- &pcie0 {
-+	pinctrl-names = "default";
-+	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
-+	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
- 	status = "okay";
- };
- 
---- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
-@@ -59,6 +59,7 @@
- 	phys = <&comphy1 0>;
- 	pinctrl-names = "default";
- 	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
-+	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
- };
- 
- /* J6 */
---- a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
-@@ -120,10 +120,6 @@
- 	};
- };
- 
--&pcie_reset_pins {
--	function = "gpio";
--};
--
- &pcie0 {
- 	pinctrl-names = "default";
- 	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
---- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
-+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
-@@ -317,7 +317,7 @@
- 
- 				pcie_reset_pins: pcie-reset-pins {
- 					groups = "pcie1";
--					function = "pcie";
-+					function = "gpio";
- 				};
- 
- 				pcie_clkreq_pins: pcie-clkreq-pins {
diff --git a/target/linux/mvebu/patches-5.10/021-arm64-dts-marvell-armada-37xx-Move-PCIe-comphy-handl.patch b/target/linux/mvebu/patches-5.10/021-arm64-dts-marvell-armada-37xx-Move-PCIe-comphy-handl.patch
deleted file mode 100644
index e92393ff6f..0000000000
--- a/target/linux/mvebu/patches-5.10/021-arm64-dts-marvell-armada-37xx-Move-PCIe-comphy-handl.patch
+++ /dev/null
@@ -1,57 +0,0 @@
-From df749cdb015011e9ed8b60ebb84b4e76a9f35735 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
-Date: Thu, 30 Apr 2020 10:06:24 +0200
-Subject: [PATCH] arm64: dts: marvell: armada-37xx: Move PCIe comphy handle
- property
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Move the comphy handle property of the PCIe node from board specific
-device tree files (EspressoBin and Turris Mox) to the generic
-armada-37xx.dtsi.
-
-This is correct since this is the only possible PCIe PHY configuration
-on Armada 37xx, so when PCIe is enabled on any board, this handle is
-correct.
-
-Signed-off-by: Marek BehÃºn <marek.behun@nic.cz>
-Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
-Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
-Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
----
- arch/arm64/boot/dts/marvell/armada-3720-espressobin.dtsi | 1 -
- arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts   | 1 -
- arch/arm64/boot/dts/marvell/armada-37xx.dtsi             | 1 +
- 3 files changed, 1 insertion(+), 2 deletions(-)
-
---- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
-@@ -56,7 +56,6 @@
- /* J9 */
- &pcie0 {
- 	status = "okay";
--	phys = <&comphy1 0>;
- 	pinctrl-names = "default";
- 	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
- 	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
---- a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
-@@ -126,7 +126,6 @@
- 	status = "okay";
- 	max-link-speed = <2>;
- 	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
--	phys = <&comphy1 0>;
- 
- 	/* enabled by U-Boot if PCIe module is present */
- 	status = "disabled";
---- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
-+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
-@@ -493,6 +493,7 @@
- 					<0 0 0 2 &pcie_intc 1>,
- 					<0 0 0 3 &pcie_intc 2>,
- 					<0 0 0 4 &pcie_intc 3>;
-+			phys = <&comphy1 0>;
- 			pcie_intc: interrupt-controller {
- 				interrupt-controller;
- 				#interrupt-cells = <1>;
diff --git a/target/linux/mvebu/patches-5.10/022-arm64-dts-marvell-armada-37xx-Move-PCIe-max-link-spe.patch b/target/linux/mvebu/patches-5.10/022-arm64-dts-marvell-armada-37xx-Move-PCIe-max-link-spe.patch
deleted file mode 100644
index ad918bef88..0000000000
--- a/target/linux/mvebu/patches-5.10/022-arm64-dts-marvell-armada-37xx-Move-PCIe-max-link-spe.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From 1b5a2dd9e266d78d5fddd7e6b116e47ba9577b5e Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
-Date: Thu, 30 Apr 2020 10:06:25 +0200
-Subject: [PATCH] arm64: dts: marvell: armada-37xx: Move PCIe max-link-speed
- property
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Move the max-link-speed property of the PCIe node from board specific
-device tree files to the generic armada-37xx.dtsi.
-
-Armada 37xx supports only PCIe gen2 speed so max-link-speed property
-should be in the generic armada-37xx.dtsi file.
-
-Signed-off-by: Pali RohÃ¡r <pali@kernel.org>
-Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
-Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
-Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
----
- arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts | 1 -
- arch/arm64/boot/dts/marvell/armada-37xx.dtsi           | 1 +
- 2 files changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
-@@ -124,7 +124,6 @@
- 	pinctrl-names = "default";
- 	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
- 	status = "okay";
--	max-link-speed = <2>;
- 	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
- 
- 	/* enabled by U-Boot if PCIe module is present */
---- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
-+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
-@@ -493,6 +493,7 @@
- 					<0 0 0 2 &pcie_intc 1>,
- 					<0 0 0 3 &pcie_intc 2>,
- 					<0 0 0 4 &pcie_intc 3>;
-+			max-link-speed = <2>;
- 			phys = <&comphy1 0>;
- 			pcie_intc: interrupt-controller {
- 				interrupt-controller;
diff --git a/target/linux/mvebu/patches-5.10/023-arm64-dts-add-uDPU-i2c-bus-recovery.patch b/target/linux/mvebu/patches-5.10/023-arm64-dts-add-uDPU-i2c-bus-recovery.patch
deleted file mode 100644
index 818fce85a8..0000000000
--- a/target/linux/mvebu/patches-5.10/023-arm64-dts-add-uDPU-i2c-bus-recovery.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From 11b2af36cc874027ce701c5784cb957c99c7de3d Mon Sep 17 00:00:00 2001
-From: Russell King <rmk+kernel@armlinux.org.uk>
-Date: Wed, 6 May 2020 10:40:37 +0100
-Subject: [PATCH] arm64: dts: add uDPU i2c bus recovery
-
-Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
-Reviewed-by: Andrew Lunn <andrew@lunn.ch>
-Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
----
- .../boot/dts/marvell/armada-3720-uDPU.dts     | 22 +++++++++++++++++--
- 1 file changed, 20 insertions(+), 2 deletions(-)
-
---- a/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
-@@ -117,18 +117,36 @@
- 	};
- };
- 
-+&pinctrl_nb {
-+	i2c1_recovery_pins: i2c1-recovery-pins {
-+		groups = "i2c1";
-+		function = "gpio";
-+	};
-+
-+	i2c2_recovery_pins: i2c2-recovery-pins {
-+		groups = "i2c2";
-+		function = "gpio";
-+	};
-+};
-+
- &i2c0 {
- 	status = "okay";
--	pinctrl-names = "default";
-+	pinctrl-names = "default", "recovery";
- 	pinctrl-0 = <&i2c1_pins>;
-+	pinctrl-1 = <&i2c1_recovery_pins>;
- 	/delete-property/mrvl,i2c-fast-mode;
-+	scl-gpios = <&gpionb 0 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
-+	sda-gpios = <&gpionb 1 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
- };
- 
- &i2c1 {
- 	status = "okay";
--	pinctrl-names = "default";
-+	pinctrl-names = "default", "recovery";
- 	pinctrl-0 = <&i2c2_pins>;
-+	pinctrl-1 = <&i2c2_recovery_pins>;
- 	/delete-property/mrvl,i2c-fast-mode;
-+	scl-gpios = <&gpionb 2 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
-+	sda-gpios = <&gpionb 3 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
- 
- 	lm75@48 {
- 		status = "okay";
diff --git a/target/linux/mvebu/patches-5.10/024-PCI-aardvark-Don-t-touch-PCIe-registers-if-no-card-c.patch b/target/linux/mvebu/patches-5.10/024-PCI-aardvark-Don-t-touch-PCIe-registers-if-no-card-c.patch
deleted file mode 100644
index dfc068c8cb..0000000000
--- a/target/linux/mvebu/patches-5.10/024-PCI-aardvark-Don-t-touch-PCIe-registers-if-no-card-c.patch
+++ /dev/null
@@ -1,50 +0,0 @@
-From 70e380250c3621c55ff218cbaf2272830d9dbb1d Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
-Date: Thu, 2 Jul 2020 10:30:36 +0200
-Subject: [PATCH] PCI: aardvark: Don't touch PCIe registers if no card
- connected
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-When there is no PCIe card connected and advk_pcie_rd_conf() or
-advk_pcie_wr_conf() is called for PCI bus which doesn't belong to emulated
-root bridge, the aardvark driver throws the following error message:
-
-  advk-pcie d0070000.pcie: config read/write timed out
-
-Obviously accessing PCIe registers of disconnected card is not possible.
-
-Extend check in advk_pcie_valid_device() function for validating
-availability of PCIe bus. If PCIe link is down, then the device is marked
-as Not Found and the driver does not try to access these registers.
-
-This is just an optimization to prevent accessing PCIe registers when card
-is disconnected. Trying to access PCIe registers of disconnected card does
-not cause any crash, kernel just needs to wait for a timeout. So if card
-disappear immediately after checking for PCIe link (before accessing PCIe
-registers), it does not cause any problems.
-
-Link: https://lore.kernel.org/r/20200702083036.12230-1-pali@kernel.org
-Signed-off-by: Pali RohÃ¡r <pali@kernel.org>
-Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
----
- drivers/pci/controller/pci-aardvark.c | 7 +++++++
- 1 file changed, 7 insertions(+)
-
---- a/drivers/pci/controller/pci-aardvark.c
-+++ b/drivers/pci/controller/pci-aardvark.c
-@@ -639,6 +639,13 @@ static bool advk_pcie_valid_device(struc
- 	if ((bus->number == pcie->root_bus_nr) && PCI_SLOT(devfn) != 0)
- 		return false;
- 
-+	/*
-+	 * If the link goes down after we check for link-up, nothing bad
-+	 * happens but the config access times out.
-+	 */
-+	if (bus->number != pcie->root_bus_nr && !advk_pcie_link_up(pcie))
-+		return false;
-+
- 	return true;
- }
- 
diff --git a/target/linux/mvebu/patches-5.10/025-power-reset-add-driver-for-LinkStation-power-off.patch b/target/linux/mvebu/patches-5.10/025-power-reset-add-driver-for-LinkStation-power-off.patch
deleted file mode 100644
index 64ea26559e..0000000000
--- a/target/linux/mvebu/patches-5.10/025-power-reset-add-driver-for-LinkStation-power-off.patch
+++ /dev/null
@@ -1,207 +0,0 @@
-From a7f79f99541eff4e6bcae0014eb08d3019337565 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Daniel=20Gonz=C3=A1lez=20Cabanelas?= <dgcbueu@gmail.com>
-Date: Wed, 15 Jul 2020 15:35:14 +0200
-Subject: [PATCH] power: reset: add driver for LinkStation power off
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Some Buffalo LinkStations perform the power off operation, at restart
-time, depending on the state of an output pin (LED2/INTn) at the ethernet
-PHY. This pin is also used to wake the machine when a WoL packet is
-received by the PHY.
-
-The driver is required by the Buffalo LinkStation LS421DE (ARM MVEBU),
-and other models. Without it, the board remains forever halted if a
-power off command is executed, unless the PSU is disconnected and
-connected again.
-
-Add the driver to provide the power off function and also make the WoL
-feature to be available.
-
-Signed-off-by: Daniel GonzÃ¡lez Cabanelas <dgcbueu@gmail.com>
-Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
----
- drivers/power/reset/Kconfig                |  11 ++
- drivers/power/reset/Makefile               |   1 +
- drivers/power/reset/linkstation-poweroff.c | 136 +++++++++++++++++++++
- 3 files changed, 148 insertions(+)
- create mode 100644 drivers/power/reset/linkstation-poweroff.c
-
---- a/drivers/power/reset/Kconfig
-+++ b/drivers/power/reset/Kconfig
-@@ -99,6 +99,17 @@ config POWER_RESET_HISI
- 	help
- 	  Reboot support for Hisilicon boards.
- 
-+config POWER_RESET_LINKSTATION
-+	tristate "Buffalo LinkStation power-off driver"
-+	depends on ARCH_MVEBU || COMPILE_TEST
-+	depends on OF_MDIO && PHYLIB
-+	help
-+	  This driver supports turning off some Buffalo LinkStations by
-+	  setting an output pin at the ethernet PHY to the correct state.
-+	  It also makes the device compatible with the WoL function.
-+
-+	  Say Y here if you have a Buffalo LinkStation LS421D/E.
-+
- config POWER_RESET_MSM
- 	bool "Qualcomm MSM power-off driver"
- 	depends on ARCH_QCOM
---- a/drivers/power/reset/Makefile
-+++ b/drivers/power/reset/Makefile
-@@ -10,6 +10,7 @@ obj-$(CONFIG_POWER_RESET_GEMINI_POWEROFF
- obj-$(CONFIG_POWER_RESET_GPIO) += gpio-poweroff.o
- obj-$(CONFIG_POWER_RESET_GPIO_RESTART) += gpio-restart.o
- obj-$(CONFIG_POWER_RESET_HISI) += hisi-reboot.o
-+obj-${CONFIG_POWER_RESET_LINKSTATION} += linkstation-poweroff.o
- obj-$(CONFIG_POWER_RESET_MSM) += msm-poweroff.o
- obj-$(CONFIG_POWER_RESET_QCOM_PON) += qcom-pon.o
- obj-$(CONFIG_POWER_RESET_OCELOT_RESET) += ocelot-reset.o
---- /dev/null
-+++ b/drivers/power/reset/linkstation-poweroff.c
-@@ -0,0 +1,144 @@
-+// SPDX-License-Identifier: GPL-2.0
-+/*
-+ * LinkStation power off restart driver
-+ * Copyright (C) 2020 Daniel GonzÃ¡lez Cabanelas <dgcbueu@gmail.com>
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/notifier.h>
-+#include <linux/of.h>
-+#include <linux/of_mdio.h>
-+#include <linux/of_platform.h>
-+#include <linux/reboot.h>
-+#include <linux/phy.h>
-+
-+/* Defines from the eth phy Marvell driver */
-+#define MII_MARVELL_COPPER_PAGE		0
-+#define MII_MARVELL_LED_PAGE		3
-+#define MII_MARVELL_WOL_PAGE		17
-+#define MII_MARVELL_PHY_PAGE		22
-+
-+#define MII_PHY_LED_CTRL		16
-+#define MII_88E1318S_PHY_LED_TCR	18
-+#define MII_88E1318S_PHY_WOL_CTRL	16
-+#define MII_M1011_IEVENT		19
-+
-+#define MII_88E1318S_PHY_LED_TCR_INTn_ENABLE		BIT(7)
-+#define MII_88E1318S_PHY_LED_TCR_FORCE_INT		BIT(15)
-+#define MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS	BIT(12)
-+#define LED2_FORCE_ON					(0x8 << 8)
-+#define LEDMASK						GENMASK(11,8)
-+
-+static struct phy_device *phydev;
-+
-+static void mvphy_reg_intn(u16 data)
-+{
-+	int rc = 0, saved_page;
-+
-+	saved_page = phy_select_page(phydev, MII_MARVELL_LED_PAGE);
-+	if (saved_page < 0)
-+		goto err;
-+
-+	/* Force manual LED2 control to let INTn work */
-+	__phy_modify(phydev, MII_PHY_LED_CTRL, LEDMASK, LED2_FORCE_ON);
-+
-+	/* Set the LED[2]/INTn pin to the required state */
-+	__phy_modify(phydev, MII_88E1318S_PHY_LED_TCR,
-+		     MII_88E1318S_PHY_LED_TCR_FORCE_INT,
-+		     MII_88E1318S_PHY_LED_TCR_INTn_ENABLE | data);
-+
-+	if (!data) {
-+		/* Clear interrupts to ensure INTn won't be holded in high state */
-+		__phy_write(phydev, MII_MARVELL_PHY_PAGE, MII_MARVELL_COPPER_PAGE);
-+		__phy_read(phydev, MII_M1011_IEVENT);
-+
-+		/* If WOL was enabled and a magic packet was received before powering
-+		 * off, we won't be able to wake up by sending another magic packet.
-+		 * Clear WOL status.
-+		 */
-+		__phy_write(phydev, MII_MARVELL_PHY_PAGE, MII_MARVELL_WOL_PAGE);
-+		__phy_set_bits(phydev, MII_88E1318S_PHY_WOL_CTRL,
-+			       MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS);
-+	}
-+err:
-+	rc = phy_restore_page(phydev, saved_page, rc);
-+	if (rc < 0)
-+		dev_err(&phydev->mdio.dev, "Write register failed, %d\n", rc);
-+
-+	if (!data) {
-+		/* Slow down the PHY to save energy */
-+		rc= phy_speed_down(phydev, false);
-+		if (rc < 0)
-+			dev_err(&phydev->mdio.dev, "PHY speed down failed, %d\n", rc);
-+	}
-+}
-+
-+static int linkstation_reboot_notifier(struct notifier_block *nb,
-+				       unsigned long action, void *unused)
-+{
-+	if (action == SYS_RESTART)
-+		mvphy_reg_intn(MII_88E1318S_PHY_LED_TCR_FORCE_INT);
-+
-+	return NOTIFY_DONE;
-+}
-+
-+static struct notifier_block linkstation_reboot_nb = {
-+	.notifier_call = linkstation_reboot_notifier,
-+};
-+
-+static void linkstation_poweroff(void)
-+{
-+	unregister_reboot_notifier(&linkstation_reboot_nb);
-+	mvphy_reg_intn(0);
-+
-+	kernel_restart("Power off");
-+}
-+
-+static const struct of_device_id ls_poweroff_of_match[] = {
-+	{ .compatible = "buffalo,ls421d" },
-+	{ .compatible = "buffalo,ls421de" },
-+	{ },
-+};
-+
-+static int __init linkstation_poweroff_init(void)
-+{
-+	struct mii_bus *bus;
-+	struct device_node *dn;
-+
-+	dn = of_find_matching_node(NULL, ls_poweroff_of_match);
-+	if (!dn)
-+		return -ENODEV;
-+	of_node_put(dn);
-+
-+	dn = of_find_node_by_name(NULL, "mdio");
-+	if (!dn)
-+		return -ENODEV;
-+
-+	bus = of_mdio_find_bus(dn);
-+	of_node_put(dn);
-+	if (!bus)
-+		return -EPROBE_DEFER;
-+
-+	phydev = phy_find_first(bus);
-+	if (!phydev)
-+		return -EPROBE_DEFER;
-+
-+	register_reboot_notifier(&linkstation_reboot_nb);
-+	pm_power_off = linkstation_poweroff;
-+
-+	pr_info("LinkStation power off driver registered\n");
-+	return 0;
-+}
-+
-+static void __exit linkstation_poweroff_exit(void)
-+{
-+	pm_power_off = NULL;
-+	unregister_reboot_notifier(&linkstation_reboot_nb);
-+}
-+
-+module_init(linkstation_poweroff_init);
-+module_exit(linkstation_poweroff_exit);
-+
-+MODULE_AUTHOR("Daniel GonzÃ¡lez Cabanelas <dgcbueu@gmail.com>");
-+MODULE_DESCRIPTION("LinkStation power off driver");
-+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/mvebu/patches-5.10/026-PCI-aardvark-Fix-initialization-with-old-Marvell-s-A.patch b/target/linux/mvebu/patches-5.10/026-PCI-aardvark-Fix-initialization-with-old-Marvell-s-A.patch
deleted file mode 100644
index bb9d7b7849..0000000000
--- a/target/linux/mvebu/patches-5.10/026-PCI-aardvark-Fix-initialization-with-old-Marvell-s-A.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From b0c6ae0f8948a2be6bf4e8b4bbab9ca1343289b6 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
-Date: Wed, 2 Sep 2020 16:43:44 +0200
-Subject: [PATCH] PCI: aardvark: Fix initialization with old Marvell's Arm
- Trusted Firmware
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Old ATF automatically power on pcie phy and does not provide SMC call for
-phy power on functionality which leads to aardvark initialization failure:
-
-[    0.330134] mvebu-a3700-comphy d0018300.phy: unsupported SMC call, try updating your firmware
-[    0.338846] phy phy-d0018300.phy.1: phy poweron failed --> -95
-[    0.344753] advk-pcie d0070000.pcie: Failed to initialize PHY (-95)
-[    0.351160] advk-pcie: probe of d0070000.pcie failed with error -95
-
-This patch fixes above failure by ignoring 'not supported' error in
-aardvark driver. In this case it is expected that phy is already power on.
-
-Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
-Link: https://lore.kernel.org/r/20200902144344.16684-3-pali@kernel.org
-Fixes: 366697018c9a ("PCI: aardvark: Add PHY support")
-Signed-off-by: Pali RohÃ¡r <pali@kernel.org>
-Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
-Reviewed-by: Rob Herring <robh@kernel.org>
-Cc: <stable@vger.kernel.org> # 5.8+: ea17a0f153af: phy: marvell: comphy: Convert internal SMCC firmware return codes to errno
----
- drivers/pci/controller/pci-aardvark.c | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
---- a/drivers/pci/controller/pci-aardvark.c
-+++ b/drivers/pci/controller/pci-aardvark.c
-@@ -1123,7 +1123,9 @@ static int advk_pcie_enable_phy(struct a
- 	}
- 
- 	ret = phy_power_on(pcie->phy);
--	if (ret) {
-+	if (ret == -EOPNOTSUPP) {
-+		dev_warn(&pcie->pdev->dev, "PHY unsupported by firmware\n");
-+	} else if (ret) {
- 		phy_exit(pcie->phy);
- 		return ret;
- 	}
diff --git a/target/linux/mvebu/patches-5.10/027-arm64-dts-marvell-espressobin-Add-ethernet-switch-al.patch b/target/linux/mvebu/patches-5.10/027-arm64-dts-marvell-espressobin-Add-ethernet-switch-al.patch
deleted file mode 100644
index 927670d8b3..0000000000
--- a/target/linux/mvebu/patches-5.10/027-arm64-dts-marvell-espressobin-Add-ethernet-switch-al.patch
+++ /dev/null
@@ -1,88 +0,0 @@
-From b64d814257b027e29a474bcd660f6372490138c7 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
-Date: Mon, 7 Sep 2020 13:27:17 +0200
-Subject: [PATCH] arm64: dts: marvell: espressobin: Add ethernet switch aliases
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Espressobin boards have 3 ethernet ports and some of them got assigned more
-then one MAC address. MAC addresses are stored in U-Boot environment.
-
-Since commit a2c7023f7075c ("net: dsa: read mac address from DT for slave
-device") kernel can use MAC addresses from DT for particular DSA port.
-
-Currently Espressobin DTS file contains alias just for ethernet0.
-
-This patch defines additional ethernet aliases in Espressobin DTS files, so
-bootloader can fill correct MAC address for DSA switch ports if more MAC
-addresses were specified.
-
-DT alias ethernet1 is used for wan port, DT aliases ethernet2 and ethernet3
-are used for lan ports for both Espressobin revisions (V5 and V7).
-
-Fixes: 5253cb8c00a6f ("arm64: dts: marvell: espressobin: add ethernet alias")
-Cc: <stable@vger.kernel.org> # a2c7023f7075c: dsa: read mac address
-Signed-off-by: Pali RohÃ¡r <pali@kernel.org>
-Reviewed-by: Andrew Lunn <andrew@lunn.ch>
-Reviewed-by: Andre Heider <a.heider@gmail.com>
-Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
----
- .../dts/marvell/armada-3720-espressobin-v7-emmc.dts  | 10 ++++++++--
- .../boot/dts/marvell/armada-3720-espressobin-v7.dts  | 10 ++++++++--
- 3 files changed, 24 insertions(+), 8 deletions(-)
-
---- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7-emmc.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7-emmc.dts
-@@ -15,16 +15,22 @@
- 	compatible = "globalscale,espressobin-v7-emmc", "globalscale,espressobin-v7",
- 		     "globalscale,espressobin", "marvell,armada3720",
- 		     "marvell,armada3710";
-+
-+	aliases {
-+		/* ethernet1 is wan port */
-+		ethernet1 = &switch0port3;
-+		ethernet3 = &switch0port1;
-+	};
- };
- 
- &ports {
--	port@1 {
-+	switch0port1: port@1 {
- 		reg = <1>;
- 		label = "lan1";
- 		phy-handle = <&switch0phy0>;
- 	};
- 
--	port@3 {
-+	switch0port3: port@3 {
- 		reg = <3>;
- 		label = "wan";
- 		phy-handle = <&switch0phy2>;
---- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7.dts
-@@ -14,16 +14,22 @@
- 	model = "Globalscale Marvell ESPRESSOBin Board V7";
- 	compatible = "globalscale,espressobin-v7", "globalscale,espressobin",
- 		     "marvell,armada3720", "marvell,armada3710";
-+
-+	aliases {
-+		/* ethernet1 is wan port */
-+		ethernet1 = &switch0port3;
-+		ethernet3 = &switch0port1;
-+	};
- };
- 
- &ports {
--	port@1 {
-+	switch0port1: port@1 {
- 		reg = <1>;
- 		label = "lan1";
- 		phy-handle = <&switch0phy0>;
- 	};
- 
--	port@3 {
-+	switch0port3: port@3 {
- 		reg = <3>;
- 		label = "wan";
- 		phy-handle = <&switch0phy2>;
diff --git a/target/linux/mvebu/patches-5.10/300-mvebu-Mangle-bootloader-s-kernel-arguments.patch b/target/linux/mvebu/patches-5.10/300-mvebu-Mangle-bootloader-s-kernel-arguments.patch
index fd60cdb322..f2a0478693 100644
--- a/target/linux/mvebu/patches-5.10/300-mvebu-Mangle-bootloader-s-kernel-arguments.patch
+++ b/target/linux/mvebu/patches-5.10/300-mvebu-Mangle-bootloader-s-kernel-arguments.patch
@@ -28,7 +28,7 @@ Signed-off-by: Michael Gray <michael.gray@lantisproject.com>
 
 --- a/arch/arm/Kconfig
 +++ b/arch/arm/Kconfig
-@@ -1827,6 +1827,17 @@ config ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEN
+@@ -1780,6 +1780,17 @@ config ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEN
  	  The command-line arguments provided by the boot loader will be
  	  appended to the the device tree bootargs property.
  
@@ -48,7 +48,7 @@ Signed-off-by: Michael Gray <michael.gray@lantisproject.com>
  config CMDLINE
 --- a/arch/arm/boot/compressed/atags_to_fdt.c
 +++ b/arch/arm/boot/compressed/atags_to_fdt.c
-@@ -4,6 +4,8 @@
+@@ -5,6 +5,8 @@
  
  #if defined(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND)
  #define do_extend_cmdline 1
@@ -57,7 +57,7 @@ Signed-off-by: Michael Gray <michael.gray@lantisproject.com>
  #else
  #define do_extend_cmdline 0
  #endif
-@@ -67,6 +69,72 @@ static uint32_t get_cell_size(const void
+@@ -69,6 +71,72 @@ static uint32_t get_cell_size(const void
  	return cell_size;
  }
  
@@ -130,7 +130,7 @@ Signed-off-by: Michael Gray <michael.gray@lantisproject.com>
  static void merge_fdt_bootargs(void *fdt, const char *fdt_cmdline)
  {
  	char cmdline[COMMAND_LINE_SIZE];
-@@ -86,12 +154,21 @@ static void merge_fdt_bootargs(void *fdt
+@@ -88,12 +156,21 @@ static void merge_fdt_bootargs(void *fdt
  
  	/* and append the ATAG_CMDLINE */
  	if (fdt_cmdline) {
@@ -152,7 +152,7 @@ Signed-off-by: Michael Gray <michael.gray@lantisproject.com>
  	}
  	*ptr = '\0';
  
-@@ -166,7 +243,9 @@ int atags_to_fdt(void *atag_list, void *
+@@ -168,7 +245,9 @@ int atags_to_fdt(void *atag_list, void *
  			else
  				setprop_string(fdt, "/chosen", "bootargs",
  					       atag->u.cmdline.cmdline);
@@ -163,7 +163,7 @@ Signed-off-by: Michael Gray <michael.gray@lantisproject.com>
  			if (memcount >= sizeof(mem_reg_property)/4)
  				continue;
  			if (!atag->u.mem.size)
-@@ -210,6 +289,10 @@ int atags_to_fdt(void *atag_list, void *
+@@ -212,6 +291,10 @@ int atags_to_fdt(void *atag_list, void *
  		setprop(fdt, "/memory", "reg", mem_reg_property,
  			4 * memcount * memsize);
  	}
@@ -176,9 +176,9 @@ Signed-off-by: Michael Gray <michael.gray@lantisproject.com>
  }
 --- a/init/main.c
 +++ b/init/main.c
-@@ -104,6 +104,10 @@
- #define CREATE_TRACE_POINTS
- #include <trace/events/initcall.h>
+@@ -110,6 +110,10 @@
+ 
+ #include <kunit/test.h>
  
 +#if defined(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE)
 +#include <linux/of.h>
@@ -187,10 +187,10 @@ Signed-off-by: Michael Gray <michael.gray@lantisproject.com>
  static int kernel_init(void *);
  
  extern void init_IRQ(void);
-@@ -631,6 +635,18 @@ asmlinkage __visible void __init start_k
+@@ -903,6 +907,18 @@ asmlinkage __visible void __init __no_sa
  	page_alloc_init();
  
- 	pr_notice("Kernel command line: %s\n", boot_command_line);
+ 	pr_notice("Kernel command line: %s\n", saved_command_line);
 +
 +#if defined(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE)
 +	//Show bootloader's original command line for reference
diff --git a/target/linux/mvebu/patches-5.10/301-mvebu-armada-38x-enable-libata-leds.patch b/target/linux/mvebu/patches-5.10/301-mvebu-armada-38x-enable-libata-leds.patch
index b8ab700c97..615caac24f 100644
--- a/target/linux/mvebu/patches-5.10/301-mvebu-armada-38x-enable-libata-leds.patch
+++ b/target/linux/mvebu/patches-5.10/301-mvebu-armada-38x-enable-libata-leds.patch
@@ -1,7 +1,7 @@
 --- a/arch/arm/mach-mvebu/Kconfig
 +++ b/arch/arm/mach-mvebu/Kconfig
-@@ -69,6 +69,7 @@ config MACH_ARMADA_38X
- 	select HAVE_SMP
+@@ -67,6 +67,7 @@ config MACH_ARMADA_38X
+ 	select HAVE_ARM_TWD if SMP
  	select MACH_MVEBU_V7
  	select PINCTRL_ARMADA_38X
 +	select ARCH_WANT_LIBATA_LEDS
diff --git a/target/linux/mvebu/patches-5.10/315-arm64-dts-marvell-armada-3720-espressobin-add-ports-.patch b/target/linux/mvebu/patches-5.10/315-arm64-dts-marvell-armada-3720-espressobin-add-ports-.patch
deleted file mode 100644
index a741e378d9..0000000000
--- a/target/linux/mvebu/patches-5.10/315-arm64-dts-marvell-armada-3720-espressobin-add-ports-.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From 6ea9a1ee9367fb35acff1c08a0dc4213ff4687a0 Mon Sep 17 00:00:00 2001
-From: Tomasz Maciej Nowak <tmn505@gmail.com>
-Date: Tue, 9 Apr 2019 15:53:42 +0200
-Subject: [PATCH] arm64: dts: marvell: armada-3720-espressobin: add ports
- phandle
-
-Instead of referencing the whole mdio node, add ports phandle to adjust
-port labels in dts for different hardware iterations of ESPRESSObin
-boards.
-
-Signed-off-by: Tomasz Maciej Nowak <tmn505@gmail.com>
----
- arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
-+++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
-@@ -147,7 +147,7 @@
- 
- 		dsa,member = <0 0>;
- 
--		ports {
-+		ports: ports {
- 			#address-cells = <1>;
- 			#size-cells = <0>;
- 
diff --git a/target/linux/mvebu/patches-5.10/400-find_active_root.patch b/target/linux/mvebu/patches-5.10/400-find_active_root.patch
index 854031b0d5..f61d85bc05 100644
--- a/target/linux/mvebu/patches-5.10/400-find_active_root.patch
+++ b/target/linux/mvebu/patches-5.10/400-find_active_root.patch
@@ -39,7 +39,7 @@ Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
  		parts[i].name = partname;
  
  		if (of_get_property(pp, "read-only", &len))
-@@ -215,6 +222,18 @@ static int __init ofpart_parser_init(voi
+@@ -218,6 +225,18 @@ static int __init ofpart_parser_init(voi
  	return 0;
  }
  
diff --git a/target/linux/mvebu/patches-5.10/700-mvneta-tx-queue-workaround.patch b/target/linux/mvebu/patches-5.10/700-mvneta-tx-queue-workaround.patch
index a82a4c0d62..2e840fd787 100644
--- a/target/linux/mvebu/patches-5.10/700-mvneta-tx-queue-workaround.patch
+++ b/target/linux/mvebu/patches-5.10/700-mvneta-tx-queue-workaround.patch
@@ -9,7 +9,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 ---
 --- a/drivers/net/ethernet/marvell/mvneta.c
 +++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -4684,6 +4684,14 @@ static int mvneta_ethtool_set_eee(struct
+@@ -4896,6 +4896,14 @@ static int mvneta_ethtool_set_eee(struct
  	return phylink_ethtool_set_eee(pp->phylink, eee);
  }
  
@@ -24,11 +24,11 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  static const struct net_device_ops mvneta_netdev_ops = {
  	.ndo_open            = mvneta_open,
  	.ndo_stop            = mvneta_stop,
-@@ -4694,6 +4702,7 @@ static const struct net_device_ops mvnet
+@@ -4906,6 +4914,7 @@ static const struct net_device_ops mvnet
  	.ndo_fix_features    = mvneta_fix_features,
  	.ndo_get_stats64     = mvneta_get_stats64,
  	.ndo_do_ioctl        = mvneta_ioctl,
 +	.ndo_select_queue    = mvneta_select_queue,
- 	.ndo_bpf             = mvneta_xdp,
+ 	.ndo_bpf	     = mvneta_xdp,
  	.ndo_xdp_xmit        = mvneta_xdp_xmit,
  };
diff --git a/target/linux/mvebu/patches-5.10/801-pci-mvebu-time-out-reset-on-link-up.patch b/target/linux/mvebu/patches-5.10/801-pci-mvebu-time-out-reset-on-link-up.patch
index 4058dc8ed5..42f890e48c 100644
--- a/target/linux/mvebu/patches-5.10/801-pci-mvebu-time-out-reset-on-link-up.patch
+++ b/target/linux/mvebu/patches-5.10/801-pci-mvebu-time-out-reset-on-link-up.patch
@@ -13,7 +13,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
 
 --- a/drivers/pci/controller/pci-mvebu.c
 +++ b/drivers/pci/controller/pci-mvebu.c
-@@ -928,6 +928,7 @@ static int mvebu_pcie_powerup(struct mve
+@@ -933,6 +933,7 @@ static int mvebu_pcie_powerup(struct mve
  
  	if (port->reset_gpio) {
  		u32 reset_udelay = PCI_PM_D3COLD_WAIT * 1000;
@@ -21,7 +21,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  
  		of_property_read_u32(port->dn, "reset-delay-us",
  				     &reset_udelay);
-@@ -935,7 +936,13 @@ static int mvebu_pcie_powerup(struct mve
+@@ -940,7 +941,13 @@ static int mvebu_pcie_powerup(struct mve
  		udelay(100);
  
  		gpiod_set_value_cansleep(port->reset_gpio, 0);
@@ -36,7 +36,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	}
  
  	return 0;
-@@ -1099,15 +1106,16 @@ static int mvebu_pcie_probe(struct platf
+@@ -1100,15 +1107,16 @@ static int mvebu_pcie_probe(struct platf
  		if (!child)
  			continue;
  
-- 
2.29.2

