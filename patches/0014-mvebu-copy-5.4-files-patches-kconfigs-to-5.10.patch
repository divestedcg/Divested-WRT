From 668862523b607105c227c5b991c7712840f4a7eb Mon Sep 17 00:00:00 2001
From: Rui Salvaterra <rsalvaterra@gmail.com>
Date: Mon, 22 Feb 2021 08:59:32 +0000
Subject: [PATCH] mvebu: copy 5.4 files/patches/kconfigs to 5.10

Just a simple copy, no refresh yet.

Signed-off-by: Rui Salvaterra <rsalvaterra@gmail.com>
Tested-by: Tad <tad@spotco.us>
---
 target/linux/mvebu/config-5.10                | 430 ++++++++++
 target/linux/mvebu/cortexa53/config-5.10      |  95 +++
 target/linux/mvebu/cortexa72/config-5.10      | 102 +++
 .../boot/dts/armada-370-buffalo-ls421de.dts   | 433 ++++++++++
 .../arm/boot/dts/armada-385-linksys-venom.dts | 213 +++++
 .../marvell/armada-3720-espressobin-emmc.dts  |  28 +
 .../marvell/armada-3720-espressobin-ultra.dts | 241 ++++++
 .../armada-3720-espressobin-v7-emmc.dts       |  43 +
 .../marvell/armada-3720-espressobin-v7.dts    |  31 +
 .../dts/marvell/armada-3720-gl-mv1000.dts     | 162 ++++
 ...t-for-endpoint-to-be-ready-before-tr.patch |  50 ++
 ...-t-rely-on-jiffies-while-holding-spi.patch |  54 ++
 ...ntroduce-mvneta_update_stats-routine.patch |  95 +++
 ...duce-page-pool-API-for-sw-buffer-man.patch | 181 ++++
 ...on-build_skb-in-mvneta_rx_swbm-poll-.patch | 303 +++++++
 ...006-net-mvneta-add-basic-XDP-support.patch | 311 +++++++
 ...avoid_error_message_for_optional_IRQ.patch |  31 +
 ...header-prefetch-in-mvneta_swbm_rx_fr.patch |  43 +
 ...mvneta-make-tx-buffer-array-agnostic.patch | 210 +++++
 .../009-net-mvneta-add-XDP_TX-support.patch   | 175 ++++
 ...fix-build-skb-for-bm-capable-devices.patch |  41 +
 ...-arm64-dts-uDPU-remove-i2c-fast-mode.patch |  31 +
 ...ts-uDPU-SFP-cages-support-3W-modules.patch |  34 +
 ...on-page_pool_recycle_direct-in-mvnet.patch |  39 +
 ...sallow-XDP-program-on-hardware-buffe.patch |  53 ++
 ...DP-support-if-sw-bm-is-used-as-fallb.patch |  67 ++
 ...in-link-immediately-after-enabling-t.patch |  60 ++
 ...7-PCI-aardvark-Improve-link-training.patch | 208 +++++
 ...18-PCI-aardvark-Issue-PERST-via-GPIO.patch | 123 +++
 .../019-PCI-aardvark-Add-PHY-support.patch    | 152 ++++
 ...l-armada-37xx-Set-pcie_reset_pin-to-.patch |  93 +++
 ...l-armada-37xx-Move-PCIe-comphy-handl.patch |  57 ++
 ...l-armada-37xx-Move-PCIe-max-link-spe.patch |  44 +
 ...-arm64-dts-add-uDPU-i2c-bus-recovery.patch |  53 ++
 ...-t-touch-PCIe-registers-if-no-card-c.patch |  50 ++
 ...add-driver-for-LinkStation-power-off.patch | 207 +++++
 ...-initialization-with-old-Marvell-s-A.patch |  44 +
 ...l-espressobin-Add-ethernet-switch-al.patch |  88 ++
 ...s-mcbin-singleshot-add-heartbeat-LED.patch |  65 ++
 ...Mangle-bootloader-s-kernel-arguments.patch | 208 +++++
 ...-mvebu-armada-38x-enable-libata-leds.patch |  10 +
 .../patches-5.10/302-add_powertables.patch    | 770 ++++++++++++++++++
 ...3-linksys_hardcode_nand_ecc_settings.patch |  17 +
 .../patches-5.10/304-revert_i2c_delay.patch   |  15 +
 .../305-armada-385-rd-mtd-partitions.patch    |  19 +
 .../306-ARM-mvebu-385-ap-Add-partitions.patch |  35 +
 ...-armada-xp-linksys-mamba-broken-idle.patch |  10 +
 .../308-armada-xp-linksys-mamba-wan.patch     |  11 +
 .../patches-5.10/309-linksys-status-led.patch |  50 ++
 .../310-linksys-use-eth0-as-cpu-port.patch    |  25 +
 .../311-adjust-compatible-for-linksys.patch   |  68 ++
 ...da388-clearfog-emmc-on-clearfog-base.patch |  87 ++
 .../312-helios4-dts-status-led-alias.patch    |  28 +
 ...ts-marvell-armada37xx-Add-eth0-alias.patch |  20 +
 ...l-armada-3720-espressobin-add-ports-.patch |  26 +
 ...witch-PHY-operation-mode-to-2500base.patch |  34 +
 .../patches-5.10/400-find_active_root.patch   |  60 ++
 .../700-mvneta-tx-queue-workaround.patch      |  34 +
 ...dicate-failure-to-enter-deeper-sleep.patch |  40 +
 ...-pci-mvebu-time-out-reset-on-link-up.patch |  60 ++
 60 files changed, 6367 insertions(+)
 create mode 100644 target/linux/mvebu/config-5.10
 create mode 100644 target/linux/mvebu/cortexa53/config-5.10
 create mode 100644 target/linux/mvebu/cortexa72/config-5.10
 create mode 100644 target/linux/mvebu/files-5.10/arch/arm/boot/dts/armada-370-buffalo-ls421de.dts
 create mode 100644 target/linux/mvebu/files-5.10/arch/arm/boot/dts/armada-385-linksys-venom.dts
 create mode 100644 target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-emmc.dts
 create mode 100644 target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-ultra.dts
 create mode 100644 target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7-emmc.dts
 create mode 100644 target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7.dts
 create mode 100644 target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-gl-mv1000.dts
 create mode 100644 target/linux/mvebu/patches-5.10/001-PCI-aardvark-Wait-for-endpoint-to-be-ready-before-tr.patch
 create mode 100644 target/linux/mvebu/patches-5.10/002-PCI-aardvark-Don-t-rely-on-jiffies-while-holding-spi.patch
 create mode 100644 target/linux/mvebu/patches-5.10/003-net-mvneta-introduce-mvneta_update_stats-routine.patch
 create mode 100644 target/linux/mvebu/patches-5.10/004-net-mvneta-introduce-page-pool-API-for-sw-buffer-man.patch
 create mode 100644 target/linux/mvebu/patches-5.10/005-net-mvneta-rely-on-build_skb-in-mvneta_rx_swbm-poll-.patch
 create mode 100644 target/linux/mvebu/patches-5.10/006-net-mvneta-add-basic-XDP-support.patch
 create mode 100644 target/linux/mvebu/patches-5.10/007-gpio-mvebu-avoid_error_message_for_optional_IRQ.patch
 create mode 100644 target/linux/mvebu/patches-5.10/007-net-mvneta-move-header-prefetch-in-mvneta_swbm_rx_fr.patch
 create mode 100644 target/linux/mvebu/patches-5.10/008-net-mvneta-make-tx-buffer-array-agnostic.patch
 create mode 100644 target/linux/mvebu/patches-5.10/009-net-mvneta-add-XDP_TX-support.patch
 create mode 100644 target/linux/mvebu/patches-5.10/010-net-mvneta-fix-build-skb-for-bm-capable-devices.patch
 create mode 100644 target/linux/mvebu/patches-5.10/011-arm64-dts-uDPU-remove-i2c-fast-mode.patch
 create mode 100644 target/linux/mvebu/patches-5.10/012-arm64-dts-uDPU-SFP-cages-support-3W-modules.patch
 create mode 100644 target/linux/mvebu/patches-5.10/013-net-mvneta-rely-on-page_pool_recycle_direct-in-mvnet.patch
 create mode 100644 target/linux/mvebu/patches-5.10/014-mvneta-driver-disallow-XDP-program-on-hardware-buffe.patch
 create mode 100644 target/linux/mvebu/patches-5.10/015-net-mvneta-fix-XDP-support-if-sw-bm-is-used-as-fallb.patch
 create mode 100644 target/linux/mvebu/patches-5.10/016-PCI-aardvark-Train-link-immediately-after-enabling-t.patch
 create mode 100644 target/linux/mvebu/patches-5.10/017-PCI-aardvark-Improve-link-training.patch
 create mode 100644 target/linux/mvebu/patches-5.10/018-PCI-aardvark-Issue-PERST-via-GPIO.patch
 create mode 100644 target/linux/mvebu/patches-5.10/019-PCI-aardvark-Add-PHY-support.patch
 create mode 100644 target/linux/mvebu/patches-5.10/020-arm64-dts-marvell-armada-37xx-Set-pcie_reset_pin-to-.patch
 create mode 100644 target/linux/mvebu/patches-5.10/021-arm64-dts-marvell-armada-37xx-Move-PCIe-comphy-handl.patch
 create mode 100644 target/linux/mvebu/patches-5.10/022-arm64-dts-marvell-armada-37xx-Move-PCIe-max-link-spe.patch
 create mode 100644 target/linux/mvebu/patches-5.10/023-arm64-dts-add-uDPU-i2c-bus-recovery.patch
 create mode 100644 target/linux/mvebu/patches-5.10/024-PCI-aardvark-Don-t-touch-PCIe-registers-if-no-card-c.patch
 create mode 100644 target/linux/mvebu/patches-5.10/025-power-reset-add-driver-for-LinkStation-power-off.patch
 create mode 100644 target/linux/mvebu/patches-5.10/026-PCI-aardvark-Fix-initialization-with-old-Marvell-s-A.patch
 create mode 100644 target/linux/mvebu/patches-5.10/027-arm64-dts-marvell-espressobin-Add-ethernet-switch-al.patch
 create mode 100644 target/linux/mvebu/patches-5.10/028-arm64-dts-mcbin-singleshot-add-heartbeat-LED.patch
 create mode 100644 target/linux/mvebu/patches-5.10/300-mvebu-Mangle-bootloader-s-kernel-arguments.patch
 create mode 100644 target/linux/mvebu/patches-5.10/301-mvebu-armada-38x-enable-libata-leds.patch
 create mode 100644 target/linux/mvebu/patches-5.10/302-add_powertables.patch
 create mode 100644 target/linux/mvebu/patches-5.10/303-linksys_hardcode_nand_ecc_settings.patch
 create mode 100644 target/linux/mvebu/patches-5.10/304-revert_i2c_delay.patch
 create mode 100644 target/linux/mvebu/patches-5.10/305-armada-385-rd-mtd-partitions.patch
 create mode 100644 target/linux/mvebu/patches-5.10/306-ARM-mvebu-385-ap-Add-partitions.patch
 create mode 100644 target/linux/mvebu/patches-5.10/307-armada-xp-linksys-mamba-broken-idle.patch
 create mode 100644 target/linux/mvebu/patches-5.10/308-armada-xp-linksys-mamba-wan.patch
 create mode 100644 target/linux/mvebu/patches-5.10/309-linksys-status-led.patch
 create mode 100644 target/linux/mvebu/patches-5.10/310-linksys-use-eth0-as-cpu-port.patch
 create mode 100644 target/linux/mvebu/patches-5.10/311-adjust-compatible-for-linksys.patch
 create mode 100644 target/linux/mvebu/patches-5.10/312-ARM-dts-armada388-clearfog-emmc-on-clearfog-base.patch
 create mode 100644 target/linux/mvebu/patches-5.10/312-helios4-dts-status-led-alias.patch
 create mode 100644 target/linux/mvebu/patches-5.10/314-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
 create mode 100644 target/linux/mvebu/patches-5.10/315-arm64-dts-marvell-armada-3720-espressobin-add-ports-.patch
 create mode 100644 target/linux/mvebu/patches-5.10/316-arm64-dts-uDPU-switch-PHY-operation-mode-to-2500base.patch
 create mode 100644 target/linux/mvebu/patches-5.10/400-find_active_root.patch
 create mode 100644 target/linux/mvebu/patches-5.10/700-mvneta-tx-queue-workaround.patch
 create mode 100644 target/linux/mvebu/patches-5.10/800-cpuidle-mvebu-indicate-failure-to-enter-deeper-sleep.patch
 create mode 100644 target/linux/mvebu/patches-5.10/801-pci-mvebu-time-out-reset-on-link-up.patch

diff --git a/target/linux/mvebu/config-5.10 b/target/linux/mvebu/config-5.10
new file mode 100644
index 0000000000..beeecd138e
--- /dev/null
+++ b/target/linux/mvebu/config-5.10
@@ -0,0 +1,430 @@
+CONFIG_AHCI_MVEBU=y
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_ARCH_32BIT_OFF_T=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+CONFIG_ARCH_MULTIPLATFORM=y
+CONFIG_ARCH_MULTI_V6_V7=y
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM=y
+CONFIG_ARMADA_370_CLK=y
+CONFIG_ARMADA_370_XP_IRQ=y
+CONFIG_ARMADA_370_XP_TIMER=y
+# CONFIG_ARMADA_37XX_WATCHDOG is not set
+CONFIG_ARMADA_38X_CLK=y
+CONFIG_ARMADA_THERMAL=y
+CONFIG_ARMADA_XP_CLK=y
+CONFIG_ARM_APPENDED_DTB=y
+# CONFIG_ARM_ARMADA_37XX_CPUFREQ is not set
+# CONFIG_ARM_ARMADA_8K_CPUFREQ is not set
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+# CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER is not set
+CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARM_CRYPTO=y
+CONFIG_ARM_ERRATA_720789=y
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GLOBAL_TIMER=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_ARM_HEAVY_MB=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_MVEBU_V7_CPUIDLE=y
+CONFIG_ARM_PATCH_IDIV=y
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_UNWIND=y
+CONFIG_ARM_VIRT_EXT=y
+CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH=y
+CONFIG_ATA=y
+CONFIG_ATAGS=y
+CONFIG_ATA_LEDS=y
+CONFIG_AUTO_ZRELADDR=y
+CONFIG_BINFMT_FLAT_ARGVP_ENVP_ON_STACK=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_MQ_PCI=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BOUNCE=y
+# CONFIG_CACHE_FEROCEON_L2 is not set
+CONFIG_CACHE_L2X0=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_CLKSRC_ARM_GLOBAL_TIMER_SCHED_CLOCK=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_COMMON_CLK=y
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_CPUFREQ_DT_PLATDEV=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_PJ4B=y
+CONFIG_CPU_PM=y
+CONFIG_CPU_RMAP=y
+CONFIG_CPU_SPECTRE=y
+CONFIG_CPU_THERMAL=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_V7=y
+CONFIG_CRC16=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_AES_ARM=y
+CONFIG_CRYPTO_AES_ARM_BS=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_CRC32=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRYPTD=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_DEV_MARVELL_CESA=y
+CONFIG_CRYPTO_ESSIV=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_LIB_DES=y
+CONFIG_CRYPTO_LZO=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA1_ARM=y
+CONFIG_CRYPTO_SHA1_ARM_NEON=y
+CONFIG_CRYPTO_SHA256_ARM=y
+CONFIG_CRYPTO_SHA512_ARM=y
+CONFIG_CRYPTO_SIMD=y
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_INCLUDE="debug/8250.S"
+CONFIG_DEBUG_MVEBU_UART0=y
+# CONFIG_DEBUG_MVEBU_UART0_ALTERNATE is not set
+# CONFIG_DEBUG_MVEBU_UART1_ALTERNATE is not set
+CONFIG_DEBUG_UART_8250=y
+# CONFIG_DEBUG_UART_8250_FLOW_CONTROL is not set
+CONFIG_DEBUG_UART_8250_SHIFT=2
+# CONFIG_DEBUG_UART_8250_WORD is not set
+CONFIG_DEBUG_UART_PHYS=0xd0012000
+CONFIG_DEBUG_UART_VIRT=0xfec12000
+CONFIG_DEBUG_UNCOMPRESS=y
+CONFIG_DEBUG_USER=y
+CONFIG_DMADEVICES=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_ENGINE_RAID=y
+CONFIG_DMA_OF=y
+CONFIG_DMA_REMAP=y
+CONFIG_DTC=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_EXT4_FS=y
+CONFIG_EXTCON=y
+CONFIG_F2FS_FS=y
+CONFIG_FIXED_PHY=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_FS_IOMAP=y
+CONFIG_FS_MBCACHE=y
+CONFIG_FW_LOADER_PAGED_BUF=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_EARLY_IOREMAP=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_PHY=y
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GLOB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_IRQCHIP=y
+CONFIG_GPIO_GENERIC=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_MVEBU=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GRO_CELLS=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_HARDEN_BRANCH_PREDICTOR=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAVE_SMP=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HWBM=y
+CONFIG_HWMON=y
+CONFIG_HW_RANDOM=y
+CONFIG_HZ=100
+CONFIG_HZ_100=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_PERIODIC=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MV64XXX=y
+# CONFIG_I2C_PXA is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_IRQCHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_IRQ_WORK=y
+# CONFIG_IWMMXT is not set
+CONFIG_JBD2=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_PCA963X=y
+CONFIG_LEDS_TLC591XX=y
+CONFIG_LEDS_TRIGGER_DISK=y
+CONFIG_LIBFDT=y
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_MACH_ARMADA_370=y
+# CONFIG_MACH_ARMADA_375 is not set
+CONFIG_MACH_ARMADA_38X=y
+# CONFIG_MACH_ARMADA_39X is not set
+CONFIG_MACH_ARMADA_XP=y
+# CONFIG_MACH_DOVE is not set
+CONFIG_MACH_MVEBU_ANY=y
+CONFIG_MACH_MVEBU_V7=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MANGLE_BOOTARGS=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MDIO_BUS=y
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_I2C=y
+CONFIG_MEMFD_CREATE=y
+CONFIG_MEMORY=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_MIGRATION=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_MVSDIO=y
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_PXAV3=y
+# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_NAND_CORE=y
+CONFIG_MTD_NAND_ECC_SW_HAMMING=y
+CONFIG_MTD_NAND_MARVELL=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPLIT_FIRMWARE=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_BEB_LIMIT=20
+CONFIG_MTD_UBI_BLOCK=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_MVEBU_CLK_COMMON=y
+CONFIG_MVEBU_CLK_COREDIV=y
+CONFIG_MVEBU_CLK_CPU=y
+CONFIG_MVEBU_DEVBUS=y
+CONFIG_MVEBU_MBUS=y
+CONFIG_MVMDIO=y
+CONFIG_MVNETA=y
+CONFIG_MVNETA_BM=y
+CONFIG_MVNETA_BM_ENABLE=y
+# CONFIG_MVPP2 is not set
+CONFIG_MV_XOR=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEON=y
+CONFIG_NET_DEVLINK=y
+CONFIG_NET_DSA=y
+CONFIG_NET_DSA_MV88E6XXX=y
+CONFIG_NET_DSA_MV88E6XXX_GLOBAL2=y
+# CONFIG_NET_DSA_MV88E6XXX_PTP is not set
+CONFIG_NET_DSA_TAG_DSA=y
+CONFIG_NET_DSA_TAG_EDSA=y
+CONFIG_NET_FLOW_LIMIT=y
+CONFIG_NET_SWITCHDEV=y
+CONFIG_NLS=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_NR_CPUS=4
+CONFIG_NVMEM=y
+CONFIG_OF=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_NET=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_ORION_WATCHDOG=y
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_PADATA=y
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PAGE_POOL=y
+CONFIG_PCI=y
+CONFIG_PCI_BRIDGE_EMUL=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_DOMAINS_GENERIC=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+CONFIG_PCI_MVEBU=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_PHYLIB=y
+CONFIG_PHYLINK=y
+# CONFIG_PHY_MVEBU_A3700_COMPHY is not set
+# CONFIG_PHY_MVEBU_A3700_UTMI is not set
+CONFIG_PHY_MVEBU_A38X_COMPHY=y
+# CONFIG_PHY_MVEBU_CP110_COMPHY is not set
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_370=y
+CONFIG_PINCTRL_ARMADA_38X=y
+CONFIG_PINCTRL_ARMADA_XP=y
+CONFIG_PINCTRL_MVEBU=y
+# CONFIG_PINCTRL_SINGLE is not set
+CONFIG_PJ4B_ERRATA_4742=y
+CONFIG_PL310_ERRATA_753970=y
+CONFIG_PLAT_ORION=y
+CONFIG_PM_OPP=y
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=11
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+CONFIG_RATIONAL=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_REFCOUNT_FULL=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_RFS_ACCEL=y
+CONFIG_RPS=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_ARMADA38X=y
+CONFIG_RTC_DRV_MV=y
+CONFIG_RTC_I2C_AND_SPI=y
+CONFIG_RTC_MC146818_LIB=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_SATA_MV=y
+CONFIG_SATA_PMP=y
+CONFIG_SCSI=y
+# CONFIG_SENSORS_DRIVETEMP is not set
+CONFIG_SENSORS_PWM_FAN=y
+CONFIG_SENSORS_TMP421=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_8250_DWLIB=y
+CONFIG_SERIAL_8250_FSL=y
+CONFIG_SERIAL_MCTRL_GPIO=y
+CONFIG_SERIAL_MVEBU_CONSOLE=y
+CONFIG_SERIAL_MVEBU_UART=y
+CONFIG_SFP=y
+CONFIG_SGL_ALLOC=y
+CONFIG_SG_POOL=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_SOC_BUS=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_SPI=y
+# CONFIG_SPI_ARMADA_3700 is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+CONFIG_SPI_ORION=y
+CONFIG_SRAM=y
+CONFIG_SRAM_EXEC=y
+CONFIG_SRCU=y
+CONFIG_SWPHY=y
+CONFIG_SWP_EMULATE=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_OF=y
+CONFIG_TICK_CPU_ACCOUNTING=y
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_TREE_RCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+CONFIG_UNWINDER_ARM=y
+CONFIG_USB=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_ORION=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_LEDS_TRIGGER_USBPORT=y
+CONFIG_USB_PHY=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_MVEBU=y
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_USE_OF=y
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_XPS=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_BCJ=y
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_ZLIB_INFLATE=y
diff --git a/target/linux/mvebu/cortexa53/config-5.10 b/target/linux/mvebu/cortexa53/config-5.10
new file mode 100644
index 0000000000..79d53932d0
--- /dev/null
+++ b/target/linux/mvebu/cortexa53/config-5.10
@@ -0,0 +1,95 @@
+CONFIG_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARM64=y
+CONFIG_ARM64_4K_PAGES=y
+CONFIG_ARM64_CONT_SHIFT=4
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1286807 is not set
+CONFIG_ARM64_PAGE_SHIFT=12
+CONFIG_ARM64_PA_BITS=48
+CONFIG_ARM64_PA_BITS_48=y
+CONFIG_ARM64_PTR_AUTH=y
+CONFIG_ARM64_SSBD=y
+CONFIG_ARM64_SVE=y
+CONFIG_ARM64_TAGGED_ADDR_ABI=y
+CONFIG_ARM64_VA_BITS=39
+CONFIG_ARM64_VA_BITS_39=y
+CONFIG_ARMADA_37XX_CLK=y
+CONFIG_ARMADA_AP806_SYSCON=y
+CONFIG_ARMADA_AP_CP_HELPER=y
+CONFIG_ARMADA_CP110_SYSCON=y
+CONFIG_ARM_AMBA=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_ARMADA_37XX_CPUFREQ=y
+CONFIG_ARM_GIC_V2M=y
+CONFIG_ARM_GIC_V3=y
+CONFIG_ARM_GIC_V3_ITS=y
+CONFIG_ARM_GIC_V3_ITS_PCI=y
+# CONFIG_ARM_PL172_MPMC is not set
+# CONFIG_ARM_PSCI_CPUIDLE is not set
+CONFIG_ARM_PSCI_FW=y
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+CONFIG_CC_HAVE_STACKPROTECTOR_SYSREG=y
+# CONFIG_DEBUG_ALIGN_RODATA is not set
+CONFIG_DMA_DIRECT_REMAP=y
+CONFIG_DRM_RCAR_WRITEBACK=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_GENERIC_PINCONF=y
+CONFIG_HOLES_IN_ZONE=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_MFD_SYSCON=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_MVEBU_GICP=y
+CONFIG_MVEBU_ICU=y
+CONFIG_MVEBU_ODMI=y
+CONFIG_MVEBU_PIC=y
+CONFIG_MVEBU_SEI=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+# CONFIG_OCTEONTX2_AF is not set
+CONFIG_PARTITION_PERCPU=y
+# CONFIG_PCIE_AL is not set
+CONFIG_PCI_AARDVARK=y
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_PHY_MVEBU_A3700_COMPHY=y
+CONFIG_PHY_MVEBU_A3700_UTMI=y
+CONFIG_PINCTRL_ARMADA_37XX=y
+CONFIG_PINCTRL_ARMADA_AP806=y
+CONFIG_PINCTRL_ARMADA_CP110=y
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_LINKSTATION is not set
+CONFIG_POWER_SUPPLY=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_RODATA_FULL_DEFAULT_ENABLED=y
+CONFIG_SPARSEMEM=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPI_ARMADA_3700=y
+CONFIG_SWIOTLB=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_THREAD_INFO_IN_TASK=y
+CONFIG_UNMAP_KERNEL_AT_EL0=y
+CONFIG_VMAP_STACK=y
+CONFIG_ZONE_DMA32=y
diff --git a/target/linux/mvebu/cortexa72/config-5.10 b/target/linux/mvebu/cortexa72/config-5.10
new file mode 100644
index 0000000000..db50baf1a9
--- /dev/null
+++ b/target/linux/mvebu/cortexa72/config-5.10
@@ -0,0 +1,102 @@
+CONFIG_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARM64=y
+CONFIG_ARM64_4K_PAGES=y
+CONFIG_ARM64_CONT_SHIFT=4
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1286807 is not set
+CONFIG_ARM64_PAGE_SHIFT=12
+CONFIG_ARM64_PA_BITS=48
+CONFIG_ARM64_PA_BITS_48=y
+# CONFIG_ARM64_PTR_AUTH is not set
+CONFIG_ARM64_SSBD=y
+CONFIG_ARM64_SVE=y
+# CONFIG_ARM64_TAGGED_ADDR_ABI is not set
+CONFIG_ARM64_VA_BITS=39
+CONFIG_ARM64_VA_BITS_39=y
+CONFIG_ARMADA_37XX_CLK=y
+CONFIG_ARMADA_AP806_SYSCON=y
+CONFIG_ARMADA_AP_CP_HELPER=y
+CONFIG_ARMADA_CP110_SYSCON=y
+CONFIG_ARM_AMBA=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_GIC_V2M=y
+CONFIG_ARM_GIC_V3=y
+CONFIG_ARM_GIC_V3_ITS=y
+CONFIG_ARM_GIC_V3_ITS_PCI=y
+# CONFIG_ARM_PL172_MPMC is not set
+# CONFIG_ARM_PSCI_CPUIDLE is not set
+CONFIG_ARM_PSCI_FW=y
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+CONFIG_CC_HAVE_STACKPROTECTOR_SYSREG=y
+# CONFIG_DEBUG_ALIGN_RODATA is not set
+CONFIG_DMA_DIRECT_REMAP=y
+CONFIG_DRM_RCAR_WRITEBACK=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_GENERIC_PINCONF=y
+CONFIG_HOLES_IN_ZONE=y
+CONFIG_HW_RANDOM_OMAP=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_MARVELL_10G_PHY=y
+CONFIG_MFD_SYSCON=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_MVEBU_GICP=y
+CONFIG_MVEBU_ICU=y
+CONFIG_MVEBU_ODMI=y
+CONFIG_MVEBU_PIC=y
+CONFIG_MVEBU_SEI=y
+CONFIG_MVPP2=y
+CONFIG_MV_XOR_V2=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+# CONFIG_OCTEONTX2_AF is not set
+CONFIG_PARTITION_PERCPU=y
+CONFIG_PCIEAER=y
+CONFIG_PCIEPORTBUS=y
+# CONFIG_PCIE_AL is not set
+CONFIG_PCIE_ARMADA_8K=y
+CONFIG_PCIE_DW=y
+CONFIG_PCIE_DW_HOST=y
+# CONFIG_PCI_AARDVARK is not set
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_PHY_MVEBU_CP110_COMPHY=y
+CONFIG_PINCTRL_ARMADA_37XX=y
+CONFIG_PINCTRL_ARMADA_AP806=y
+CONFIG_PINCTRL_ARMADA_CP110=y
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_LINKSTATION is not set
+CONFIG_POWER_SUPPLY=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_RAS=y
+CONFIG_REGULATOR_GPIO=y
+# CONFIG_RODATA_FULL_DEFAULT_ENABLED is not set
+CONFIG_SPARSEMEM=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SWIOTLB=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_THREAD_INFO_IN_TASK=y
+CONFIG_UNMAP_KERNEL_AT_EL0=y
+CONFIG_VMAP_STACK=y
+CONFIG_ZONE_DMA32=y
diff --git a/target/linux/mvebu/files-5.10/arch/arm/boot/dts/armada-370-buffalo-ls421de.dts b/target/linux/mvebu/files-5.10/arch/arm/boot/dts/armada-370-buffalo-ls421de.dts
new file mode 100644
index 0000000000..57f1acf5f1
--- /dev/null
+++ b/target/linux/mvebu/files-5.10/arch/arm/boot/dts/armada-370-buffalo-ls421de.dts
@@ -0,0 +1,433 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR MIT)
+/*
+ * Device Tree file for Buffalo LinkStation LS421DE
+ *
+ * Copyright (C) 2020 Daniel González Cabanelas <dgcbueu@gmail.com>
+ */
+
+/dts-v1/;
+
+#include "armada-370.dtsi"
+#include "mvebu-linkstation-fan.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	model = "Buffalo LinkStation LS421DE";
+	compatible = "buffalo,ls421de", "marvell,armada370", "marvell,armada-370-xp";
+
+	aliases {
+		led-boot = &led_boot;
+		led-failsafe = &led_failsafe;
+		led-running = &led_power;
+		led-upgrade = &led_upgrade;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200 earlyprintk noinitrd rootfstype=squashfs";
+		stdout-path = "serial0:115200n8";
+		append-rootblock = "nullparameter="; /* override the bootloader args */
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x00000000 0x20000000>; /* 512 MB */
+	};
+
+	soc {
+		ranges = <MBUS_ID(0xf0, 0x01) 0 0xd0000000 0x100000
+			  MBUS_ID(0x01, 0xe0) 0 0xfff00000 0x100000
+			  MBUS_ID(0x09, 0x01) 0 0xf1100000 0x10000>;
+	};
+
+	system_fan: gpio_fan {
+		gpios = <&gpio0 13 GPIO_ACTIVE_HIGH
+			 &gpio0 14 GPIO_ACTIVE_HIGH>;
+		alarm-gpios = <&gpio0 10 GPIO_ACTIVE_HIGH>;
+
+		#cooling-cells = <2>;
+	};
+
+	thermal-zones {
+		hdd-thermal {
+			polling-delay = <20000>;
+			polling-delay-passive = <2000>;
+
+			thermal-sensors = <&hdd0_temp>; /* only one drivetemp sensor is supported */
+
+			trips {
+				hdd_alert1: trip1 {
+					temperature = <36000>;
+					hysteresis = <2000>;
+					type = "active";
+				};
+				hdd_alert2: trip2 {
+					temperature = <44000>;
+					hysteresis = <2000>;
+					type = "active";
+				};
+				hdd_alert3: trip3 {
+					temperature = <52000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				hdd_crit: trip4 {
+					temperature = <60000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map1 {
+					trip = <&hdd_alert1>;
+					cooling-device = <&system_fan THERMAL_NO_LIMIT 1>;
+				};
+				map2 {
+					trip = <&hdd_alert2>;
+					cooling-device = <&system_fan 2 2>;
+				};
+				map3 {
+					trip = <&hdd_alert3>;
+					cooling-device = <&system_fan 3 THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+
+		ethphy-thermal {
+			polling-delay = <20000>;
+			polling-delay-passive = <2000>;
+
+			thermal-sensors = <&ethphy0>;
+
+			trips {
+				ethphy_alert1: trip1 {
+					temperature = <65000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+
+				ethphy_crit: trip2 {
+					temperature = <100000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map1 {
+					trip = <&ethphy_alert1>;
+					cooling-device = <&system_fan THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+
+			};
+		};
+	};
+
+	gpio_keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&pmx_buttons>;
+		pinctrl-names = "default";
+
+		power {
+			label = "Power Switch";
+			linux,code = <KEY_POWER>;
+			linux,input-type = <EV_SW>;
+			gpios = <&gpio0 15 GPIO_ACTIVE_LOW>;
+		};
+
+		function {
+			label = "Function Button";
+			linux,code = <KEY_CONFIG>;
+			gpios = <&gpio0 16 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	gpio_leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pmx_leds1 &pmx_leds2>;
+
+		system_red {
+			label = "ls421de:red:system";
+			gpios = <&gpio0 7 GPIO_ACTIVE_HIGH>;
+		};
+
+		led_power: power_white {
+			label = "ls421de:white:power";
+			gpios = <&gpio1 22 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+		};
+
+		led_failsafe: power_red {
+			label = "ls421de:red:power";
+			gpios = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+		};
+
+		led_upgrade: power_orange {
+			label = "ls421de:orange:power";
+			gpios = <&gpio1 25 GPIO_ACTIVE_HIGH>;
+		};
+
+		led_boot: system_white {
+			label = "ls421de:white:system";
+			gpios = <&gpio1 27 GPIO_ACTIVE_HIGH>;
+		};
+
+		hdd1_red {
+			label = "ls421de:red:hdd1";
+			gpios = <&gpio1 29 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "ata1";
+		};
+
+		hdd2_red {
+			label = "ls421de:red:hdd2";
+			gpios = <&gpio1 30 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "ata2";
+		};
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&pmx_power_usb &pmx_power_hdd1 &pmx_power_hdd2>;
+		pinctrl-names = "default";
+
+		usb_power: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "USB";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			enable-active-high;
+			regulator-always-on;
+			regulator-boot-on;
+			gpio = <&gpio0 5 GPIO_ACTIVE_HIGH>;
+		};
+
+		sata1_power: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "HDD1";
+			regulator-min-microvolt = <12000000>;
+			regulator-max-microvolt = <12000000>;
+			startup-delay-us = <2000000>;
+			enable-active-high;
+			regulator-always-on;
+			regulator-boot-on;
+			gpio = <&gpio0 8 GPIO_ACTIVE_HIGH>;
+		};
+
+		sata2_power: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			regulator-name = "HDD2";
+			regulator-min-microvolt = <12000000>;
+			regulator-max-microvolt = <12000000>;
+			startup-delay-us = <4000000>;
+			enable-active-high;
+			regulator-always-on;
+			regulator-boot-on;
+			gpio = <&gpio0 9 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&coherencyfab {
+	broken-idle;
+};
+
+&eth1 {
+	pinctrl-0 = <&ge1_rgmii_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+	phy-handle = <&ethphy0>;
+	phy-connection-type = "rgmii-id";
+};
+
+&i2c0 {
+	pinctrl-0 = <&i2c0_pins>;
+	pinctrl-names = "default";
+	clock-frequency = <100000>;
+	status = "okay";
+
+	rs5c372a: rs5c372a@32 {
+		compatible = "ricoh,rs5c372a";
+		reg = <0x32>;
+		wakeup-source;
+	};
+};
+
+&mdio {
+	pinctrl-0 = <&mdio_pins>;
+	pinctrl-names = "default";
+
+	ethphy0: ethernet-phy@0 { /* Marvell 88E1518 */
+		reg = <0>;
+		marvell,reg-init = <0x3 0x10 0x1 0x1991>, /* LED function */
+				   <0x3 0x11 0x1 0x4401>, /* LED polarity */
+				   <0x3 0x12 0x1 0x4905>; /* LED timer */
+		#thermal-sensor-cells = <0>;
+	};
+};
+
+&pciec {
+	status = "okay";
+	/* Connected to uPD720202 USB 3.0 Host */
+	pcie@1,0 {
+		status = "okay";
+	};
+};
+
+&pmsu {
+	pinctrl-0 = <&pmx_power_cpu>;
+	pinctrl-names = "default";
+};
+
+&rtc {
+	status = "disabled";
+};
+
+&sata {
+	nr-ports = <2>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	hdd0_temp: sata-port@0 {
+		reg = <0>;
+		#thermal-sensor-cells = <0>;
+	};
+
+	hdd1_temp: sata-port@1 {
+		reg = <1>;
+		#thermal-sensor-cells = <0>;
+	};
+};
+
+&sdio {
+	pinctrl-0 = <&sdio_pins2>;
+	pinctrl-names = "default";
+	status = "okay";
+	/* No CD or WP GPIOs */
+	broken-cd;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+};
+
+&nand_controller {
+	status = "okay";
+
+	nand@0 {
+		reg = <0>;
+		label = "pxa3xx_nand-0";
+		nand-rb = <0>;
+		marvell,nand-keep-config;
+		nand-on-flash-bbt;
+		nand-ecc-strength = <4>;
+		nand-ecc-step-size = <512>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "kernel";
+				reg = <0x00000000 0x02000000>;  /* 32 MiB */
+			};
+
+			partition@2000000 {
+				label = "ubi";
+				reg = <0x02000000 0x1e000000>;  /* 480 MiB */
+			};
+		};
+	};
+};
+
+&spi0 {
+	status = "okay";
+	pinctrl-0 = <&spi0_pins2>;
+	pinctrl-names = "default";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "mxicy,mx25l8005", "jedec,spi-nor";
+		reg = <0>; /* Chip select 0 */
+		spi-max-frequency = <50000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				reg = <0x00000 0xf0000>; /* 960 KiB*/
+				label = "u-boot";
+				read-only;
+			};
+			partition@f0000 {
+				reg = <0xf0000 0x10000>; /* 64 KiB */
+				label = "u-boot-env";
+			};
+		};
+	};
+};
+
+&pinctrl {
+	pmx_power_cpu: pmx-power-cpu {
+		marvell,pins = "mpp4";
+		marvell,function = "vdd";
+	};
+	pmx_power_usb: pmx-power-usb {
+		marvell,pins = "mpp5";
+		marvell,function = "gpo";
+	};
+	pmx_power_hdd1: pmx-power-hdd1 {
+		marvell,pins = "mpp8";
+		marvell,function = "gpio";
+	};
+	pmx_power_hdd2: pmx-power-hdd2 {
+		marvell,pins = "mpp9";
+		marvell,function = "gpo";
+	};
+	pmx_fan_lock: pmx-fan-lock {
+		marvell,pins = "mpp10";
+		marvell,function = "gpio";
+	};
+	pmx_hdd_present: pmx-hdd-present {
+		marvell,pins = "mpp11", "mpp12";
+		marvell,function = "gpio";
+	};
+	pmx_fan_high: pmx-fan-high {
+		marvell,pins = "mpp13";
+		marvell,function = "gpio";
+	};
+	pmx_fan_low: pmx-fan-low {
+		marvell,pins = "mpp14";
+		marvell,function = "gpio";
+	};
+	pmx_buttons: pmx-buttons {
+		marvell,pins = "mpp15", "mpp16";
+		marvell,function = "gpio";
+	};
+	pmx_leds1: pmx-leds {
+		marvell,pins = "mpp7", "mpp54", "mpp59", "mpp61";
+		marvell,function = "gpo";
+	};
+	pmx_leds2: pmx-leds {
+		marvell,pins = "mpp55", "mpp57", "mpp62";
+		marvell,function = "gpio";
+	};
+};
diff --git a/target/linux/mvebu/files-5.10/arch/arm/boot/dts/armada-385-linksys-venom.dts b/target/linux/mvebu/files-5.10/arch/arm/boot/dts/armada-385-linksys-venom.dts
new file mode 100644
index 0000000000..de81600a80
--- /dev/null
+++ b/target/linux/mvebu/files-5.10/arch/arm/boot/dts/armada-385-linksys-venom.dts
@@ -0,0 +1,213 @@
+/*
+ * Device Tree file for the Linksys WRT32X (Venom)
+ *
+ * Copyright (C) 2017 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is licensed under the terms of the GNU General Public
+ *     License version 2.  This program is licensed "as is" without
+ *     any warranty of any kind, whether express or implied.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include "armada-385-linksys.dtsi"
+
+/ {
+	model = "Linksys WRT32X";
+	compatible = "linksys,wrt32x", "linksys,venom", "linksys,armada385",
+		     "marvell,armada385", "marvell,armada380";
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+		stdout-path = "serial0:115200n8";
+		append-rootblock = "root=/dev/mtdblock";
+	};
+};
+
+&expander0 {
+	wan_amber@0 {
+		label = "venom:amber:wan";
+		reg = <0x0>;
+	};
+
+	wan_blue@1 {
+		label = "venom:blue:wan";
+		reg = <0x1>;
+	};
+
+	usb2@5 {
+		label = "venom:blue:usb2";
+		reg = <0x5>;
+	};
+
+	usb3_1@6 {
+		label = "venom:blue:usb3_1";
+		reg = <0x6>;
+	};
+
+	usb3_2@7 {
+		label = "venom:blue:usb3_2";
+		reg = <0x7>;
+	};
+
+	wps_blue@8 {
+		label = "venom:blue:wps";
+		reg = <0x8>;
+	};
+
+	wps_amber@9 {
+		label = "venom:amber:wps";
+		reg = <0x9>;
+	};
+};
+
+&gpio_leds {
+	power {
+		gpios = <&gpio1 24 GPIO_ACTIVE_HIGH>;
+		label = "venom:blue:power";
+	};
+
+	sata {
+		gpios = <&gpio1 21 GPIO_ACTIVE_LOW>;
+		label = "venom:blue:sata";
+	};
+
+	wlan_2g {
+		gpios = <&gpio1 13 GPIO_ACTIVE_LOW>;
+		label = "venom:blue:wlan_2g";
+	};
+
+	wlan_5g {
+		gpios = <&gpio1 14 GPIO_ACTIVE_LOW>;
+		label = "venom:blue:wlan_5g";
+	};
+};
+
+&gpio_leds_pins {
+	marvell,pins = "mpp21", "mpp45", "mpp46", "mpp56";
+};
+
+&nand {
+	/* Spansion S34ML02G2 256MiB, OEM Layout */
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "u-boot";
+			reg = <0x0000000 0x200000>;	/* 2MB */
+			read-only;
+		};
+
+		partition@200000 {
+			label = "u_env";
+			reg = <0x200000 0x20000>;	/* 128KB */
+		};
+
+		partition@220000 {
+			label = "s_env";
+			reg = <0x220000 0x40000>;	/* 256KB */
+		};
+
+		partition@180000 {
+			label = "unused_area";
+			reg = <0x260000 0x5c0000>;	/* 5.75MB */
+		};
+
+		partition@7e0000 {
+			label = "devinfo";
+			reg = <0x7e0000 0x40000>;	/* 256KB */
+			read-only;
+		};
+
+		/* kernel1 overlaps with rootfs1 by design */
+		partition@900000 {
+			label = "kernel1";
+			reg = <0x900000 0x7b00000>;	/* 123MB */
+		};
+
+		partition@c00000 {
+			label = "rootfs1";
+			reg = <0xc00000 0x7800000>;	/* 120MB */
+		};
+
+		/* kernel2 overlaps with rootfs2 by design */
+		partition@8400000 {
+			label = "kernel2";
+			reg = <0x8400000 0x7b00000>;	/* 123MB */
+		};
+
+		partition@8700000 {
+			label = "rootfs2";
+			reg = <0x8700000 0x7800000>;	/* 120MB */
+		};
+
+		/* last MB is for the BBT, not writable */
+		partition@ff00000 {
+			label = "BBT";
+			reg = <0xff00000 0x100000>;
+		};
+	};
+};
+
+
+&pcie1 {
+	mwlwifi {
+		marvell,chainmask = <4 4>;
+	};
+};
+
+&pcie2 {
+	mwlwifi {
+		marvell,chainmask = <4 4>;
+	};
+};
+
+&sdhci {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdhci_pins>;
+	no-1-8-v;
+	non-removable;
+	wp-inverted;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&usb3_1_vbus {
+	gpio = <&gpio1 12 GPIO_ACTIVE_HIGH>;
+};
+
+&usb3_1_vbus_pins {
+	marvell,pins = "mpp44";
+};
diff --git a/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-emmc.dts b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-emmc.dts
new file mode 100644
index 0000000000..e3bed4d445
--- /dev/null
+++ b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-emmc.dts
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR MIT)
+/*
+ * Device Tree file for Globalscale Marvell ESPRESSOBin Board with eMMC
+ * Copyright (C) 2018 Marvell
+ *
+ * Romain Perier <romain.perier@free-electrons.com>
+ * Konstantin Porotchkin <kostap@marvell.com>
+ *
+ */
+
+#include "armada-3720-espressobin.dts"
+
+/ {
+	model = "Globalscale Marvell ESPRESSOBin Board (eMMC)";
+	compatible = "globalscale,espressobin-emmc", "globalscale,espressobin",
+		     "marvell,armada3720", "marvell,armada3710";
+};
+
+&sdhci0 {
+	status = "okay";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	mmccard: mmccard@0 {
+		compatible = "mmc-card";
+		reg = <0>;
+	};
+};
diff --git a/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-ultra.dts b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-ultra.dts
new file mode 100644
index 0000000000..669b67e5a9
--- /dev/null
+++ b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-ultra.dts
@@ -0,0 +1,241 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Device Tree file for ESPRESSObin-Ultra
+ * Copyright (C) 2019 Globalscale technologies, Inc.
+ *
+ * Jason Hung <jhung@globalscaletechnologies.com>
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include "armada-372x.dtsi"
+
+/ {
+	model = "Globalscale Marvell ESPRESSOBin Ultra Board";
+	compatible = "globalscale,espressobin-ultra", "marvell,armada3720",
+		     "marvell,armada3710";
+
+	aliases {
+		/* for dsa slave device */
+		ethernet1 = &switch0port1;
+		ethernet2 = &switch0port2;
+		ethernet3 = &switch0port3;
+		ethernet4 = &switch0port4;
+		ethernet5 = &switch0port5;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
+	};
+
+	reg_usb3_vbus: usb3-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb3-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpionb 19 GPIO_ACTIVE_HIGH>;
+	};
+
+	usb3_phy: usb3-phy {
+		compatible = "usb-nop-xceiv";
+		vcc-supply = <&reg_usb3_vbus>;
+	};
+
+	leds {
+		pinctrl-names = "default";
+		compatible = "gpio-leds";
+		/* No assigned functions to the LEDs by default */
+		led1 {
+			label = "ebin-ultra:blue:led1";
+			gpios = <&gpionb 11 GPIO_ACTIVE_LOW>;
+		};
+		led2 {
+			label = "ebin-ultra:green:led2";
+			gpios = <&gpionb 12 GPIO_ACTIVE_LOW>;
+		};
+		led3 {
+			label = "ebin-ultra:red:led3";
+			gpios = <&gpionb 13 GPIO_ACTIVE_LOW>;
+		};
+		led4 {
+			label = "ebin-ultra:yellow:led4";
+			gpios = <&gpionb 14 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
+
+&sdhci0 {
+	status = "okay";
+	non-removable;
+	bus-width = <8>;
+	mmc-ddr-1_8v;
+	mmc-hs400-1_8v;
+	marvell,pad-type = "fixed-1-8v";
+};
+
+&spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi_quad_pins>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+		spi-rx-bus-width = <4>;
+		spi-tx-bus-width = <4>;
+		m25p,fast-read;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "firmware";
+				reg = <0x0 0x3e0000>;
+			};
+			partition@3e0000 {
+				label = "hw-info";
+				reg = <0x3e0000 0x10000>;
+				read-only;
+			};
+			partition@3f0000 {
+				label = "u-boot-env";
+				reg = <0x3f0000 0x10000>;
+			};
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins>;
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pins>;
+
+	clock-frequency = <100000>;
+
+	rtc@51 {
+		compatible = "nxp,pcf8563";
+		reg = <0x51>;
+	};
+};
+
+&usb3 {
+	status = "okay";
+	usb-phy = <&usb3_phy>;
+};
+
+&usb2 {
+	status = "okay";
+};
+
+&eth0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&rgmii_pins>;
+	phy-mode = "rgmii-id";
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&mdio {
+	status = "okay";
+
+	extphy: ethernet-phy@0 {
+		reg = <1>;
+	};
+
+	switch0: switch0@1 {
+		compatible = "marvell,mv88e6085";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <3>;
+
+		dsa,member = <0 0>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			switch0port0: port@0 {
+				reg = <0>;
+				label = "cpu";
+				ethernet = <&eth0>;
+			};
+
+			switch0port1: port@1 {
+				reg = <1>;
+				label = "lan0";
+				phy-handle = <&switch0phy1>;
+			};
+
+			switch0port2: port@2 {
+				reg = <2>;
+				label = "lan1";
+				phy-handle = <&switch0phy2>;
+			};
+
+			switch0port3: port@3 {
+				reg = <3>;
+				label = "lan2";
+				phy-handle = <&switch0phy3>;
+			};
+
+			switch0port4: port@4 {
+				reg = <4>;
+				label = "lan3";
+				phy-handle = <&switch0phy4>;
+			};
+
+			switch0port5: port@5 {
+				reg = <5>;
+				label = "wan";
+				phy-handle = <&extphy>;
+				phy-mode = "sgmii";
+			};
+		};
+
+		mdio {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			switch0phy1: switch0phy1@11 {
+				reg = <0x11>;
+			};
+			switch0phy2: switch0phy2@12 {
+				reg = <0x12>;
+			};
+			switch0phy3: switch0phy3@13 {
+				reg = <0x13>;
+			};
+			switch0phy4: switch0phy4@14 {
+				reg = <0x14>;
+			};
+		};
+	};
+};
diff --git a/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7-emmc.dts b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7-emmc.dts
new file mode 100644
index 0000000000..e1e0071434
--- /dev/null
+++ b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7-emmc.dts
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR MIT)
+/*
+ * Device Tree file for Globalscale Marvell ESPRESSOBin Board V7 with eMMC
+ * Copyright (C) 2018 Marvell
+ *
+ * Romain Perier <romain.perier@free-electrons.com>
+ * Konstantin Porotchkin <kostap@marvell.com>
+ *
+ */
+
+#include "armada-3720-espressobin.dts"
+
+/ {
+	model = "Globalscale Marvell ESPRESSOBin Board V7 (eMMC)";
+	compatible = "globalscale,espressobin-v7-emmc", "globalscale,espressobin-v7",
+		     "globalscale,espressobin", "marvell,armada3720",
+		     "marvell,armada3710";
+};
+
+&ports {
+	port@1 {
+		reg = <1>;
+		label = "lan1";
+		phy-handle = <&switch0phy0>;
+	};
+
+	port@3 {
+		reg = <3>;
+		label = "wan";
+		phy-handle = <&switch0phy2>;
+	};
+};
+
+&sdhci0 {
+	status = "okay";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	mmccard: mmccard@0 {
+		compatible = "mmc-card";
+		reg = <0>;
+	};
+};
diff --git a/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7.dts b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7.dts
new file mode 100644
index 0000000000..40f18409bf
--- /dev/null
+++ b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7.dts
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR MIT)
+/*
+ * Device Tree file for Globalscale Marvell ESPRESSOBin Board V7
+ * Copyright (C) 2018 Marvell
+ *
+ * Romain Perier <romain.perier@free-electrons.com>
+ * Konstantin Porotchkin <kostap@marvell.com>
+ *
+ */
+
+#include "armada-3720-espressobin.dts"
+
+/ {
+	model = "Globalscale Marvell ESPRESSOBin Board V7";
+	compatible = "globalscale,espressobin-v7", "globalscale,espressobin",
+		     "marvell,armada3720", "marvell,armada3710";
+};
+
+&ports {
+	port@1 {
+		reg = <1>;
+		label = "lan1";
+		phy-handle = <&switch0phy0>;
+	};
+
+	port@3 {
+		reg = <3>;
+		label = "wan";
+		phy-handle = <&switch0phy2>;
+	};
+};
diff --git a/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-gl-mv1000.dts b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-gl-mv1000.dts
new file mode 100644
index 0000000000..86c33fa100
--- /dev/null
+++ b/target/linux/mvebu/files-5.10/arch/arm64/boot/dts/marvell/armada-3720-gl-mv1000.dts
@@ -0,0 +1,162 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR MIT)
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include "armada-372x.dtsi"
+
+/ {
+	model = "GL.iNet GL-MV1000";
+	compatible = "glinet,gl-mv1000", "marvell,armada3720";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
+	};
+
+	vcc_sd_reg1: regulator {
+		compatible = "regulator-gpio";
+		regulator-name = "vcc_sd1";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+        
+		gpios-states = <0>;
+		states = <1800000 0x1
+			3300000 0x0>;
+		enable-active-high;
+	};
+};
+
+&spi0 {
+	status = "okay";
+
+	flash@0 {
+		reg = <0>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <104000000>;
+		m25p,fast-read;
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0 0xf0000>;
+			};
+
+			partition@f0000 {
+				label = "u-boot-env";
+				reg = <0Xf0000 0x8000>;
+			};
+
+			factory: partition@f8000 {
+				label = "factory";
+				reg = <0xf8000 0x8000>;
+			};
+		};
+	};
+};
+
+&sdhci1 {
+	wp-inverted;
+	bus-width = <4>;
+	cd-gpios = <&gpionb 17 GPIO_ACTIVE_LOW>;
+	marvell,pad-type = "sd";
+	no-1-8-v;
+	vqmmc-supply = <&vcc_sd_reg1>;
+	status = "okay";
+};
+
+&sdhci0 {
+	bus-width = <8>;
+	mmc-ddr-1_8v;
+	mmc-hs400-1_8v;
+	non-removable;
+	no-sd;
+	no-sdio;
+	marvell,pad-type = "fixed-1-8v";
+	status = "okay";
+};
+
+&usb3 {
+	status = "okay";
+};
+
+&usb2 {
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&mdio {
+	switch0: switch0@1 {
+		compatible = "marvell,mv88e6085";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <1>;
+
+		dsa,member = <0 0>;
+
+		ports: ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				label = "cpu";
+				ethernet = <&eth0>;
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "wan";
+				phy-handle = <&switch0phy0>;
+			};
+
+			port@2 {
+				reg = <2>;
+				label = "lan0";
+				phy-handle = <&switch0phy1>;
+			};
+
+			port@3 {
+				reg = <3>;
+				label = "lan1";
+				phy-handle = <&switch0phy2>;
+			};
+		};
+
+		mdio {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			switch0phy0: switch0phy0@11 {
+				reg = <0x11>;
+			};
+			switch0phy1: switch0phy1@12 {
+				reg = <0x12>;
+			};
+			switch0phy2: switch0phy2@13 {
+				reg = <0x13>;
+			};
+		};
+	};
+};
+
+&eth0 {
+	mtd-mac-address = <&factory 0x0>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
diff --git a/target/linux/mvebu/patches-5.10/001-PCI-aardvark-Wait-for-endpoint-to-be-ready-before-tr.patch b/target/linux/mvebu/patches-5.10/001-PCI-aardvark-Wait-for-endpoint-to-be-ready-before-tr.patch
new file mode 100644
index 0000000000..95abbce002
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/001-PCI-aardvark-Wait-for-endpoint-to-be-ready-before-tr.patch
@@ -0,0 +1,50 @@
+From f4c7d053d7f77cd5c1a1ba7c7ce085ddba13d1d7 Mon Sep 17 00:00:00 2001
+From: Remi Pommarel <repk@triplefau.lt>
+Date: Wed, 22 May 2019 23:33:50 +0200
+Subject: [PATCH] PCI: aardvark: Wait for endpoint to be ready before training
+ link
+
+When configuring pcie reset pin from gpio (e.g. initially set by
+u-boot) to pcie function this pin goes low for a brief moment
+asserting the PERST# signal. Thus connected device enters fundamental
+reset process and link configuration can only begin after a minimal
+100ms delay (see [1]).
+
+Because the pin configuration comes from the "default" pinctrl it is
+implicitly configured before the probe callback is called:
+
+driver_probe_device()
+  really_probe()
+    ...
+    pinctrl_bind_pins() /* Here pin goes from gpio to PCIE reset
+                           function and PERST# is asserted */
+    ...
+    drv->probe()
+
+[1] "PCI Express Base Specification", REV. 4.0
+    PCI Express, February 19 2014, 6.6.1 Conventional Reset
+
+Signed-off-by: Remi Pommarel <repk@triplefau.lt>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -337,6 +337,14 @@ static void advk_pcie_setup_hw(struct ad
+ 	reg |= PIO_CTRL_ADDR_WIN_DISABLE;
+ 	advk_writel(pcie, reg, PIO_CTRL);
+ 
++	/*
++	 * PERST# signal could have been asserted by pinctrl subsystem before
++	 * probe() callback has been called, making the endpoint going into
++	 * fundamental reset. As required by PCI Express spec a delay for at
++	 * least 100ms after such a reset before link training is needed.
++	 */
++	msleep(PCI_PM_D3COLD_WAIT);
++
+ 	/* Start link training */
+ 	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
+ 	reg |= PCIE_CORE_LINK_TRAINING;
diff --git a/target/linux/mvebu/patches-5.10/002-PCI-aardvark-Don-t-rely-on-jiffies-while-holding-spi.patch b/target/linux/mvebu/patches-5.10/002-PCI-aardvark-Don-t-rely-on-jiffies-while-holding-spi.patch
new file mode 100644
index 0000000000..db4afd22a2
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/002-PCI-aardvark-Don-t-rely-on-jiffies-while-holding-spi.patch
@@ -0,0 +1,54 @@
+From 7fbcb5da811be7d47468417c7795405058abb3da Mon Sep 17 00:00:00 2001
+From: Remi Pommarel <repk@triplefau.lt>
+Date: Fri, 27 Sep 2019 10:55:02 +0200
+Subject: [PATCH] PCI: aardvark: Don't rely on jiffies while holding spinlock
+
+advk_pcie_wait_pio() can be called while holding a spinlock (from
+pci_bus_read_config_dword()), then depends on jiffies in order to
+timeout while polling on PIO state registers. In the case the PIO
+transaction failed, the timeout will never happen and will also cause
+the cpu to stall.
+
+This decrements a variable and wait instead of using jiffies.
+
+Signed-off-by: Remi Pommarel <repk@triplefau.lt>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Reviewed-by: Andrew Murray <andrew.murray@arm.com>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -175,7 +175,8 @@
+ 	(PCIE_CONF_BUS(bus) | PCIE_CONF_DEV(PCI_SLOT(devfn))	| \
+ 	 PCIE_CONF_FUNC(PCI_FUNC(devfn)) | PCIE_CONF_REG(where))
+ 
+-#define PIO_TIMEOUT_MS			1
++#define PIO_RETRY_CNT			500
++#define PIO_RETRY_DELAY			2 /* 2 us*/
+ 
+ #define LINK_WAIT_MAX_RETRIES		10
+ #define LINK_WAIT_USLEEP_MIN		90000
+@@ -400,17 +401,16 @@ static void advk_pcie_check_pio_status(s
+ static int advk_pcie_wait_pio(struct advk_pcie *pcie)
+ {
+ 	struct device *dev = &pcie->pdev->dev;
+-	unsigned long timeout;
++	int i;
+ 
+-	timeout = jiffies + msecs_to_jiffies(PIO_TIMEOUT_MS);
+-
+-	while (time_before(jiffies, timeout)) {
++	for (i = 0; i < PIO_RETRY_CNT; i++) {
+ 		u32 start, isr;
+ 
+ 		start = advk_readl(pcie, PIO_START);
+ 		isr = advk_readl(pcie, PIO_ISR);
+ 		if (!start && isr)
+ 			return 0;
++		udelay(PIO_RETRY_DELAY);
+ 	}
+ 
+ 	dev_err(dev, "config read/write timed out\n");
diff --git a/target/linux/mvebu/patches-5.10/003-net-mvneta-introduce-mvneta_update_stats-routine.patch b/target/linux/mvebu/patches-5.10/003-net-mvneta-introduce-mvneta_update_stats-routine.patch
new file mode 100644
index 0000000000..f6ce6163cf
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/003-net-mvneta-introduce-mvneta_update_stats-routine.patch
@@ -0,0 +1,95 @@
+From ff519e2acd463bff6c5bb4e8d7ed350c9bae885b Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Sat, 19 Oct 2019 10:13:21 +0200
+Subject: [PATCH 1/7] net: mvneta: introduce mvneta_update_stats routine
+
+Introduce mvneta_update_stats routine to collect {rx/tx} statistics
+(packets and bytes). This is a preliminary patch to add XDP support to
+mvneta driver
+
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 43 ++++++++++++++-------------
+ 1 file changed, 22 insertions(+), 21 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -1913,6 +1913,23 @@ static void mvneta_rxq_drop_pkts(struct
+ 	}
+ }
+ 
++static void
++mvneta_update_stats(struct mvneta_port *pp, u32 pkts,
++		    u32 len, bool tx)
++{
++	struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
++
++	u64_stats_update_begin(&stats->syncp);
++	if (tx) {
++		stats->tx_packets += pkts;
++		stats->tx_bytes += len;
++	} else {
++		stats->rx_packets += pkts;
++		stats->rx_bytes += len;
++	}
++	u64_stats_update_end(&stats->syncp);
++}
++
+ static inline
+ int mvneta_rx_refill_queue(struct mvneta_port *pp, struct mvneta_rx_queue *rxq)
+ {
+@@ -2093,14 +2110,8 @@ static int mvneta_rx_swbm(struct napi_st
+ 		rxq->left_size = 0;
+ 	}
+ 
+-	if (rcvd_pkts) {
+-		struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
+-
+-		u64_stats_update_begin(&stats->syncp);
+-		stats->rx_packets += rcvd_pkts;
+-		stats->rx_bytes   += rcvd_bytes;
+-		u64_stats_update_end(&stats->syncp);
+-	}
++	if (rcvd_pkts)
++		mvneta_update_stats(pp, rcvd_pkts, rcvd_bytes, false);
+ 
+ 	/* return some buffers to hardware queue, one at a time is too slow */
+ 	refill = mvneta_rx_refill_queue(pp, rxq);
+@@ -2223,14 +2234,8 @@ err_drop_frame:
+ 		napi_gro_receive(napi, skb);
+ 	}
+ 
+-	if (rcvd_pkts) {
+-		struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
+-
+-		u64_stats_update_begin(&stats->syncp);
+-		stats->rx_packets += rcvd_pkts;
+-		stats->rx_bytes   += rcvd_bytes;
+-		u64_stats_update_end(&stats->syncp);
+-	}
++	if (rcvd_pkts)
++		mvneta_update_stats(pp, rcvd_pkts, rcvd_bytes, false);
+ 
+ 	/* Update rxq management counters */
+ 	mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_done);
+@@ -2476,7 +2481,6 @@ static netdev_tx_t mvneta_tx(struct sk_b
+ 
+ out:
+ 	if (frags > 0) {
+-		struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
+ 		struct netdev_queue *nq = netdev_get_tx_queue(dev, txq_id);
+ 
+ 		netdev_tx_sent_queue(nq, len);
+@@ -2491,10 +2495,7 @@ out:
+ 		else
+ 			txq->pending += frags;
+ 
+-		u64_stats_update_begin(&stats->syncp);
+-		stats->tx_packets++;
+-		stats->tx_bytes  += len;
+-		u64_stats_update_end(&stats->syncp);
++		mvneta_update_stats(pp, 1, len, true);
+ 	} else {
+ 		dev->stats.tx_dropped++;
+ 		dev_kfree_skb_any(skb);
diff --git a/target/linux/mvebu/patches-5.10/004-net-mvneta-introduce-page-pool-API-for-sw-buffer-man.patch b/target/linux/mvebu/patches-5.10/004-net-mvneta-introduce-page-pool-API-for-sw-buffer-man.patch
new file mode 100644
index 0000000000..fbcae20f74
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/004-net-mvneta-introduce-page-pool-API-for-sw-buffer-man.patch
@@ -0,0 +1,181 @@
+From 568a3fa24a95476d40afe3f8616bafb543bc4182 Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Sat, 19 Oct 2019 10:13:22 +0200
+Subject: [PATCH 2/7] net: mvneta: introduce page pool API for sw buffer
+ manager
+
+Use the page_pool api for allocations and DMA handling instead of
+__dev_alloc_page()/dma_map_page() and free_page()/dma_unmap_page().
+Pages are unmapped using page_pool_release_page before packets
+go into the network stack.
+
+The page_pool API offers buffer recycling capabilities for XDP but
+allocates one page per packet, unless the driver splits and manages
+the allocated page.
+This is a preliminary patch to add XDP support to mvneta driver
+
+Signed-off-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
+Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/Kconfig  |  1 +
+ drivers/net/ethernet/marvell/mvneta.c | 83 +++++++++++++++++++++------
+ 2 files changed, 65 insertions(+), 19 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/Kconfig
++++ b/drivers/net/ethernet/marvell/Kconfig
+@@ -61,6 +61,7 @@ config MVNETA
+ 	depends on ARCH_MVEBU || COMPILE_TEST
+ 	select MVMDIO
+ 	select PHYLINK
++	select PAGE_POOL
+ 	---help---
+ 	  This driver supports the network interface units in the
+ 	  Marvell ARMADA XP, ARMADA 370, ARMADA 38x and
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -37,6 +37,7 @@
+ #include <net/ip.h>
+ #include <net/ipv6.h>
+ #include <net/tso.h>
++#include <net/page_pool.h>
+ 
+ /* Registers */
+ #define MVNETA_RXQ_CONFIG_REG(q)                (0x1400 + ((q) << 2))
+@@ -607,6 +608,10 @@ struct mvneta_rx_queue {
+ 	u32 pkts_coal;
+ 	u32 time_coal;
+ 
++	/* page_pool */
++	struct page_pool *page_pool;
++	struct xdp_rxq_info xdp_rxq;
++
+ 	/* Virtual address of the RX buffer */
+ 	void  **buf_virt_addr;
+ 
+@@ -1825,23 +1830,21 @@ static int mvneta_rx_refill(struct mvnet
+ 			    struct mvneta_rx_queue *rxq,
+ 			    gfp_t gfp_mask)
+ {
++	enum dma_data_direction dma_dir;
+ 	dma_addr_t phys_addr;
+ 	struct page *page;
+ 
+-	page = __dev_alloc_page(gfp_mask);
++	page = page_pool_alloc_pages(rxq->page_pool,
++				     gfp_mask | __GFP_NOWARN);
+ 	if (!page)
+ 		return -ENOMEM;
+ 
+-	/* map page for use */
+-	phys_addr = dma_map_page(pp->dev->dev.parent, page, 0, PAGE_SIZE,
+-				 DMA_FROM_DEVICE);
+-	if (unlikely(dma_mapping_error(pp->dev->dev.parent, phys_addr))) {
+-		__free_page(page);
+-		return -ENOMEM;
+-	}
+-
+-	phys_addr += pp->rx_offset_correction;
++	phys_addr = page_pool_get_dma_addr(page) + pp->rx_offset_correction;
++	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
++	dma_sync_single_for_device(pp->dev->dev.parent, phys_addr,
++				   PAGE_SIZE, dma_dir);
+ 	mvneta_rx_desc_fill(rx_desc, phys_addr, page, rxq);
++
+ 	return 0;
+ }
+ 
+@@ -1907,10 +1910,12 @@ static void mvneta_rxq_drop_pkts(struct
+ 		if (!data || !(rx_desc->buf_phys_addr))
+ 			continue;
+ 
+-		dma_unmap_page(pp->dev->dev.parent, rx_desc->buf_phys_addr,
+-			       PAGE_SIZE, DMA_FROM_DEVICE);
+-		__free_page(data);
++		page_pool_put_page(rxq->page_pool, data, false);
+ 	}
++	if (xdp_rxq_info_is_reg(&rxq->xdp_rxq))
++		xdp_rxq_info_unreg(&rxq->xdp_rxq);
++	page_pool_destroy(rxq->page_pool);
++	rxq->page_pool = NULL;
+ }
+ 
+ static void
+@@ -2047,8 +2052,7 @@ static int mvneta_rx_swbm(struct napi_st
+ 				skb_add_rx_frag(rxq->skb, frag_num, page,
+ 						frag_offset, frag_size,
+ 						PAGE_SIZE);
+-				dma_unmap_page(dev->dev.parent, phys_addr,
+-					       PAGE_SIZE, DMA_FROM_DEVICE);
++				page_pool_release_page(rxq->page_pool, page);
+ 				rxq->left_size -= frag_size;
+ 			}
+ 		} else {
+@@ -2078,9 +2082,7 @@ static int mvneta_rx_swbm(struct napi_st
+ 						frag_offset, frag_size,
+ 						PAGE_SIZE);
+ 
+-				dma_unmap_page(dev->dev.parent, phys_addr,
+-					       PAGE_SIZE, DMA_FROM_DEVICE);
+-
++				page_pool_release_page(rxq->page_pool, page);
+ 				rxq->left_size -= frag_size;
+ 			}
+ 		} /* Middle or Last descriptor */
+@@ -2847,11 +2849,54 @@ static int mvneta_poll(struct napi_struc
+ 	return rx_done;
+ }
+ 
++static int mvneta_create_page_pool(struct mvneta_port *pp,
++				   struct mvneta_rx_queue *rxq, int size)
++{
++	struct page_pool_params pp_params = {
++		.order = 0,
++		.flags = PP_FLAG_DMA_MAP,
++		.pool_size = size,
++		.nid = cpu_to_node(0),
++		.dev = pp->dev->dev.parent,
++		.dma_dir = DMA_FROM_DEVICE,
++	};
++	int err;
++
++	rxq->page_pool = page_pool_create(&pp_params);
++	if (IS_ERR(rxq->page_pool)) {
++		err = PTR_ERR(rxq->page_pool);
++		rxq->page_pool = NULL;
++		return err;
++	}
++
++	err = xdp_rxq_info_reg(&rxq->xdp_rxq, pp->dev, rxq->id);
++	if (err < 0)
++		goto err_free_pp;
++
++	err = xdp_rxq_info_reg_mem_model(&rxq->xdp_rxq, MEM_TYPE_PAGE_POOL,
++					 rxq->page_pool);
++	if (err)
++		goto err_unregister_rxq;
++
++	return 0;
++
++err_unregister_rxq:
++	xdp_rxq_info_unreg(&rxq->xdp_rxq);
++err_free_pp:
++	page_pool_destroy(rxq->page_pool);
++	rxq->page_pool = NULL;
++	return err;
++}
++
+ /* Handle rxq fill: allocates rxq skbs; called when initializing a port */
+ static int mvneta_rxq_fill(struct mvneta_port *pp, struct mvneta_rx_queue *rxq,
+ 			   int num)
+ {
+-	int i;
++	int i, err;
++
++	err = mvneta_create_page_pool(pp, rxq, num);
++	if (err < 0)
++		return err;
+ 
+ 	for (i = 0; i < num; i++) {
+ 		memset(rxq->descs + i, 0, sizeof(struct mvneta_rx_desc));
diff --git a/target/linux/mvebu/patches-5.10/005-net-mvneta-rely-on-build_skb-in-mvneta_rx_swbm-poll-.patch b/target/linux/mvebu/patches-5.10/005-net-mvneta-rely-on-build_skb-in-mvneta_rx_swbm-poll-.patch
new file mode 100644
index 0000000000..9038ca8ca8
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/005-net-mvneta-rely-on-build_skb-in-mvneta_rx_swbm-poll-.patch
@@ -0,0 +1,303 @@
+From 8dc9a0888f4c8e27b25e48ff1b4bc2b3a845cc2d Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Sat, 19 Oct 2019 10:13:23 +0200
+Subject: [PATCH 3/7] net: mvneta: rely on build_skb in mvneta_rx_swbm poll
+ routine
+
+Refactor mvneta_rx_swbm code introducing mvneta_swbm_rx_frame and
+mvneta_swbm_add_rx_fragment routines. Rely on build_skb in oreder to
+allocate skb since the previous patch introduced buffer recycling using
+the page_pool API.
+This patch fixes even an issue in the original driver where dma buffers
+are accessed before dma sync.
+mvneta driver can run on not cache coherent devices so it is
+necessary to sync DMA buffers before sending them to the device
+in order to avoid memory corruptions. Running perf analysis we can
+see a performance cost associated with this DMA-sync (anyway it is
+already there in the original driver code). In follow up patches we
+will add more logic to reduce DMA-sync as much as possible.
+
+Signed-off-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
+Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 185 +++++++++++++-------------
+ 1 file changed, 95 insertions(+), 90 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -325,6 +325,11 @@
+ 	      ETH_HLEN + ETH_FCS_LEN,			     \
+ 	      cache_line_size())
+ 
++#define MVNETA_SKB_PAD	(SKB_DATA_ALIGN(sizeof(struct skb_shared_info) + \
++			 NET_SKB_PAD))
++#define MVNETA_SKB_SIZE(len)	(SKB_DATA_ALIGN(len) + MVNETA_SKB_PAD)
++#define MVNETA_MAX_RX_BUF_SIZE	(PAGE_SIZE - MVNETA_SKB_PAD)
++
+ #define IS_TSO_HEADER(txq, addr) \
+ 	((addr >= txq->tso_hdrs_phys) && \
+ 	 (addr < txq->tso_hdrs_phys + txq->size * TSO_HEADER_SIZE))
+@@ -650,7 +655,6 @@ static int txq_number = 8;
+ static int rxq_def;
+ 
+ static int rx_copybreak __read_mostly = 256;
+-static int rx_header_size __read_mostly = 128;
+ 
+ /* HW BM need that each port be identify by a unique ID */
+ static int global_port_id;
+@@ -1842,7 +1846,7 @@ static int mvneta_rx_refill(struct mvnet
+ 	phys_addr = page_pool_get_dma_addr(page) + pp->rx_offset_correction;
+ 	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
+ 	dma_sync_single_for_device(pp->dev->dev.parent, phys_addr,
+-				   PAGE_SIZE, dma_dir);
++				   MVNETA_MAX_RX_BUF_SIZE, dma_dir);
+ 	mvneta_rx_desc_fill(rx_desc, phys_addr, page, rxq);
+ 
+ 	return 0;
+@@ -1960,30 +1964,102 @@ int mvneta_rx_refill_queue(struct mvneta
+ 	return i;
+ }
+ 
++static int
++mvneta_swbm_rx_frame(struct mvneta_port *pp,
++		     struct mvneta_rx_desc *rx_desc,
++		     struct mvneta_rx_queue *rxq,
++		     struct page *page)
++{
++	unsigned char *data = page_address(page);
++	int data_len = -MVNETA_MH_SIZE, len;
++	struct net_device *dev = pp->dev;
++	enum dma_data_direction dma_dir;
++
++	if (MVNETA_SKB_SIZE(rx_desc->data_size) > PAGE_SIZE) {
++		len = MVNETA_MAX_RX_BUF_SIZE;
++		data_len += len;
++	} else {
++		len = rx_desc->data_size;
++		data_len += len - ETH_FCS_LEN;
++	}
++
++	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
++	dma_sync_single_for_cpu(dev->dev.parent,
++				rx_desc->buf_phys_addr,
++				len, dma_dir);
++
++	rxq->skb = build_skb(data, PAGE_SIZE);
++	if (unlikely(!rxq->skb)) {
++		netdev_err(dev,
++			   "Can't allocate skb on queue %d\n",
++			   rxq->id);
++		dev->stats.rx_dropped++;
++		rxq->skb_alloc_err++;
++		return -ENOMEM;
++	}
++	page_pool_release_page(rxq->page_pool, page);
++
++	skb_reserve(rxq->skb, MVNETA_MH_SIZE + NET_SKB_PAD);
++	skb_put(rxq->skb, data_len);
++	mvneta_rx_csum(pp, rx_desc->status, rxq->skb);
++
++	rxq->left_size = rx_desc->data_size - len;
++	rx_desc->buf_phys_addr = 0;
++
++	return 0;
++}
++
++static void
++mvneta_swbm_add_rx_fragment(struct mvneta_port *pp,
++			    struct mvneta_rx_desc *rx_desc,
++			    struct mvneta_rx_queue *rxq,
++			    struct page *page)
++{
++	struct net_device *dev = pp->dev;
++	enum dma_data_direction dma_dir;
++	int data_len, len;
++
++	if (rxq->left_size > MVNETA_MAX_RX_BUF_SIZE) {
++		len = MVNETA_MAX_RX_BUF_SIZE;
++		data_len = len;
++	} else {
++		len = rxq->left_size;
++		data_len = len - ETH_FCS_LEN;
++	}
++	dma_dir = page_pool_get_dma_dir(rxq->page_pool);
++	dma_sync_single_for_cpu(dev->dev.parent,
++				rx_desc->buf_phys_addr,
++				len, dma_dir);
++	if (data_len > 0) {
++		/* refill descriptor with new buffer later */
++		skb_add_rx_frag(rxq->skb,
++				skb_shinfo(rxq->skb)->nr_frags,
++				page, NET_SKB_PAD, data_len,
++				PAGE_SIZE);
++	}
++	page_pool_release_page(rxq->page_pool, page);
++	rx_desc->buf_phys_addr = 0;
++	rxq->left_size -= len;
++}
++
+ /* Main rx processing when using software buffer management */
+ static int mvneta_rx_swbm(struct napi_struct *napi,
+ 			  struct mvneta_port *pp, int budget,
+ 			  struct mvneta_rx_queue *rxq)
+ {
++	int rcvd_pkts = 0, rcvd_bytes = 0, rx_proc = 0;
+ 	struct net_device *dev = pp->dev;
+-	int rx_todo, rx_proc;
+-	int refill = 0;
+-	u32 rcvd_pkts = 0;
+-	u32 rcvd_bytes = 0;
++	int rx_todo, refill;
+ 
+ 	/* Get number of received packets */
+ 	rx_todo = mvneta_rxq_busy_desc_num_get(pp, rxq);
+-	rx_proc = 0;
+ 
+ 	/* Fairness NAPI loop */
+-	while ((rcvd_pkts < budget) && (rx_proc < rx_todo)) {
++	while (rx_proc < budget && rx_proc < rx_todo) {
+ 		struct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);
++		u32 rx_status, index;
+ 		unsigned char *data;
+ 		struct page *page;
+-		dma_addr_t phys_addr;
+-		u32 rx_status, index;
+-		int rx_bytes, skb_size, copy_size;
+-		int frag_num, frag_size, frag_offset;
+ 
+ 		index = rx_desc - rxq->descs;
+ 		page = (struct page *)rxq->buf_virt_addr[index];
+@@ -1991,100 +2067,30 @@ static int mvneta_rx_swbm(struct napi_st
+ 		/* Prefetch header */
+ 		prefetch(data);
+ 
+-		phys_addr = rx_desc->buf_phys_addr;
+ 		rx_status = rx_desc->status;
+ 		rx_proc++;
+ 		rxq->refill_num++;
+ 
+ 		if (rx_status & MVNETA_RXD_FIRST_DESC) {
++			int err;
++
+ 			/* Check errors only for FIRST descriptor */
+ 			if (rx_status & MVNETA_RXD_ERR_SUMMARY) {
+ 				mvneta_rx_error(pp, rx_desc);
+ 				/* leave the descriptor untouched */
+ 				continue;
+ 			}
+-			rx_bytes = rx_desc->data_size -
+-				   (ETH_FCS_LEN + MVNETA_MH_SIZE);
+-
+-			/* Allocate small skb for each new packet */
+-			skb_size = max(rx_copybreak, rx_header_size);
+-			rxq->skb = netdev_alloc_skb_ip_align(dev, skb_size);
+-			if (unlikely(!rxq->skb)) {
+-				struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
+-
+-				netdev_err(dev,
+-					   "Can't allocate skb on queue %d\n",
+-					   rxq->id);
+-
+-				rxq->skb_alloc_err++;
+ 
+-				u64_stats_update_begin(&stats->syncp);
+-				stats->rx_dropped++;
+-				u64_stats_update_end(&stats->syncp);
++			err = mvneta_swbm_rx_frame(pp, rx_desc, rxq, page);
++			if (err)
+ 				continue;
+-			}
+-			copy_size = min(skb_size, rx_bytes);
+-
+-			/* Copy data from buffer to SKB, skip Marvell header */
+-			memcpy(rxq->skb->data, data + MVNETA_MH_SIZE,
+-			       copy_size);
+-			skb_put(rxq->skb, copy_size);
+-			rxq->left_size = rx_bytes - copy_size;
+-
+-			mvneta_rx_csum(pp, rx_status, rxq->skb);
+-			if (rxq->left_size == 0) {
+-				int size = copy_size + MVNETA_MH_SIZE;
+-
+-				dma_sync_single_range_for_cpu(dev->dev.parent,
+-							      phys_addr, 0,
+-							      size,
+-							      DMA_FROM_DEVICE);
+-
+-				/* leave the descriptor and buffer untouched */
+-			} else {
+-				/* refill descriptor with new buffer later */
+-				rx_desc->buf_phys_addr = 0;
+-
+-				frag_num = 0;
+-				frag_offset = copy_size + MVNETA_MH_SIZE;
+-				frag_size = min(rxq->left_size,
+-						(int)(PAGE_SIZE - frag_offset));
+-				skb_add_rx_frag(rxq->skb, frag_num, page,
+-						frag_offset, frag_size,
+-						PAGE_SIZE);
+-				page_pool_release_page(rxq->page_pool, page);
+-				rxq->left_size -= frag_size;
+-			}
+ 		} else {
+-			/* Middle or Last descriptor */
+ 			if (unlikely(!rxq->skb)) {
+ 				pr_debug("no skb for rx_status 0x%x\n",
+ 					 rx_status);
+ 				continue;
+ 			}
+-			if (!rxq->left_size) {
+-				/* last descriptor has only FCS */
+-				/* and can be discarded */
+-				dma_sync_single_range_for_cpu(dev->dev.parent,
+-							      phys_addr, 0,
+-							      ETH_FCS_LEN,
+-							      DMA_FROM_DEVICE);
+-				/* leave the descriptor and buffer untouched */
+-			} else {
+-				/* refill descriptor with new buffer later */
+-				rx_desc->buf_phys_addr = 0;
+-
+-				frag_num = skb_shinfo(rxq->skb)->nr_frags;
+-				frag_offset = 0;
+-				frag_size = min(rxq->left_size,
+-						(int)(PAGE_SIZE - frag_offset));
+-				skb_add_rx_frag(rxq->skb, frag_num, page,
+-						frag_offset, frag_size,
+-						PAGE_SIZE);
+-
+-				page_pool_release_page(rxq->page_pool, page);
+-				rxq->left_size -= frag_size;
+-			}
++			mvneta_swbm_add_rx_fragment(pp, rx_desc, rxq, page);
+ 		} /* Middle or Last descriptor */
+ 
+ 		if (!(rx_status & MVNETA_RXD_LAST_DESC))
+@@ -2109,7 +2115,6 @@ static int mvneta_rx_swbm(struct napi_st
+ 
+ 		/* clean uncomplete skb pointer in queue */
+ 		rxq->skb = NULL;
+-		rxq->left_size = 0;
+ 	}
+ 
+ 	if (rcvd_pkts)
+@@ -2970,7 +2975,7 @@ static void mvneta_rxq_hw_init(struct mv
+ 		/* Set Offset */
+ 		mvneta_rxq_offset_set(pp, rxq, 0);
+ 		mvneta_rxq_buf_size_set(pp, rxq, PAGE_SIZE < SZ_64K ?
+-					PAGE_SIZE :
++					MVNETA_MAX_RX_BUF_SIZE :
+ 					MVNETA_RX_BUF_SIZE(pp->pkt_size));
+ 		mvneta_rxq_bm_disable(pp, rxq);
+ 		mvneta_rxq_fill(pp, rxq, rxq->size);
+@@ -4708,7 +4713,7 @@ static int mvneta_probe(struct platform_
+ 	SET_NETDEV_DEV(dev, &pdev->dev);
+ 
+ 	pp->id = global_port_id++;
+-	pp->rx_offset_correction = 0; /* not relevant for SW BM */
++	pp->rx_offset_correction = NET_SKB_PAD;
+ 
+ 	/* Obtain access to BM resources if enabled and already initialized */
+ 	bm_node = of_parse_phandle(dn, "buffer-manager", 0);
diff --git a/target/linux/mvebu/patches-5.10/006-net-mvneta-add-basic-XDP-support.patch b/target/linux/mvebu/patches-5.10/006-net-mvneta-add-basic-XDP-support.patch
new file mode 100644
index 0000000000..163632df51
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/006-net-mvneta-add-basic-XDP-support.patch
@@ -0,0 +1,311 @@
+From 0db51da7a8e99f0803ec3a8e25c1a66234a219cb Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Sat, 19 Oct 2019 10:13:24 +0200
+Subject: [PATCH 4/7] net: mvneta: add basic XDP support
+
+Add basic XDP support to mvneta driver for devices that rely on software
+buffer management. Currently supported verdicts are:
+- XDP_DROP
+- XDP_PASS
+- XDP_REDIRECT
+- XDP_ABORTED
+
+- iptables drop:
+$iptables -t raw -I PREROUTING -p udp --dport 9 -j DROP
+$nstat -n && sleep 1 && nstat
+IpInReceives		151169		0.0
+IpExtInOctets		6953544		0.0
+IpExtInNoECTPkts	151165		0.0
+
+- XDP_DROP via xdp1
+$./samples/bpf/xdp1 3
+proto 0:	421419 pkt/s
+proto 0:	421444 pkt/s
+proto 0:	421393 pkt/s
+proto 0:	421440 pkt/s
+proto 0:	421184 pkt/s
+
+Tested-by: Matteo Croce <mcroce@redhat.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 148 ++++++++++++++++++++++++--
+ 1 file changed, 139 insertions(+), 9 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -38,6 +38,7 @@
+ #include <net/ipv6.h>
+ #include <net/tso.h>
+ #include <net/page_pool.h>
++#include <linux/bpf_trace.h>
+ 
+ /* Registers */
+ #define MVNETA_RXQ_CONFIG_REG(q)                (0x1400 + ((q) << 2))
+@@ -325,8 +326,10 @@
+ 	      ETH_HLEN + ETH_FCS_LEN,			     \
+ 	      cache_line_size())
+ 
++#define MVNETA_SKB_HEADROOM	(max(XDP_PACKET_HEADROOM, NET_SKB_PAD) + \
++				 NET_IP_ALIGN)
+ #define MVNETA_SKB_PAD	(SKB_DATA_ALIGN(sizeof(struct skb_shared_info) + \
+-			 NET_SKB_PAD))
++			 MVNETA_SKB_HEADROOM))
+ #define MVNETA_SKB_SIZE(len)	(SKB_DATA_ALIGN(len) + MVNETA_SKB_PAD)
+ #define MVNETA_MAX_RX_BUF_SIZE	(PAGE_SIZE - MVNETA_SKB_PAD)
+ 
+@@ -354,6 +357,11 @@ struct mvneta_statistic {
+ #define T_REG_64	64
+ #define T_SW		1
+ 
++#define MVNETA_XDP_PASS		BIT(0)
++#define MVNETA_XDP_DROPPED	BIT(1)
++#define MVNETA_XDP_TX		BIT(2)
++#define MVNETA_XDP_REDIR	BIT(3)
++
+ static const struct mvneta_statistic mvneta_statistics[] = {
+ 	{ 0x3000, T_REG_64, "good_octets_received", },
+ 	{ 0x3010, T_REG_32, "good_frames_received", },
+@@ -435,6 +443,8 @@ struct mvneta_port {
+ 	u32 cause_rx_tx;
+ 	struct napi_struct napi;
+ 
++	struct bpf_prog *xdp_prog;
++
+ 	/* Core clock */
+ 	struct clk *clk;
+ 	/* AXI clock */
+@@ -1965,10 +1975,50 @@ int mvneta_rx_refill_queue(struct mvneta
+ }
+ 
+ static int
++mvneta_run_xdp(struct mvneta_port *pp, struct mvneta_rx_queue *rxq,
++	       struct bpf_prog *prog, struct xdp_buff *xdp)
++{
++	u32 ret, act = bpf_prog_run_xdp(prog, xdp);
++
++	switch (act) {
++	case XDP_PASS:
++		ret = MVNETA_XDP_PASS;
++		break;
++	case XDP_REDIRECT: {
++		int err;
++
++		err = xdp_do_redirect(pp->dev, xdp, prog);
++		if (err) {
++			ret = MVNETA_XDP_DROPPED;
++			xdp_return_buff(xdp);
++		} else {
++			ret = MVNETA_XDP_REDIR;
++		}
++		break;
++	}
++	default:
++		bpf_warn_invalid_xdp_action(act);
++		/* fall through */
++	case XDP_ABORTED:
++		trace_xdp_exception(pp->dev, prog, act);
++		/* fall through */
++	case XDP_DROP:
++		page_pool_recycle_direct(rxq->page_pool,
++					 virt_to_head_page(xdp->data));
++		ret = MVNETA_XDP_DROPPED;
++		break;
++	}
++
++	return ret;
++}
++
++static int
+ mvneta_swbm_rx_frame(struct mvneta_port *pp,
+ 		     struct mvneta_rx_desc *rx_desc,
+ 		     struct mvneta_rx_queue *rxq,
+-		     struct page *page)
++		     struct xdp_buff *xdp,
++		     struct bpf_prog *xdp_prog,
++		     struct page *page, u32 *xdp_ret)
+ {
+ 	unsigned char *data = page_address(page);
+ 	int data_len = -MVNETA_MH_SIZE, len;
+@@ -1988,7 +2038,26 @@ mvneta_swbm_rx_frame(struct mvneta_port
+ 				rx_desc->buf_phys_addr,
+ 				len, dma_dir);
+ 
+-	rxq->skb = build_skb(data, PAGE_SIZE);
++	xdp->data_hard_start = data;
++	xdp->data = data + MVNETA_SKB_HEADROOM + MVNETA_MH_SIZE;
++	xdp->data_end = xdp->data + data_len;
++	xdp_set_data_meta_invalid(xdp);
++
++	if (xdp_prog) {
++		u32 ret;
++
++		ret = mvneta_run_xdp(pp, rxq, xdp_prog, xdp);
++		if (ret != MVNETA_XDP_PASS) {
++			mvneta_update_stats(pp, 1,
++					    xdp->data_end - xdp->data,
++					    false);
++			rx_desc->buf_phys_addr = 0;
++			*xdp_ret |= ret;
++			return ret;
++		}
++	}
++
++	rxq->skb = build_skb(xdp->data_hard_start, PAGE_SIZE);
+ 	if (unlikely(!rxq->skb)) {
+ 		netdev_err(dev,
+ 			   "Can't allocate skb on queue %d\n",
+@@ -1999,8 +2068,9 @@ mvneta_swbm_rx_frame(struct mvneta_port
+ 	}
+ 	page_pool_release_page(rxq->page_pool, page);
+ 
+-	skb_reserve(rxq->skb, MVNETA_MH_SIZE + NET_SKB_PAD);
+-	skb_put(rxq->skb, data_len);
++	skb_reserve(rxq->skb,
++		    xdp->data - xdp->data_hard_start);
++	skb_put(rxq->skb, xdp->data_end - xdp->data);
+ 	mvneta_rx_csum(pp, rx_desc->status, rxq->skb);
+ 
+ 	rxq->left_size = rx_desc->data_size - len;
+@@ -2034,7 +2104,7 @@ mvneta_swbm_add_rx_fragment(struct mvnet
+ 		/* refill descriptor with new buffer later */
+ 		skb_add_rx_frag(rxq->skb,
+ 				skb_shinfo(rxq->skb)->nr_frags,
+-				page, NET_SKB_PAD, data_len,
++				page, MVNETA_SKB_HEADROOM, data_len,
+ 				PAGE_SIZE);
+ 	}
+ 	page_pool_release_page(rxq->page_pool, page);
+@@ -2049,11 +2119,18 @@ static int mvneta_rx_swbm(struct napi_st
+ {
+ 	int rcvd_pkts = 0, rcvd_bytes = 0, rx_proc = 0;
+ 	struct net_device *dev = pp->dev;
++	struct bpf_prog *xdp_prog;
++	struct xdp_buff xdp_buf;
+ 	int rx_todo, refill;
++	u32 xdp_ret = 0;
+ 
+ 	/* Get number of received packets */
+ 	rx_todo = mvneta_rxq_busy_desc_num_get(pp, rxq);
+ 
++	rcu_read_lock();
++	xdp_prog = READ_ONCE(pp->xdp_prog);
++	xdp_buf.rxq = &rxq->xdp_rxq;
++
+ 	/* Fairness NAPI loop */
+ 	while (rx_proc < budget && rx_proc < rx_todo) {
+ 		struct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);
+@@ -2081,7 +2158,8 @@ static int mvneta_rx_swbm(struct napi_st
+ 				continue;
+ 			}
+ 
+-			err = mvneta_swbm_rx_frame(pp, rx_desc, rxq, page);
++			err = mvneta_swbm_rx_frame(pp, rx_desc, rxq, &xdp_buf,
++						   xdp_prog, page, &xdp_ret);
+ 			if (err)
+ 				continue;
+ 		} else {
+@@ -2116,6 +2194,10 @@ static int mvneta_rx_swbm(struct napi_st
+ 		/* clean uncomplete skb pointer in queue */
+ 		rxq->skb = NULL;
+ 	}
++	rcu_read_unlock();
++
++	if (xdp_ret & MVNETA_XDP_REDIR)
++		xdp_do_flush_map();
+ 
+ 	if (rcvd_pkts)
+ 		mvneta_update_stats(pp, rcvd_pkts, rcvd_bytes, false);
+@@ -2857,13 +2939,14 @@ static int mvneta_poll(struct napi_struc
+ static int mvneta_create_page_pool(struct mvneta_port *pp,
+ 				   struct mvneta_rx_queue *rxq, int size)
+ {
++	struct bpf_prog *xdp_prog = READ_ONCE(pp->xdp_prog);
+ 	struct page_pool_params pp_params = {
+ 		.order = 0,
+ 		.flags = PP_FLAG_DMA_MAP,
+ 		.pool_size = size,
+ 		.nid = cpu_to_node(0),
+ 		.dev = pp->dev->dev.parent,
+-		.dma_dir = DMA_FROM_DEVICE,
++		.dma_dir = xdp_prog ? DMA_BIDIRECTIONAL : DMA_FROM_DEVICE,
+ 	};
+ 	int err;
+ 
+@@ -3364,6 +3447,11 @@ static int mvneta_change_mtu(struct net_
+ 		mtu = ALIGN(MVNETA_RX_PKT_SIZE(mtu), 8);
+ 	}
+ 
++	if (pp->xdp_prog && mtu > MVNETA_MAX_RX_BUF_SIZE) {
++		netdev_info(dev, "Illegal MTU value %d for XDP mode\n", mtu);
++		return -EINVAL;
++	}
++
+ 	dev->mtu = mtu;
+ 
+ 	if (!netif_running(dev)) {
+@@ -4029,6 +4117,47 @@ static int mvneta_ioctl(struct net_devic
+ 	return phylink_mii_ioctl(pp->phylink, ifr, cmd);
+ }
+ 
++static int mvneta_xdp_setup(struct net_device *dev, struct bpf_prog *prog,
++			    struct netlink_ext_ack *extack)
++{
++	bool need_update, running = netif_running(dev);
++	struct mvneta_port *pp = netdev_priv(dev);
++	struct bpf_prog *old_prog;
++
++	if (prog && dev->mtu > MVNETA_MAX_RX_BUF_SIZE) {
++		NL_SET_ERR_MSG_MOD(extack, "Jumbo frames not supported on XDP");
++		return -EOPNOTSUPP;
++	}
++
++	need_update = !!pp->xdp_prog != !!prog;
++	if (running && need_update)
++		mvneta_stop(dev);
++
++	old_prog = xchg(&pp->xdp_prog, prog);
++	if (old_prog)
++		bpf_prog_put(old_prog);
++
++	if (running && need_update)
++		return mvneta_open(dev);
++
++	return 0;
++}
++
++static int mvneta_xdp(struct net_device *dev, struct netdev_bpf *xdp)
++{
++	struct mvneta_port *pp = netdev_priv(dev);
++
++	switch (xdp->command) {
++	case XDP_SETUP_PROG:
++		return mvneta_xdp_setup(dev, xdp->prog, xdp->extack);
++	case XDP_QUERY_PROG:
++		xdp->prog_id = pp->xdp_prog ? pp->xdp_prog->aux->id : 0;
++		return 0;
++	default:
++		return -EINVAL;
++	}
++}
++
+ /* Ethtool methods */
+ 
+ /* Set link ksettings (phy address, speed) for ethtools */
+@@ -4425,6 +4554,7 @@ static const struct net_device_ops mvnet
+ 	.ndo_fix_features    = mvneta_fix_features,
+ 	.ndo_get_stats64     = mvneta_get_stats64,
+ 	.ndo_do_ioctl        = mvneta_ioctl,
++	.ndo_bpf             = mvneta_xdp,
+ };
+ 
+ static const struct ethtool_ops mvneta_eth_tool_ops = {
+@@ -4713,7 +4843,7 @@ static int mvneta_probe(struct platform_
+ 	SET_NETDEV_DEV(dev, &pdev->dev);
+ 
+ 	pp->id = global_port_id++;
+-	pp->rx_offset_correction = NET_SKB_PAD;
++	pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
+ 
+ 	/* Obtain access to BM resources if enabled and already initialized */
+ 	bm_node = of_parse_phandle(dn, "buffer-manager", 0);
diff --git a/target/linux/mvebu/patches-5.10/007-gpio-mvebu-avoid_error_message_for_optional_IRQ.patch b/target/linux/mvebu/patches-5.10/007-gpio-mvebu-avoid_error_message_for_optional_IRQ.patch
new file mode 100644
index 0000000000..00d2b30d58
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/007-gpio-mvebu-avoid_error_message_for_optional_IRQ.patch
@@ -0,0 +1,31 @@
+From 525b0858ff2fdb78defec2d4d6d63baaa423d5fd Mon Sep 17 00:00:00 2001
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Fri, 13 Mar 2020 16:42:44 +1300
+Subject: [PATCH] gpio: mvebu: avoid error message for optional IRQ
+
+platform_get_irq() will generate an error message if the requested irq
+is not present
+
+  mvebu-gpio f1010140.gpio: IRQ index 3 not found
+
+use platform_get_irq_optional() to avoid the error message being
+generated.
+
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
+Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
+---
+ drivers/gpio/gpio-mvebu.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/gpio/gpio-mvebu.c
++++ b/drivers/gpio/gpio-mvebu.c
+@@ -1248,7 +1248,7 @@ static int mvebu_gpio_probe(struct platf
+ 	 * pins.
+ 	 */
+ 	for (i = 0; i < 4; i++) {
+-		int irq = platform_get_irq(pdev, i);
++		int irq = platform_get_irq_optional(pdev, i);
+ 
+ 		if (irq < 0)
+ 			continue;
diff --git a/target/linux/mvebu/patches-5.10/007-net-mvneta-move-header-prefetch-in-mvneta_swbm_rx_fr.patch b/target/linux/mvebu/patches-5.10/007-net-mvneta-move-header-prefetch-in-mvneta_swbm_rx_fr.patch
new file mode 100644
index 0000000000..e075796e41
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/007-net-mvneta-move-header-prefetch-in-mvneta_swbm_rx_fr.patch
@@ -0,0 +1,43 @@
+From fa383f6b77a2ed788266fa8fbfb659aa284d2f58 Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Sat, 19 Oct 2019 10:13:25 +0200
+Subject: [PATCH 5/7] net: mvneta: move header prefetch in mvneta_swbm_rx_frame
+
+Move data buffer prefetch in mvneta_swbm_rx_frame after
+dma_sync_single_range_for_cpu
+
+Signed-off-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
+Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 7 +++----
+ 1 file changed, 3 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -2038,6 +2038,9 @@ mvneta_swbm_rx_frame(struct mvneta_port
+ 				rx_desc->buf_phys_addr,
+ 				len, dma_dir);
+ 
++	/* Prefetch header */
++	prefetch(data);
++
+ 	xdp->data_hard_start = data;
+ 	xdp->data = data + MVNETA_SKB_HEADROOM + MVNETA_MH_SIZE;
+ 	xdp->data_end = xdp->data + data_len;
+@@ -2135,14 +2138,10 @@ static int mvneta_rx_swbm(struct napi_st
+ 	while (rx_proc < budget && rx_proc < rx_todo) {
+ 		struct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);
+ 		u32 rx_status, index;
+-		unsigned char *data;
+ 		struct page *page;
+ 
+ 		index = rx_desc - rxq->descs;
+ 		page = (struct page *)rxq->buf_virt_addr[index];
+-		data = page_address(page);
+-		/* Prefetch header */
+-		prefetch(data);
+ 
+ 		rx_status = rx_desc->status;
+ 		rx_proc++;
diff --git a/target/linux/mvebu/patches-5.10/008-net-mvneta-make-tx-buffer-array-agnostic.patch b/target/linux/mvebu/patches-5.10/008-net-mvneta-make-tx-buffer-array-agnostic.patch
new file mode 100644
index 0000000000..e79aa816b8
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/008-net-mvneta-make-tx-buffer-array-agnostic.patch
@@ -0,0 +1,210 @@
+From 9e58c8b410650b5a6eb5b8fad8474bd8425a4023 Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Sat, 19 Oct 2019 10:13:26 +0200
+Subject: [PATCH 6/7] net: mvneta: make tx buffer array agnostic
+
+Allow tx buffer array to contain both skb and xdp buffers in order to
+enable xdp frame recycling adding XDP_TX verdict support
+
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 66 +++++++++++++++++----------
+ 1 file changed, 43 insertions(+), 23 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -565,6 +565,20 @@ struct mvneta_rx_desc {
+ };
+ #endif
+ 
++enum mvneta_tx_buf_type {
++	MVNETA_TYPE_SKB,
++	MVNETA_TYPE_XDP_TX,
++	MVNETA_TYPE_XDP_NDO,
++};
++
++struct mvneta_tx_buf {
++	enum mvneta_tx_buf_type type;
++	union {
++		struct xdp_frame *xdpf;
++		struct sk_buff *skb;
++	};
++};
++
+ struct mvneta_tx_queue {
+ 	/* Number of this TX queue, in the range 0-7 */
+ 	u8 id;
+@@ -580,8 +594,8 @@ struct mvneta_tx_queue {
+ 	int tx_stop_threshold;
+ 	int tx_wake_threshold;
+ 
+-	/* Array of transmitted skb */
+-	struct sk_buff **tx_skb;
++	/* Array of transmitted buffers */
++	struct mvneta_tx_buf *buf;
+ 
+ 	/* Index of last TX DMA descriptor that was inserted */
+ 	int txq_put_index;
+@@ -1793,14 +1807,9 @@ static void mvneta_txq_bufs_free(struct
+ 	int i;
+ 
+ 	for (i = 0; i < num; i++) {
++		struct mvneta_tx_buf *buf = &txq->buf[txq->txq_get_index];
+ 		struct mvneta_tx_desc *tx_desc = txq->descs +
+ 			txq->txq_get_index;
+-		struct sk_buff *skb = txq->tx_skb[txq->txq_get_index];
+-
+-		if (skb) {
+-			bytes_compl += skb->len;
+-			pkts_compl++;
+-		}
+ 
+ 		mvneta_txq_inc_get(txq);
+ 
+@@ -1808,9 +1817,12 @@ static void mvneta_txq_bufs_free(struct
+ 			dma_unmap_single(pp->dev->dev.parent,
+ 					 tx_desc->buf_phys_addr,
+ 					 tx_desc->data_size, DMA_TO_DEVICE);
+-		if (!skb)
++		if (!buf->skb)
+ 			continue;
+-		dev_kfree_skb_any(skb);
++
++		bytes_compl += buf->skb->len;
++		pkts_compl++;
++		dev_kfree_skb_any(buf->skb);
+ 	}
+ 
+ 	netdev_tx_completed_queue(nq, pkts_compl, bytes_compl);
+@@ -2335,16 +2347,19 @@ static inline void
+ mvneta_tso_put_hdr(struct sk_buff *skb,
+ 		   struct mvneta_port *pp, struct mvneta_tx_queue *txq)
+ {
+-	struct mvneta_tx_desc *tx_desc;
+ 	int hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);
++	struct mvneta_tx_buf *buf = &txq->buf[txq->txq_put_index];
++	struct mvneta_tx_desc *tx_desc;
+ 
+-	txq->tx_skb[txq->txq_put_index] = NULL;
+ 	tx_desc = mvneta_txq_next_desc_get(txq);
+ 	tx_desc->data_size = hdr_len;
+ 	tx_desc->command = mvneta_skb_tx_csum(pp, skb);
+ 	tx_desc->command |= MVNETA_TXD_F_DESC;
+ 	tx_desc->buf_phys_addr = txq->tso_hdrs_phys +
+ 				 txq->txq_put_index * TSO_HEADER_SIZE;
++	buf->type = MVNETA_TYPE_SKB;
++	buf->skb = NULL;
++
+ 	mvneta_txq_inc_put(txq);
+ }
+ 
+@@ -2353,6 +2368,7 @@ mvneta_tso_put_data(struct net_device *d
+ 		    struct sk_buff *skb, char *data, int size,
+ 		    bool last_tcp, bool is_last)
+ {
++	struct mvneta_tx_buf *buf = &txq->buf[txq->txq_put_index];
+ 	struct mvneta_tx_desc *tx_desc;
+ 
+ 	tx_desc = mvneta_txq_next_desc_get(txq);
+@@ -2366,7 +2382,8 @@ mvneta_tso_put_data(struct net_device *d
+ 	}
+ 
+ 	tx_desc->command = 0;
+-	txq->tx_skb[txq->txq_put_index] = NULL;
++	buf->type = MVNETA_TYPE_SKB;
++	buf->skb = NULL;
+ 
+ 	if (last_tcp) {
+ 		/* last descriptor in the TCP packet */
+@@ -2374,7 +2391,7 @@ mvneta_tso_put_data(struct net_device *d
+ 
+ 		/* last descriptor in SKB */
+ 		if (is_last)
+-			txq->tx_skb[txq->txq_put_index] = skb;
++			buf->skb = skb;
+ 	}
+ 	mvneta_txq_inc_put(txq);
+ 	return 0;
+@@ -2459,6 +2476,7 @@ static int mvneta_tx_frag_process(struct
+ 	int i, nr_frags = skb_shinfo(skb)->nr_frags;
+ 
+ 	for (i = 0; i < nr_frags; i++) {
++		struct mvneta_tx_buf *buf = &txq->buf[txq->txq_put_index];
+ 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+ 		void *addr = skb_frag_address(frag);
+ 
+@@ -2478,12 +2496,13 @@ static int mvneta_tx_frag_process(struct
+ 		if (i == nr_frags - 1) {
+ 			/* Last descriptor */
+ 			tx_desc->command = MVNETA_TXD_L_DESC | MVNETA_TXD_Z_PAD;
+-			txq->tx_skb[txq->txq_put_index] = skb;
++			buf->skb = skb;
+ 		} else {
+ 			/* Descriptor in the middle: Not First, Not Last */
+ 			tx_desc->command = 0;
+-			txq->tx_skb[txq->txq_put_index] = NULL;
++			buf->skb = NULL;
+ 		}
++		buf->type = MVNETA_TYPE_SKB;
+ 		mvneta_txq_inc_put(txq);
+ 	}
+ 
+@@ -2511,6 +2530,7 @@ static netdev_tx_t mvneta_tx(struct sk_b
+ 	struct mvneta_port *pp = netdev_priv(dev);
+ 	u16 txq_id = skb_get_queue_mapping(skb);
+ 	struct mvneta_tx_queue *txq = &pp->txqs[txq_id];
++	struct mvneta_tx_buf *buf = &txq->buf[txq->txq_put_index];
+ 	struct mvneta_tx_desc *tx_desc;
+ 	int len = skb->len;
+ 	int frags = 0;
+@@ -2543,16 +2563,17 @@ static netdev_tx_t mvneta_tx(struct sk_b
+ 		goto out;
+ 	}
+ 
++	buf->type = MVNETA_TYPE_SKB;
+ 	if (frags == 1) {
+ 		/* First and Last descriptor */
+ 		tx_cmd |= MVNETA_TXD_FLZ_DESC;
+ 		tx_desc->command = tx_cmd;
+-		txq->tx_skb[txq->txq_put_index] = skb;
++		buf->skb = skb;
+ 		mvneta_txq_inc_put(txq);
+ 	} else {
+ 		/* First but not Last */
+ 		tx_cmd |= MVNETA_TXD_F_DESC;
+-		txq->tx_skb[txq->txq_put_index] = NULL;
++		buf->skb = NULL;
+ 		mvneta_txq_inc_put(txq);
+ 		tx_desc->command = tx_cmd;
+ 		/* Continue with other skb fragments */
+@@ -3138,9 +3159,8 @@ static int mvneta_txq_sw_init(struct mvn
+ 
+ 	txq->last_desc = txq->size - 1;
+ 
+-	txq->tx_skb = kmalloc_array(txq->size, sizeof(*txq->tx_skb),
+-				    GFP_KERNEL);
+-	if (!txq->tx_skb) {
++	txq->buf = kmalloc_array(txq->size, sizeof(*txq->buf), GFP_KERNEL);
++	if (!txq->buf) {
+ 		dma_free_coherent(pp->dev->dev.parent,
+ 				  txq->size * MVNETA_DESC_ALIGNED_SIZE,
+ 				  txq->descs, txq->descs_phys);
+@@ -3152,7 +3172,7 @@ static int mvneta_txq_sw_init(struct mvn
+ 					   txq->size * TSO_HEADER_SIZE,
+ 					   &txq->tso_hdrs_phys, GFP_KERNEL);
+ 	if (!txq->tso_hdrs) {
+-		kfree(txq->tx_skb);
++		kfree(txq->buf);
+ 		dma_free_coherent(pp->dev->dev.parent,
+ 				  txq->size * MVNETA_DESC_ALIGNED_SIZE,
+ 				  txq->descs, txq->descs_phys);
+@@ -3205,7 +3225,7 @@ static void mvneta_txq_sw_deinit(struct
+ {
+ 	struct netdev_queue *nq = netdev_get_tx_queue(pp->dev, txq->id);
+ 
+-	kfree(txq->tx_skb);
++	kfree(txq->buf);
+ 
+ 	if (txq->tso_hdrs)
+ 		dma_free_coherent(pp->dev->dev.parent,
diff --git a/target/linux/mvebu/patches-5.10/009-net-mvneta-add-XDP_TX-support.patch b/target/linux/mvebu/patches-5.10/009-net-mvneta-add-XDP_TX-support.patch
new file mode 100644
index 0000000000..c971030a1e
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/009-net-mvneta-add-XDP_TX-support.patch
@@ -0,0 +1,175 @@
+From b0a43db9087a21d96e1a0b716b8d9963064b2d58 Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Sat, 19 Oct 2019 10:13:27 +0200
+Subject: [PATCH 7/7] net: mvneta: add XDP_TX support
+
+Implement XDP_TX verdict and ndo_xdp_xmit net_device_ops function
+pointer
+
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 128 ++++++++++++++++++++++++--
+ 1 file changed, 121 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -1813,16 +1813,19 @@ static void mvneta_txq_bufs_free(struct
+ 
+ 		mvneta_txq_inc_get(txq);
+ 
+-		if (!IS_TSO_HEADER(txq, tx_desc->buf_phys_addr))
++		if (!IS_TSO_HEADER(txq, tx_desc->buf_phys_addr) &&
++		    buf->type != MVNETA_TYPE_XDP_TX)
+ 			dma_unmap_single(pp->dev->dev.parent,
+ 					 tx_desc->buf_phys_addr,
+ 					 tx_desc->data_size, DMA_TO_DEVICE);
+-		if (!buf->skb)
+-			continue;
+-
+-		bytes_compl += buf->skb->len;
+-		pkts_compl++;
+-		dev_kfree_skb_any(buf->skb);
++		if (buf->type == MVNETA_TYPE_SKB && buf->skb) {
++			bytes_compl += buf->skb->len;
++			pkts_compl++;
++			dev_kfree_skb_any(buf->skb);
++		} else if (buf->type == MVNETA_TYPE_XDP_TX ||
++			   buf->type == MVNETA_TYPE_XDP_NDO) {
++			xdp_return_frame(buf->xdpf);
++		}
+ 	}
+ 
+ 	netdev_tx_completed_queue(nq, pkts_compl, bytes_compl);
+@@ -1987,6 +1990,111 @@ int mvneta_rx_refill_queue(struct mvneta
+ }
+ 
+ static int
++mvneta_xdp_submit_frame(struct mvneta_port *pp, struct mvneta_tx_queue *txq,
++			struct xdp_frame *xdpf, bool dma_map)
++{
++	struct mvneta_tx_desc *tx_desc;
++	struct mvneta_tx_buf *buf;
++	dma_addr_t dma_addr;
++
++	if (txq->count >= txq->tx_stop_threshold)
++		return MVNETA_XDP_DROPPED;
++
++	tx_desc = mvneta_txq_next_desc_get(txq);
++
++	buf = &txq->buf[txq->txq_put_index];
++	if (dma_map) {
++		/* ndo_xdp_xmit */
++		dma_addr = dma_map_single(pp->dev->dev.parent, xdpf->data,
++					  xdpf->len, DMA_TO_DEVICE);
++		if (dma_mapping_error(pp->dev->dev.parent, dma_addr)) {
++			mvneta_txq_desc_put(txq);
++			return MVNETA_XDP_DROPPED;
++		}
++		buf->type = MVNETA_TYPE_XDP_NDO;
++	} else {
++		struct page *page = virt_to_page(xdpf->data);
++
++		dma_addr = page_pool_get_dma_addr(page) +
++			   sizeof(*xdpf) + xdpf->headroom;
++		dma_sync_single_for_device(pp->dev->dev.parent, dma_addr,
++					   xdpf->len, DMA_BIDIRECTIONAL);
++		buf->type = MVNETA_TYPE_XDP_TX;
++	}
++	buf->xdpf = xdpf;
++
++	tx_desc->command = MVNETA_TXD_FLZ_DESC;
++	tx_desc->buf_phys_addr = dma_addr;
++	tx_desc->data_size = xdpf->len;
++
++	mvneta_update_stats(pp, 1, xdpf->len, true);
++	mvneta_txq_inc_put(txq);
++	txq->pending++;
++	txq->count++;
++
++	return MVNETA_XDP_TX;
++}
++
++static int
++mvneta_xdp_xmit_back(struct mvneta_port *pp, struct xdp_buff *xdp)
++{
++	struct mvneta_tx_queue *txq;
++	struct netdev_queue *nq;
++	struct xdp_frame *xdpf;
++	int cpu;
++	u32 ret;
++
++	xdpf = convert_to_xdp_frame(xdp);
++	if (unlikely(!xdpf))
++		return MVNETA_XDP_DROPPED;
++
++	cpu = smp_processor_id();
++	txq = &pp->txqs[cpu % txq_number];
++	nq = netdev_get_tx_queue(pp->dev, txq->id);
++
++	__netif_tx_lock(nq, cpu);
++	ret = mvneta_xdp_submit_frame(pp, txq, xdpf, false);
++	if (ret == MVNETA_XDP_TX)
++		mvneta_txq_pend_desc_add(pp, txq, 0);
++	__netif_tx_unlock(nq);
++
++	return ret;
++}
++
++static int
++mvneta_xdp_xmit(struct net_device *dev, int num_frame,
++		struct xdp_frame **frames, u32 flags)
++{
++	struct mvneta_port *pp = netdev_priv(dev);
++	int cpu = smp_processor_id();
++	struct mvneta_tx_queue *txq;
++	struct netdev_queue *nq;
++	int i, drops = 0;
++	u32 ret;
++
++	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))
++		return -EINVAL;
++
++	txq = &pp->txqs[cpu % txq_number];
++	nq = netdev_get_tx_queue(pp->dev, txq->id);
++
++	__netif_tx_lock(nq, cpu);
++	for (i = 0; i < num_frame; i++) {
++		ret = mvneta_xdp_submit_frame(pp, txq, frames[i], true);
++		if (ret != MVNETA_XDP_TX) {
++			xdp_return_frame_rx_napi(frames[i]);
++			drops++;
++		}
++	}
++
++	if (unlikely(flags & XDP_XMIT_FLUSH))
++		mvneta_txq_pend_desc_add(pp, txq, 0);
++	__netif_tx_unlock(nq);
++
++	return num_frame - drops;
++}
++
++static int
+ mvneta_run_xdp(struct mvneta_port *pp, struct mvneta_rx_queue *rxq,
+ 	       struct bpf_prog *prog, struct xdp_buff *xdp)
+ {
+@@ -2008,6 +2116,11 @@ mvneta_run_xdp(struct mvneta_port *pp, s
+ 		}
+ 		break;
+ 	}
++	case XDP_TX:
++		ret = mvneta_xdp_xmit_back(pp, xdp);
++		if (ret != MVNETA_XDP_TX)
++			xdp_return_buff(xdp);
++		break;
+ 	default:
+ 		bpf_warn_invalid_xdp_action(act);
+ 		/* fall through */
+@@ -4574,6 +4687,7 @@ static const struct net_device_ops mvnet
+ 	.ndo_get_stats64     = mvneta_get_stats64,
+ 	.ndo_do_ioctl        = mvneta_ioctl,
+ 	.ndo_bpf             = mvneta_xdp,
++	.ndo_xdp_xmit        = mvneta_xdp_xmit,
+ };
+ 
+ static const struct ethtool_ops mvneta_eth_tool_ops = {
diff --git a/target/linux/mvebu/patches-5.10/010-net-mvneta-fix-build-skb-for-bm-capable-devices.patch b/target/linux/mvebu/patches-5.10/010-net-mvneta-fix-build-skb-for-bm-capable-devices.patch
new file mode 100644
index 0000000000..adfa51e4e8
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/010-net-mvneta-fix-build-skb-for-bm-capable-devices.patch
@@ -0,0 +1,41 @@
+From b37fa92e20ef28aada852cbf03b368d29a20478c Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Thu, 14 Nov 2019 01:25:55 +0200
+Subject: [PATCH] net: mvneta: fix build skb for bm capable devices
+
+Fix build_skb for bm capable devices when they fall-back using swbm path
+(e.g. when bm properties are configured in device tree but
+CONFIG_MVNETA_BM_ENABLE is not set). In this case rx_offset_correction is
+overwritten so we need to use it building skb instead of
+MVNETA_SKB_HEADROOM directly
+
+Fixes: 8dc9a0888f4c ("net: mvneta: rely on build_skb in mvneta_rx_swbm poll routine")
+Fixes: 0db51da7a8e9 ("net: mvneta: add basic XDP support")
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Reported-by: Andrew Lunn <andrew@lunn.ch>
+Tested-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -2167,7 +2167,7 @@ mvneta_swbm_rx_frame(struct mvneta_port
+ 	prefetch(data);
+ 
+ 	xdp->data_hard_start = data;
+-	xdp->data = data + MVNETA_SKB_HEADROOM + MVNETA_MH_SIZE;
++	xdp->data = data + pp->rx_offset_correction + MVNETA_MH_SIZE;
+ 	xdp->data_end = xdp->data + data_len;
+ 	xdp_set_data_meta_invalid(xdp);
+ 
+@@ -2232,7 +2232,7 @@ mvneta_swbm_add_rx_fragment(struct mvnet
+ 		/* refill descriptor with new buffer later */
+ 		skb_add_rx_frag(rxq->skb,
+ 				skb_shinfo(rxq->skb)->nr_frags,
+-				page, MVNETA_SKB_HEADROOM, data_len,
++				page, pp->rx_offset_correction, data_len,
+ 				PAGE_SIZE);
+ 	}
+ 	page_pool_release_page(rxq->page_pool, page);
diff --git a/target/linux/mvebu/patches-5.10/011-arm64-dts-uDPU-remove-i2c-fast-mode.patch b/target/linux/mvebu/patches-5.10/011-arm64-dts-uDPU-remove-i2c-fast-mode.patch
new file mode 100644
index 0000000000..2922d49f44
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/011-arm64-dts-uDPU-remove-i2c-fast-mode.patch
@@ -0,0 +1,31 @@
+From fe3ec631a77ded87817f449691710a436a80caa7 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Sat, 16 Nov 2019 11:07:01 +0000
+Subject: [PATCH] arm64: dts: uDPU: remove i2c-fast-mode
+
+The I2C bus violates the timing specifications when run in fast mode
+on the uDPU, so switch to 100kHz mode.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
+@@ -119,12 +119,14 @@
+ 	status = "okay";
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&i2c1_pins>;
++	/delete-property/mrvl,i2c-fast-mode;
+ };
+ 
+ &i2c1 {
+ 	status = "okay";
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&i2c2_pins>;
++	/delete-property/mrvl,i2c-fast-mode;
+ 
+ 	lm75@48 {
+ 		status = "okay";
diff --git a/target/linux/mvebu/patches-5.10/012-arm64-dts-uDPU-SFP-cages-support-3W-modules.patch b/target/linux/mvebu/patches-5.10/012-arm64-dts-uDPU-SFP-cages-support-3W-modules.patch
new file mode 100644
index 0000000000..1884def2c6
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/012-arm64-dts-uDPU-SFP-cages-support-3W-modules.patch
@@ -0,0 +1,34 @@
+From cd592187f9de3c6305d6c1c66f7fac084cb5b846 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 19 Nov 2019 22:53:04 +0000
+Subject: [PATCH] arm64: dts: uDPU: SFP cages support 3W modules
+
+The SFP cages are designed to support up to 3W modules, such as G.hn,
+G.fast and MoCA modules. Although there is no way for such modules to
+declare to software that they consume 3W, we document in DT that this
+is the designed power level for these cages.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
+@@ -69,6 +69,7 @@
+ 		mod-def0-gpio = <&gpiosb 3 GPIO_ACTIVE_LOW>;
+ 		tx-disable-gpio = <&gpiosb 4 GPIO_ACTIVE_HIGH>;
+ 		tx-fault-gpio = <&gpiosb 5 GPIO_ACTIVE_HIGH>;
++		maximum-power-milliwatt = <3000>;
+ 	};
+ 
+ 	sfp_eth1: sfp-eth1 {
+@@ -78,6 +79,7 @@
+ 		mod-def0-gpio = <&gpiosb 8 GPIO_ACTIVE_LOW>;
+ 		tx-disable-gpio = <&gpiosb 9 GPIO_ACTIVE_HIGH>;
+ 		tx-fault-gpio = <&gpiosb 10 GPIO_ACTIVE_HIGH>;
++		maximum-power-milliwatt = <3000>;
+ 	};
+ };
+ 
diff --git a/target/linux/mvebu/patches-5.10/013-net-mvneta-rely-on-page_pool_recycle_direct-in-mvnet.patch b/target/linux/mvebu/patches-5.10/013-net-mvneta-rely-on-page_pool_recycle_direct-in-mvnet.patch
new file mode 100644
index 0000000000..6e79aeb358
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/013-net-mvneta-rely-on-page_pool_recycle_direct-in-mvnet.patch
@@ -0,0 +1,39 @@
+From f383b2950070ce4f34e74db94f70bb565b746e97 Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Wed, 20 Nov 2019 16:54:17 +0200
+Subject: [PATCH] net: mvneta: rely on page_pool_recycle_direct in
+ mvneta_run_xdp
+
+Rely on page_pool_recycle_direct and not on xdp_return_buff in
+mvneta_run_xdp. This is a preliminary patch to limit the dma sync len
+to the one strictly necessary
+
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 6 ++++--
+ 1 file changed, 4 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -2110,7 +2110,8 @@ mvneta_run_xdp(struct mvneta_port *pp, s
+ 		err = xdp_do_redirect(pp->dev, xdp, prog);
+ 		if (err) {
+ 			ret = MVNETA_XDP_DROPPED;
+-			xdp_return_buff(xdp);
++			page_pool_recycle_direct(rxq->page_pool,
++						 virt_to_head_page(xdp->data));
+ 		} else {
+ 			ret = MVNETA_XDP_REDIR;
+ 		}
+@@ -2119,7 +2120,8 @@ mvneta_run_xdp(struct mvneta_port *pp, s
+ 	case XDP_TX:
+ 		ret = mvneta_xdp_xmit_back(pp, xdp);
+ 		if (ret != MVNETA_XDP_TX)
+-			xdp_return_buff(xdp);
++			page_pool_recycle_direct(rxq->page_pool,
++						 virt_to_head_page(xdp->data));
+ 		break;
+ 	default:
+ 		bpf_warn_invalid_xdp_action(act);
diff --git a/target/linux/mvebu/patches-5.10/014-mvneta-driver-disallow-XDP-program-on-hardware-buffe.patch b/target/linux/mvebu/patches-5.10/014-mvneta-driver-disallow-XDP-program-on-hardware-buffe.patch
new file mode 100644
index 0000000000..e8a41d9eb2
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/014-mvneta-driver-disallow-XDP-program-on-hardware-buffe.patch
@@ -0,0 +1,53 @@
+From 79572c98c554dcdb080bca547c871a51716dcdf8 Mon Sep 17 00:00:00 2001
+From: Sven Auhagen <sven.auhagen@voleatech.de>
+Date: Sat, 25 Jan 2020 08:07:03 +0000
+Subject: [PATCH] mvneta driver disallow XDP program on hardware buffer
+ management
+
+Recently XDP Support was added to the mvneta driver
+for software buffer management only.
+It is still possible to attach an XDP program if
+hardware buffer management is used.
+It is not doing anything at that point.
+
+The patch disallows attaching XDP programs to mvneta
+if hardware buffer management is used.
+
+I am sorry about that. It is my first submission and I am having
+some troubles with the format of my emails.
+
+v4 -> v5:
+- Remove extra tabs
+
+v3 -> v4:
+- Please ignore v3 I accidentally submitted
+  my other patch with git-send-mail and v4 is correct
+
+v2 -> v3:
+- My mailserver corrupted the patch
+  resubmission with git-send-email
+
+v1 -> v2:
+- Fixing the patches indentation
+
+Signed-off-by: Sven Auhagen <sven.auhagen@voleatech.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -4263,6 +4263,12 @@ static int mvneta_xdp_setup(struct net_d
+ 		return -EOPNOTSUPP;
+ 	}
+ 
++	if (pp->bm_priv) {
++		NL_SET_ERR_MSG_MOD(extack,
++				   "Hardware Buffer Management not supported on XDP");
++		return -EOPNOTSUPP;
++	}
++
+ 	need_update = !!pp->xdp_prog != !!prog;
+ 	if (running && need_update)
+ 		mvneta_stop(dev);
diff --git a/target/linux/mvebu/patches-5.10/015-net-mvneta-fix-XDP-support-if-sw-bm-is-used-as-fallb.patch b/target/linux/mvebu/patches-5.10/015-net-mvneta-fix-XDP-support-if-sw-bm-is-used-as-fallb.patch
new file mode 100644
index 0000000000..86bffa538a
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/015-net-mvneta-fix-XDP-support-if-sw-bm-is-used-as-fallb.patch
@@ -0,0 +1,67 @@
+From 44efc78d0e464ce70b45b165c005f8bedc17952e Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Wed, 29 Jan 2020 12:50:53 +0100
+Subject: [PATCH] net: mvneta: fix XDP support if sw bm is used as fallback
+
+In order to fix XDP support if sw buffer management is used as fallback
+for hw bm devices, define MVNETA_SKB_HEADROOM as maximum between
+XDP_PACKET_HEADROOM and NET_SKB_PAD and let the hw aligns the IP header
+to 4-byte boundary.
+Fix rx_offset_correction initialization if mvneta_bm_port_init fails in
+mvneta_resume routine
+
+Fixes: 0db51da7a8e9 ("net: mvneta: add basic XDP support")
+Tested-by: Sven Auhagen <sven.auhagen@voleatech.de>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 10 +++++++---
+ 1 file changed, 7 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -326,8 +326,7 @@
+ 	      ETH_HLEN + ETH_FCS_LEN,			     \
+ 	      cache_line_size())
+ 
+-#define MVNETA_SKB_HEADROOM	(max(XDP_PACKET_HEADROOM, NET_SKB_PAD) + \
+-				 NET_IP_ALIGN)
++#define MVNETA_SKB_HEADROOM	max(XDP_PACKET_HEADROOM, NET_SKB_PAD)
+ #define MVNETA_SKB_PAD	(SKB_DATA_ALIGN(sizeof(struct skb_shared_info) + \
+ 			 MVNETA_SKB_HEADROOM))
+ #define MVNETA_SKB_SIZE(len)	(SKB_DATA_ALIGN(len) + MVNETA_SKB_PAD)
+@@ -1174,6 +1173,7 @@ bm_mtu_err:
+ 	mvneta_bm_pool_destroy(pp->bm_priv, pp->pool_short, 1 << pp->id);
+ 
+ 	pp->bm_priv = NULL;
++	pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
+ 	mvreg_write(pp, MVNETA_ACC_MODE, MVNETA_ACC_MODE_EXT1);
+ 	netdev_info(pp->dev, "fail to update MTU, fall back to software BM\n");
+ }
+@@ -4984,7 +4984,6 @@ static int mvneta_probe(struct platform_
+ 	SET_NETDEV_DEV(dev, &pdev->dev);
+ 
+ 	pp->id = global_port_id++;
+-	pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
+ 
+ 	/* Obtain access to BM resources if enabled and already initialized */
+ 	bm_node = of_parse_phandle(dn, "buffer-manager", 0);
+@@ -5009,6 +5008,10 @@ static int mvneta_probe(struct platform_
+ 	}
+ 	of_node_put(bm_node);
+ 
++	/* sw buffer management */
++	if (!pp->bm_priv)
++		pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
++
+ 	err = mvneta_init(&pdev->dev, pp);
+ 	if (err < 0)
+ 		goto err_netdev;
+@@ -5166,6 +5169,7 @@ static int mvneta_resume(struct device *
+ 		err = mvneta_bm_port_init(pdev, pp);
+ 		if (err < 0) {
+ 			dev_info(&pdev->dev, "use SW buffer management\n");
++			pp->rx_offset_correction = MVNETA_SKB_HEADROOM;
+ 			pp->bm_priv = NULL;
+ 		}
+ 	}
diff --git a/target/linux/mvebu/patches-5.10/016-PCI-aardvark-Train-link-immediately-after-enabling-t.patch b/target/linux/mvebu/patches-5.10/016-PCI-aardvark-Train-link-immediately-after-enabling-t.patch
new file mode 100644
index 0000000000..c9e49ac2f1
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/016-PCI-aardvark-Train-link-immediately-after-enabling-t.patch
@@ -0,0 +1,60 @@
+From 6964494582f56a3882c2c53b0edbfe99eb32b2e1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 30 Apr 2020 10:06:14 +0200
+Subject: [PATCH] PCI: aardvark: Train link immediately after enabling training
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Adding even 100ms (PCI_PM_D3COLD_WAIT) delay between enabling link
+training and starting link training causes detection issues with some
+buggy cards (such as Compex WLE900VX).
+
+Move the code which enables link training immediately before the one
+which starts link traning.
+
+This fixes detection issues of Compex WLE900VX card on Turris MOX after
+cold boot.
+
+Link: https://lore.kernel.org/r/20200430080625.26070-2-pali@kernel.org
+Fixes: f4c7d053d7f7 ("PCI: aardvark: Wait for endpoint to be ready...")
+Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Acked-by: Rob Herring <robh@kernel.org>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 15 +++++++++------
+ 1 file changed, 9 insertions(+), 6 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -300,11 +300,6 @@ static void advk_pcie_setup_hw(struct ad
+ 	reg |= LANE_COUNT_1;
+ 	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+ 
+-	/* Enable link training */
+-	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+-	reg |= LINK_TRAINING_EN;
+-	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+-
+ 	/* Enable MSI */
+ 	reg = advk_readl(pcie, PCIE_CORE_CTRL2_REG);
+ 	reg |= PCIE_CORE_CTRL2_MSI_ENABLE;
+@@ -346,7 +341,15 @@ static void advk_pcie_setup_hw(struct ad
+ 	 */
+ 	msleep(PCI_PM_D3COLD_WAIT);
+ 
+-	/* Start link training */
++	/* Enable link training */
++	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
++	reg |= LINK_TRAINING_EN;
++	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
++
++	/*
++	 * Start link training immediately after enabling it.
++	 * This solves problems for some buggy cards.
++	 */
+ 	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
+ 	reg |= PCIE_CORE_LINK_TRAINING;
+ 	advk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);
diff --git a/target/linux/mvebu/patches-5.10/017-PCI-aardvark-Improve-link-training.patch b/target/linux/mvebu/patches-5.10/017-PCI-aardvark-Improve-link-training.patch
new file mode 100644
index 0000000000..2bf838432f
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/017-PCI-aardvark-Improve-link-training.patch
@@ -0,0 +1,208 @@
+From 43fc679ced18006b12d918d7a8a4af392b7fbfe7 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 30 Apr 2020 10:06:17 +0200
+Subject: [PATCH] PCI: aardvark: Improve link training
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Currently the aardvark driver trains link in PCIe gen2 mode. This may
+cause some buggy gen1 cards (such as Compex WLE900VX) to be unstable or
+even not detected. Moreover when ASPM code tries to retrain link second
+time, these cards may stop responding and link goes down. If gen1 is
+used this does not happen.
+
+Unconditionally forcing gen1 is not a good solution since it may have
+performance impact on gen2 cards.
+
+To overcome this, read 'max-link-speed' property (as defined in PCI
+device tree bindings) and use this as max gen mode. Then iteratively try
+link training at this mode or lower until successful. After successful
+link training choose final controller gen based on Negotiated Link Speed
+from Link Status register, which should match card speed.
+
+Link: https://lore.kernel.org/r/20200430080625.26070-5-pali@kernel.org
+Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Reviewed-by: Rob Herring <robh@kernel.org>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 114 ++++++++++++++++++++------
+ 1 file changed, 89 insertions(+), 25 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -39,6 +39,7 @@
+ #define PCIE_CORE_LINK_CTRL_STAT_REG				0xd0
+ #define     PCIE_CORE_LINK_L0S_ENTRY				BIT(0)
+ #define     PCIE_CORE_LINK_TRAINING				BIT(5)
++#define     PCIE_CORE_LINK_SPEED_SHIFT				16
+ #define     PCIE_CORE_LINK_WIDTH_SHIFT				20
+ #define PCIE_CORE_ERR_CAPCTL_REG				0x118
+ #define     PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX			BIT(5)
+@@ -201,6 +202,7 @@ struct advk_pcie {
+ 	struct mutex msi_used_lock;
+ 	u16 msi_msg;
+ 	int root_bus_nr;
++	int link_gen;
+ 	struct pci_bridge_emul bridge;
+ };
+ 
+@@ -225,20 +227,16 @@ static int advk_pcie_link_up(struct advk
+ 
+ static int advk_pcie_wait_for_link(struct advk_pcie *pcie)
+ {
+-	struct device *dev = &pcie->pdev->dev;
+ 	int retries;
+ 
+ 	/* check if the link is up or not */
+ 	for (retries = 0; retries < LINK_WAIT_MAX_RETRIES; retries++) {
+-		if (advk_pcie_link_up(pcie)) {
+-			dev_info(dev, "link up\n");
++		if (advk_pcie_link_up(pcie))
+ 			return 0;
+-		}
+ 
+ 		usleep_range(LINK_WAIT_USLEEP_MIN, LINK_WAIT_USLEEP_MAX);
+ 	}
+ 
+-	dev_err(dev, "link never came up\n");
+ 	return -ETIMEDOUT;
+ }
+ 
+@@ -253,6 +251,85 @@ static void advk_pcie_wait_for_retrain(s
+ 	}
+ }
+ 
++static int advk_pcie_train_at_gen(struct advk_pcie *pcie, int gen)
++{
++	int ret, neg_gen;
++	u32 reg;
++
++	/* Setup link speed */
++	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
++	reg &= ~PCIE_GEN_SEL_MSK;
++	if (gen == 3)
++		reg |= SPEED_GEN_3;
++	else if (gen == 2)
++		reg |= SPEED_GEN_2;
++	else
++		reg |= SPEED_GEN_1;
++	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
++
++	/*
++	 * Enable link training. This is not needed in every call to this
++	 * function, just once suffices, but it does not break anything either.
++	 */
++	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
++	reg |= LINK_TRAINING_EN;
++	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
++
++	/*
++	 * Start link training immediately after enabling it.
++	 * This solves problems for some buggy cards.
++	 */
++	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
++	reg |= PCIE_CORE_LINK_TRAINING;
++	advk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);
++
++	ret = advk_pcie_wait_for_link(pcie);
++	if (ret)
++		return ret;
++
++	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
++	neg_gen = (reg >> PCIE_CORE_LINK_SPEED_SHIFT) & 0xf;
++
++	return neg_gen;
++}
++
++static void advk_pcie_train_link(struct advk_pcie *pcie)
++{
++	struct device *dev = &pcie->pdev->dev;
++	int neg_gen = -1, gen;
++
++	/*
++	 * Try link training at link gen specified by device tree property
++	 * 'max-link-speed'. If this fails, iteratively train at lower gen.
++	 */
++	for (gen = pcie->link_gen; gen > 0; --gen) {
++		neg_gen = advk_pcie_train_at_gen(pcie, gen);
++		if (neg_gen > 0)
++			break;
++	}
++
++	if (neg_gen < 0)
++		goto err;
++
++	/*
++	 * After successful training if negotiated gen is lower than requested,
++	 * train again on negotiated gen. This solves some stability issues for
++	 * some buggy gen1 cards.
++	 */
++	if (neg_gen < gen) {
++		gen = neg_gen;
++		neg_gen = advk_pcie_train_at_gen(pcie, gen);
++	}
++
++	if (neg_gen == gen) {
++		dev_info(dev, "link up at gen %i\n", gen);
++		return;
++	}
++
++err:
++	dev_err(dev, "link never came up\n");
++}
++
+ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
+ {
+ 	u32 reg;
+@@ -288,12 +365,6 @@ static void advk_pcie_setup_hw(struct ad
+ 		PCIE_CORE_CTRL2_TD_ENABLE;
+ 	advk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);
+ 
+-	/* Set GEN2 */
+-	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+-	reg &= ~PCIE_GEN_SEL_MSK;
+-	reg |= SPEED_GEN_2;
+-	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+-
+ 	/* Set lane X1 */
+ 	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+ 	reg &= ~LANE_CNT_MSK;
+@@ -341,20 +412,7 @@ static void advk_pcie_setup_hw(struct ad
+ 	 */
+ 	msleep(PCI_PM_D3COLD_WAIT);
+ 
+-	/* Enable link training */
+-	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+-	reg |= LINK_TRAINING_EN;
+-	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+-
+-	/*
+-	 * Start link training immediately after enabling it.
+-	 * This solves problems for some buggy cards.
+-	 */
+-	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
+-	reg |= PCIE_CORE_LINK_TRAINING;
+-	advk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);
+-
+-	advk_pcie_wait_for_link(pcie);
++	advk_pcie_train_link(pcie);
+ 
+ 	reg = advk_readl(pcie, PCIE_CORE_CMD_STATUS_REG);
+ 	reg |= PCIE_CORE_CMD_MEM_ACCESS_EN |
+@@ -1035,6 +1093,12 @@ static int advk_pcie_probe(struct platfo
+ 		return ret;
+ 	}
+ 
++	ret = of_pci_get_max_link_speed(dev->of_node);
++	if (ret <= 0 || ret > 3)
++		pcie->link_gen = 3;
++	else
++		pcie->link_gen = ret;
++
+ 	advk_pcie_setup_hw(pcie);
+ 
+ 	ret = advk_sw_pci_bridge_init(pcie);
diff --git a/target/linux/mvebu/patches-5.10/018-PCI-aardvark-Issue-PERST-via-GPIO.patch b/target/linux/mvebu/patches-5.10/018-PCI-aardvark-Issue-PERST-via-GPIO.patch
new file mode 100644
index 0000000000..83212ec475
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/018-PCI-aardvark-Issue-PERST-via-GPIO.patch
@@ -0,0 +1,123 @@
+From 5169a9851daaa2782a7bd2bb83d5b1bd224b2879 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 30 Apr 2020 10:06:18 +0200
+Subject: [PATCH] PCI: aardvark: Issue PERST via GPIO
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add support for issuing PERST via GPIO specified in 'reset-gpios'
+property (as described in PCI device tree bindings).
+
+Some buggy cards (e.g. Compex WLE900VX or WLE1216) are not detected
+after reboot when PERST is not issued during driver initialization.
+
+If bootloader already enabled link training then issuing PERST has no
+effect for some buggy cards (e.g. Compex WLE900VX) and these cards are
+not detected. We therefore clear the LINK_TRAINING_EN register before.
+
+It was observed that Compex WLE900VX card needs to be in PERST reset
+for at least 10ms if bootloader enabled link training.
+
+Tested on Turris MOX.
+
+Link: https://lore.kernel.org/r/20200430080625.26070-6-pali@kernel.org
+Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 43 ++++++++++++++++++++++++++-
+ 1 file changed, 42 insertions(+), 1 deletion(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -9,6 +9,7 @@
+  */
+ 
+ #include <linux/delay.h>
++#include <linux/gpio.h>
+ #include <linux/interrupt.h>
+ #include <linux/irq.h>
+ #include <linux/irqdomain.h>
+@@ -17,6 +18,7 @@
+ #include <linux/init.h>
+ #include <linux/platform_device.h>
+ #include <linux/of_address.h>
++#include <linux/of_gpio.h>
+ #include <linux/of_pci.h>
+ 
+ #include "../pci.h"
+@@ -204,6 +206,7 @@ struct advk_pcie {
+ 	int root_bus_nr;
+ 	int link_gen;
+ 	struct pci_bridge_emul bridge;
++	struct gpio_desc *reset_gpio;
+ };
+ 
+ static inline void advk_writel(struct advk_pcie *pcie, u32 val, u64 reg)
+@@ -330,10 +333,31 @@ err:
+ 	dev_err(dev, "link never came up\n");
+ }
+ 
++static void advk_pcie_issue_perst(struct advk_pcie *pcie)
++{
++	u32 reg;
++
++	if (!pcie->reset_gpio)
++		return;
++
++	/* PERST does not work for some cards when link training is enabled */
++	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
++	reg &= ~LINK_TRAINING_EN;
++	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
++
++	/* 10ms delay is needed for some cards */
++	dev_info(&pcie->pdev->dev, "issuing PERST via reset GPIO for 10ms\n");
++	gpiod_set_value_cansleep(pcie->reset_gpio, 1);
++	usleep_range(10000, 11000);
++	gpiod_set_value_cansleep(pcie->reset_gpio, 0);
++}
++
+ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
+ {
+ 	u32 reg;
+ 
++	advk_pcie_issue_perst(pcie);
++
+ 	/* Set to Direct mode */
+ 	reg = advk_readl(pcie, CTRL_CONFIG_REG);
+ 	reg &= ~(CTRL_MODE_MASK << CTRL_MODE_SHIFT);
+@@ -406,7 +430,8 @@ static void advk_pcie_setup_hw(struct ad
+ 
+ 	/*
+ 	 * PERST# signal could have been asserted by pinctrl subsystem before
+-	 * probe() callback has been called, making the endpoint going into
++	 * probe() callback has been called or issued explicitly by reset gpio
++	 * function advk_pcie_issue_perst(), making the endpoint going into
+ 	 * fundamental reset. As required by PCI Express spec a delay for at
+ 	 * least 100ms after such a reset before link training is needed.
+ 	 */
+@@ -1093,6 +1118,22 @@ static int advk_pcie_probe(struct platfo
+ 		return ret;
+ 	}
+ 
++	pcie->reset_gpio = devm_gpiod_get_from_of_node(dev, dev->of_node,
++						       "reset-gpios", 0,
++						       GPIOD_OUT_LOW,
++						       "pcie1-reset");
++	ret = PTR_ERR_OR_ZERO(pcie->reset_gpio);
++	if (ret) {
++		if (ret == -ENOENT) {
++			pcie->reset_gpio = NULL;
++		} else {
++			if (ret != -EPROBE_DEFER)
++				dev_err(dev, "Failed to get reset-gpio: %i\n",
++					ret);
++			return ret;
++		}
++	}
++
+ 	ret = of_pci_get_max_link_speed(dev->of_node);
+ 	if (ret <= 0 || ret > 3)
+ 		pcie->link_gen = 3;
diff --git a/target/linux/mvebu/patches-5.10/019-PCI-aardvark-Add-PHY-support.patch b/target/linux/mvebu/patches-5.10/019-PCI-aardvark-Add-PHY-support.patch
new file mode 100644
index 0000000000..fa04861e80
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/019-PCI-aardvark-Add-PHY-support.patch
@@ -0,0 +1,152 @@
+From 366697018c9a2aa67d457bfdc495115cface6ae8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 30 Apr 2020 10:06:20 +0200
+Subject: [PATCH] PCI: aardvark: Add PHY support
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+With recent proposed changes for U-Boot it is possible that bootloader
+won't initialize the PHY for this controller (currently the PHY is
+initialized regardless whether PCI is used in U-Boot, but with these
+proposed changes the PHY is initialized only on request).
+
+Since the mvebu-a3700-comphy driver by Miquèl Raynal supports enabling
+PCIe PHY, and since Linux' functionality should be independent on what
+bootloader did, add code for enabling generic PHY if found in device OF
+node.
+
+The mvebu-a3700-comphy driver does PHY powering via SMC calls to ARM
+Trusted Firmware. The corresponding code in ARM Trusted Firmware skips
+one register write which U-Boot does not: step 7 ("Enable TX"), see [1].
+Instead ARM Trusted Firmware expects PCIe driver to do this step,
+probably because the register is in PCIe controller address space,
+instead of PHY address space. We therefore add this step into the
+advk_pcie_setup_hw function.
+
+[1] https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/drivers/marvell/comphy/phy-comphy-3700.c?h=v2.3-rc2#n836
+
+Link: https://lore.kernel.org/r/20200430080625.26070-8-pali@kernel.org
+Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Reviewed-by: Rob Herring <robh@kernel.org>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+Cc: Miquèl Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 69 +++++++++++++++++++++++++++
+ 1 file changed, 69 insertions(+)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -16,6 +16,7 @@
+ #include <linux/kernel.h>
+ #include <linux/pci.h>
+ #include <linux/init.h>
++#include <linux/phy/phy.h>
+ #include <linux/platform_device.h>
+ #include <linux/of_address.h>
+ #include <linux/of_gpio.h>
+@@ -103,6 +104,8 @@
+ #define     PCIE_CORE_CTRL2_STRICT_ORDER_ENABLE	BIT(5)
+ #define     PCIE_CORE_CTRL2_OB_WIN_ENABLE	BIT(6)
+ #define     PCIE_CORE_CTRL2_MSI_ENABLE		BIT(10)
++#define PCIE_CORE_REF_CLK_REG			(CONTROL_BASE_ADDR + 0x14)
++#define     PCIE_CORE_REF_CLK_TX_ENABLE		BIT(1)
+ #define PCIE_MSG_LOG_REG			(CONTROL_BASE_ADDR + 0x30)
+ #define PCIE_ISR0_REG				(CONTROL_BASE_ADDR + 0x40)
+ #define PCIE_MSG_PM_PME_MASK			BIT(7)
+@@ -207,6 +210,7 @@ struct advk_pcie {
+ 	int link_gen;
+ 	struct pci_bridge_emul bridge;
+ 	struct gpio_desc *reset_gpio;
++	struct phy *phy;
+ };
+ 
+ static inline void advk_writel(struct advk_pcie *pcie, u32 val, u64 reg)
+@@ -358,6 +362,11 @@ static void advk_pcie_setup_hw(struct ad
+ 
+ 	advk_pcie_issue_perst(pcie);
+ 
++	/* Enable TX */
++	reg = advk_readl(pcie, PCIE_CORE_REF_CLK_REG);
++	reg |= PCIE_CORE_REF_CLK_TX_ENABLE;
++	advk_writel(pcie, reg, PCIE_CORE_REF_CLK_REG);
++
+ 	/* Set to Direct mode */
+ 	reg = advk_readl(pcie, CTRL_CONFIG_REG);
+ 	reg &= ~(CTRL_MODE_MASK << CTRL_MODE_SHIFT);
+@@ -1083,6 +1092,62 @@ out_release_res:
+ 	return err;
+ }
+ 
++static void __maybe_unused advk_pcie_disable_phy(struct advk_pcie *pcie)
++{
++	phy_power_off(pcie->phy);
++	phy_exit(pcie->phy);
++}
++
++static int advk_pcie_enable_phy(struct advk_pcie *pcie)
++{
++	int ret;
++
++	if (!pcie->phy)
++		return 0;
++
++	ret = phy_init(pcie->phy);
++	if (ret)
++		return ret;
++
++	ret = phy_set_mode(pcie->phy, PHY_MODE_PCIE);
++	if (ret) {
++		phy_exit(pcie->phy);
++		return ret;
++	}
++
++	ret = phy_power_on(pcie->phy);
++	if (ret) {
++		phy_exit(pcie->phy);
++		return ret;
++	}
++
++	return 0;
++}
++
++static int advk_pcie_setup_phy(struct advk_pcie *pcie)
++{
++	struct device *dev = &pcie->pdev->dev;
++	struct device_node *node = dev->of_node;
++	int ret = 0;
++
++	pcie->phy = devm_of_phy_get(dev, node, NULL);
++	if (IS_ERR(pcie->phy) && (PTR_ERR(pcie->phy) == -EPROBE_DEFER))
++		return PTR_ERR(pcie->phy);
++
++	/* Old bindings miss the PHY handle */
++	if (IS_ERR(pcie->phy)) {
++		dev_warn(dev, "PHY unavailable (%ld)\n", PTR_ERR(pcie->phy));
++		pcie->phy = NULL;
++		return 0;
++	}
++
++	ret = advk_pcie_enable_phy(pcie);
++	if (ret)
++		dev_err(dev, "Failed to initialize PHY (%d)\n", ret);
++
++	return ret;
++}
++
+ static int advk_pcie_probe(struct platform_device *pdev)
+ {
+ 	struct device *dev = &pdev->dev;
+@@ -1140,6 +1205,10 @@ static int advk_pcie_probe(struct platfo
+ 	else
+ 		pcie->link_gen = ret;
+ 
++	ret = advk_pcie_setup_phy(pcie);
++	if (ret)
++		return ret;
++
+ 	advk_pcie_setup_hw(pcie);
+ 
+ 	ret = advk_sw_pci_bridge_init(pcie);
diff --git a/target/linux/mvebu/patches-5.10/020-arm64-dts-marvell-armada-37xx-Set-pcie_reset_pin-to-.patch b/target/linux/mvebu/patches-5.10/020-arm64-dts-marvell-armada-37xx-Set-pcie_reset_pin-to-.patch
new file mode 100644
index 0000000000..87247b63ad
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/020-arm64-dts-marvell-armada-37xx-Set-pcie_reset_pin-to-.patch
@@ -0,0 +1,93 @@
+From 715878016984b2617f6c1f177c50039e12e7bd5b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 30 Apr 2020 10:06:23 +0200
+Subject: [PATCH] arm64: dts: marvell: armada-37xx: Set pcie_reset_pin to gpio
+ function
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+We found out that we are unable to control the PERST# signal via the
+default pin dedicated to be PERST# pin (GPIO2[3] pin) on A3700 SOC when
+this pin is in EP_PCIE1_Resetn mode. There is a register in the PCIe
+register space called PERSTN_GPIO_EN (D0088004[3]), but changing the
+value of this register does not change the pin output when measuring
+with voltmeter.
+
+We do not know if this is a bug in the SOC, or if it works only when
+PCIe controller is in a certain state.
+
+Commit f4c7d053d7f7 ("PCI: aardvark: Wait for endpoint to be ready
+before training link") says that when this pin changes pinctrl mode
+from EP_PCIE1_Resetn to GPIO, the PERST# signal is asserted for a brief
+moment.
+
+So currently the situation is that on A3700 boards the PERST# signal is
+asserted in U-Boot (because the code in U-Boot issues reset via this pin
+via GPIO mode), and then in Linux by the obscure and undocumented
+mechanism described by the above mentioned commit.
+
+We want to issue PERST# signal in a known way, therefore this patch
+changes the pcie_reset_pin function from "pcie" to "gpio" and adds the
+reset-gpios property to the PCIe node in device tree files of
+EspressoBin and Armada 3720 Dev Board (Turris Mox device tree already
+has this property and uDPU does not have a PCIe port).
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+Cc: Remi Pommarel <repk@triplefau.lt>
+Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/armada-3720-db.dts           | 3 +++
+ arch/arm64/boot/dts/marvell/armada-3720-espressobin.dtsi | 1 +
+ arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts   | 4 ----
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi             | 2 +-
+ 4 files changed, 5 insertions(+), 5 deletions(-)
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-db.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-db.dts
+@@ -128,6 +128,9 @@
+ 
+ /* CON15(V2.0)/CON17(V1.4) : PCIe / CON15(V2.0)/CON12(V1.4) :mini-PCIe */
+ &pcie0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
++	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
+ 	status = "okay";
+ };
+ 
+--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
+@@ -59,6 +59,7 @@
+ 	phys = <&comphy1 0>;
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
++	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
+ };
+ 
+ /* J6 */
+--- a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+@@ -120,10 +120,6 @@
+ 	};
+ };
+ 
+-&pcie_reset_pins {
+-	function = "gpio";
+-};
+-
+ &pcie0 {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -317,7 +317,7 @@
+ 
+ 				pcie_reset_pins: pcie-reset-pins {
+ 					groups = "pcie1";
+-					function = "pcie";
++					function = "gpio";
+ 				};
+ 
+ 				pcie_clkreq_pins: pcie-clkreq-pins {
diff --git a/target/linux/mvebu/patches-5.10/021-arm64-dts-marvell-armada-37xx-Move-PCIe-comphy-handl.patch b/target/linux/mvebu/patches-5.10/021-arm64-dts-marvell-armada-37xx-Move-PCIe-comphy-handl.patch
new file mode 100644
index 0000000000..e92393ff6f
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/021-arm64-dts-marvell-armada-37xx-Move-PCIe-comphy-handl.patch
@@ -0,0 +1,57 @@
+From df749cdb015011e9ed8b60ebb84b4e76a9f35735 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 30 Apr 2020 10:06:24 +0200
+Subject: [PATCH] arm64: dts: marvell: armada-37xx: Move PCIe comphy handle
+ property
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Move the comphy handle property of the PCIe node from board specific
+device tree files (EspressoBin and Turris Mox) to the generic
+armada-37xx.dtsi.
+
+This is correct since this is the only possible PCIe PHY configuration
+on Armada 37xx, so when PCIe is enabled on any board, this handle is
+correct.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/armada-3720-espressobin.dtsi | 1 -
+ arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts   | 1 -
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi             | 1 +
+ 3 files changed, 1 insertion(+), 2 deletions(-)
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
+@@ -56,7 +56,6 @@
+ /* J9 */
+ &pcie0 {
+ 	status = "okay";
+-	phys = <&comphy1 0>;
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
+ 	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
+--- a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+@@ -126,7 +126,6 @@
+ 	status = "okay";
+ 	max-link-speed = <2>;
+ 	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
+-	phys = <&comphy1 0>;
+ 
+ 	/* enabled by U-Boot if PCIe module is present */
+ 	status = "disabled";
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -493,6 +493,7 @@
+ 					<0 0 0 2 &pcie_intc 1>,
+ 					<0 0 0 3 &pcie_intc 2>,
+ 					<0 0 0 4 &pcie_intc 3>;
++			phys = <&comphy1 0>;
+ 			pcie_intc: interrupt-controller {
+ 				interrupt-controller;
+ 				#interrupt-cells = <1>;
diff --git a/target/linux/mvebu/patches-5.10/022-arm64-dts-marvell-armada-37xx-Move-PCIe-max-link-spe.patch b/target/linux/mvebu/patches-5.10/022-arm64-dts-marvell-armada-37xx-Move-PCIe-max-link-spe.patch
new file mode 100644
index 0000000000..ad918bef88
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/022-arm64-dts-marvell-armada-37xx-Move-PCIe-max-link-spe.patch
@@ -0,0 +1,44 @@
+From 1b5a2dd9e266d78d5fddd7e6b116e47ba9577b5e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 30 Apr 2020 10:06:25 +0200
+Subject: [PATCH] arm64: dts: marvell: armada-37xx: Move PCIe max-link-speed
+ property
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Move the max-link-speed property of the PCIe node from board specific
+device tree files to the generic armada-37xx.dtsi.
+
+Armada 37xx supports only PCIe gen2 speed so max-link-speed property
+should be in the generic armada-37xx.dtsi file.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts | 1 -
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi           | 1 +
+ 2 files changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+@@ -124,7 +124,6 @@
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&pcie_reset_pins &pcie_clkreq_pins>;
+ 	status = "okay";
+-	max-link-speed = <2>;
+ 	reset-gpios = <&gpiosb 3 GPIO_ACTIVE_LOW>;
+ 
+ 	/* enabled by U-Boot if PCIe module is present */
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -493,6 +493,7 @@
+ 					<0 0 0 2 &pcie_intc 1>,
+ 					<0 0 0 3 &pcie_intc 2>,
+ 					<0 0 0 4 &pcie_intc 3>;
++			max-link-speed = <2>;
+ 			phys = <&comphy1 0>;
+ 			pcie_intc: interrupt-controller {
+ 				interrupt-controller;
diff --git a/target/linux/mvebu/patches-5.10/023-arm64-dts-add-uDPU-i2c-bus-recovery.patch b/target/linux/mvebu/patches-5.10/023-arm64-dts-add-uDPU-i2c-bus-recovery.patch
new file mode 100644
index 0000000000..818fce85a8
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/023-arm64-dts-add-uDPU-i2c-bus-recovery.patch
@@ -0,0 +1,53 @@
+From 11b2af36cc874027ce701c5784cb957c99c7de3d Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Wed, 6 May 2020 10:40:37 +0100
+Subject: [PATCH] arm64: dts: add uDPU i2c bus recovery
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ .../boot/dts/marvell/armada-3720-uDPU.dts     | 22 +++++++++++++++++--
+ 1 file changed, 20 insertions(+), 2 deletions(-)
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
+@@ -117,18 +117,36 @@
+ 	};
+ };
+ 
++&pinctrl_nb {
++	i2c1_recovery_pins: i2c1-recovery-pins {
++		groups = "i2c1";
++		function = "gpio";
++	};
++
++	i2c2_recovery_pins: i2c2-recovery-pins {
++		groups = "i2c2";
++		function = "gpio";
++	};
++};
++
+ &i2c0 {
+ 	status = "okay";
+-	pinctrl-names = "default";
++	pinctrl-names = "default", "recovery";
+ 	pinctrl-0 = <&i2c1_pins>;
++	pinctrl-1 = <&i2c1_recovery_pins>;
+ 	/delete-property/mrvl,i2c-fast-mode;
++	scl-gpios = <&gpionb 0 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
++	sda-gpios = <&gpionb 1 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+ };
+ 
+ &i2c1 {
+ 	status = "okay";
+-	pinctrl-names = "default";
++	pinctrl-names = "default", "recovery";
+ 	pinctrl-0 = <&i2c2_pins>;
++	pinctrl-1 = <&i2c2_recovery_pins>;
+ 	/delete-property/mrvl,i2c-fast-mode;
++	scl-gpios = <&gpionb 2 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
++	sda-gpios = <&gpionb 3 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+ 
+ 	lm75@48 {
+ 		status = "okay";
diff --git a/target/linux/mvebu/patches-5.10/024-PCI-aardvark-Don-t-touch-PCIe-registers-if-no-card-c.patch b/target/linux/mvebu/patches-5.10/024-PCI-aardvark-Don-t-touch-PCIe-registers-if-no-card-c.patch
new file mode 100644
index 0000000000..dfc068c8cb
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/024-PCI-aardvark-Don-t-touch-PCIe-registers-if-no-card-c.patch
@@ -0,0 +1,50 @@
+From 70e380250c3621c55ff218cbaf2272830d9dbb1d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 2 Jul 2020 10:30:36 +0200
+Subject: [PATCH] PCI: aardvark: Don't touch PCIe registers if no card
+ connected
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+When there is no PCIe card connected and advk_pcie_rd_conf() or
+advk_pcie_wr_conf() is called for PCI bus which doesn't belong to emulated
+root bridge, the aardvark driver throws the following error message:
+
+  advk-pcie d0070000.pcie: config read/write timed out
+
+Obviously accessing PCIe registers of disconnected card is not possible.
+
+Extend check in advk_pcie_valid_device() function for validating
+availability of PCIe bus. If PCIe link is down, then the device is marked
+as Not Found and the driver does not try to access these registers.
+
+This is just an optimization to prevent accessing PCIe registers when card
+is disconnected. Trying to access PCIe registers of disconnected card does
+not cause any crash, kernel just needs to wait for a timeout. So if card
+disappear immediately after checking for PCIe link (before accessing PCIe
+registers), it does not cause any problems.
+
+Link: https://lore.kernel.org/r/20200702083036.12230-1-pali@kernel.org
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -639,6 +639,13 @@ static bool advk_pcie_valid_device(struc
+ 	if ((bus->number == pcie->root_bus_nr) && PCI_SLOT(devfn) != 0)
+ 		return false;
+ 
++	/*
++	 * If the link goes down after we check for link-up, nothing bad
++	 * happens but the config access times out.
++	 */
++	if (bus->number != pcie->root_bus_nr && !advk_pcie_link_up(pcie))
++		return false;
++
+ 	return true;
+ }
+ 
diff --git a/target/linux/mvebu/patches-5.10/025-power-reset-add-driver-for-LinkStation-power-off.patch b/target/linux/mvebu/patches-5.10/025-power-reset-add-driver-for-LinkStation-power-off.patch
new file mode 100644
index 0000000000..64ea26559e
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/025-power-reset-add-driver-for-LinkStation-power-off.patch
@@ -0,0 +1,207 @@
+From a7f79f99541eff4e6bcae0014eb08d3019337565 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Daniel=20Gonz=C3=A1lez=20Cabanelas?= <dgcbueu@gmail.com>
+Date: Wed, 15 Jul 2020 15:35:14 +0200
+Subject: [PATCH] power: reset: add driver for LinkStation power off
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Some Buffalo LinkStations perform the power off operation, at restart
+time, depending on the state of an output pin (LED2/INTn) at the ethernet
+PHY. This pin is also used to wake the machine when a WoL packet is
+received by the PHY.
+
+The driver is required by the Buffalo LinkStation LS421DE (ARM MVEBU),
+and other models. Without it, the board remains forever halted if a
+power off command is executed, unless the PSU is disconnected and
+connected again.
+
+Add the driver to provide the power off function and also make the WoL
+feature to be available.
+
+Signed-off-by: Daniel González Cabanelas <dgcbueu@gmail.com>
+Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>
+---
+ drivers/power/reset/Kconfig                |  11 ++
+ drivers/power/reset/Makefile               |   1 +
+ drivers/power/reset/linkstation-poweroff.c | 136 +++++++++++++++++++++
+ 3 files changed, 148 insertions(+)
+ create mode 100644 drivers/power/reset/linkstation-poweroff.c
+
+--- a/drivers/power/reset/Kconfig
++++ b/drivers/power/reset/Kconfig
+@@ -99,6 +99,17 @@ config POWER_RESET_HISI
+ 	help
+ 	  Reboot support for Hisilicon boards.
+ 
++config POWER_RESET_LINKSTATION
++	tristate "Buffalo LinkStation power-off driver"
++	depends on ARCH_MVEBU || COMPILE_TEST
++	depends on OF_MDIO && PHYLIB
++	help
++	  This driver supports turning off some Buffalo LinkStations by
++	  setting an output pin at the ethernet PHY to the correct state.
++	  It also makes the device compatible with the WoL function.
++
++	  Say Y here if you have a Buffalo LinkStation LS421D/E.
++
+ config POWER_RESET_MSM
+ 	bool "Qualcomm MSM power-off driver"
+ 	depends on ARCH_QCOM
+--- a/drivers/power/reset/Makefile
++++ b/drivers/power/reset/Makefile
+@@ -10,6 +10,7 @@ obj-$(CONFIG_POWER_RESET_GEMINI_POWEROFF
+ obj-$(CONFIG_POWER_RESET_GPIO) += gpio-poweroff.o
+ obj-$(CONFIG_POWER_RESET_GPIO_RESTART) += gpio-restart.o
+ obj-$(CONFIG_POWER_RESET_HISI) += hisi-reboot.o
++obj-${CONFIG_POWER_RESET_LINKSTATION} += linkstation-poweroff.o
+ obj-$(CONFIG_POWER_RESET_MSM) += msm-poweroff.o
+ obj-$(CONFIG_POWER_RESET_QCOM_PON) += qcom-pon.o
+ obj-$(CONFIG_POWER_RESET_OCELOT_RESET) += ocelot-reset.o
+--- /dev/null
++++ b/drivers/power/reset/linkstation-poweroff.c
+@@ -0,0 +1,144 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * LinkStation power off restart driver
++ * Copyright (C) 2020 Daniel González Cabanelas <dgcbueu@gmail.com>
++ */
++
++#include <linux/module.h>
++#include <linux/notifier.h>
++#include <linux/of.h>
++#include <linux/of_mdio.h>
++#include <linux/of_platform.h>
++#include <linux/reboot.h>
++#include <linux/phy.h>
++
++/* Defines from the eth phy Marvell driver */
++#define MII_MARVELL_COPPER_PAGE		0
++#define MII_MARVELL_LED_PAGE		3
++#define MII_MARVELL_WOL_PAGE		17
++#define MII_MARVELL_PHY_PAGE		22
++
++#define MII_PHY_LED_CTRL		16
++#define MII_88E1318S_PHY_LED_TCR	18
++#define MII_88E1318S_PHY_WOL_CTRL	16
++#define MII_M1011_IEVENT		19
++
++#define MII_88E1318S_PHY_LED_TCR_INTn_ENABLE		BIT(7)
++#define MII_88E1318S_PHY_LED_TCR_FORCE_INT		BIT(15)
++#define MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS	BIT(12)
++#define LED2_FORCE_ON					(0x8 << 8)
++#define LEDMASK						GENMASK(11,8)
++
++static struct phy_device *phydev;
++
++static void mvphy_reg_intn(u16 data)
++{
++	int rc = 0, saved_page;
++
++	saved_page = phy_select_page(phydev, MII_MARVELL_LED_PAGE);
++	if (saved_page < 0)
++		goto err;
++
++	/* Force manual LED2 control to let INTn work */
++	__phy_modify(phydev, MII_PHY_LED_CTRL, LEDMASK, LED2_FORCE_ON);
++
++	/* Set the LED[2]/INTn pin to the required state */
++	__phy_modify(phydev, MII_88E1318S_PHY_LED_TCR,
++		     MII_88E1318S_PHY_LED_TCR_FORCE_INT,
++		     MII_88E1318S_PHY_LED_TCR_INTn_ENABLE | data);
++
++	if (!data) {
++		/* Clear interrupts to ensure INTn won't be holded in high state */
++		__phy_write(phydev, MII_MARVELL_PHY_PAGE, MII_MARVELL_COPPER_PAGE);
++		__phy_read(phydev, MII_M1011_IEVENT);
++
++		/* If WOL was enabled and a magic packet was received before powering
++		 * off, we won't be able to wake up by sending another magic packet.
++		 * Clear WOL status.
++		 */
++		__phy_write(phydev, MII_MARVELL_PHY_PAGE, MII_MARVELL_WOL_PAGE);
++		__phy_set_bits(phydev, MII_88E1318S_PHY_WOL_CTRL,
++			       MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS);
++	}
++err:
++	rc = phy_restore_page(phydev, saved_page, rc);
++	if (rc < 0)
++		dev_err(&phydev->mdio.dev, "Write register failed, %d\n", rc);
++
++	if (!data) {
++		/* Slow down the PHY to save energy */
++		rc= phy_speed_down(phydev, false);
++		if (rc < 0)
++			dev_err(&phydev->mdio.dev, "PHY speed down failed, %d\n", rc);
++	}
++}
++
++static int linkstation_reboot_notifier(struct notifier_block *nb,
++				       unsigned long action, void *unused)
++{
++	if (action == SYS_RESTART)
++		mvphy_reg_intn(MII_88E1318S_PHY_LED_TCR_FORCE_INT);
++
++	return NOTIFY_DONE;
++}
++
++static struct notifier_block linkstation_reboot_nb = {
++	.notifier_call = linkstation_reboot_notifier,
++};
++
++static void linkstation_poweroff(void)
++{
++	unregister_reboot_notifier(&linkstation_reboot_nb);
++	mvphy_reg_intn(0);
++
++	kernel_restart("Power off");
++}
++
++static const struct of_device_id ls_poweroff_of_match[] = {
++	{ .compatible = "buffalo,ls421d" },
++	{ .compatible = "buffalo,ls421de" },
++	{ },
++};
++
++static int __init linkstation_poweroff_init(void)
++{
++	struct mii_bus *bus;
++	struct device_node *dn;
++
++	dn = of_find_matching_node(NULL, ls_poweroff_of_match);
++	if (!dn)
++		return -ENODEV;
++	of_node_put(dn);
++
++	dn = of_find_node_by_name(NULL, "mdio");
++	if (!dn)
++		return -ENODEV;
++
++	bus = of_mdio_find_bus(dn);
++	of_node_put(dn);
++	if (!bus)
++		return -EPROBE_DEFER;
++
++	phydev = phy_find_first(bus);
++	if (!phydev)
++		return -EPROBE_DEFER;
++
++	register_reboot_notifier(&linkstation_reboot_nb);
++	pm_power_off = linkstation_poweroff;
++
++	pr_info("LinkStation power off driver registered\n");
++	return 0;
++}
++
++static void __exit linkstation_poweroff_exit(void)
++{
++	pm_power_off = NULL;
++	unregister_reboot_notifier(&linkstation_reboot_nb);
++}
++
++module_init(linkstation_poweroff_init);
++module_exit(linkstation_poweroff_exit);
++
++MODULE_AUTHOR("Daniel González Cabanelas <dgcbueu@gmail.com>");
++MODULE_DESCRIPTION("LinkStation power off driver");
++MODULE_LICENSE("GPL v2");
diff --git a/target/linux/mvebu/patches-5.10/026-PCI-aardvark-Fix-initialization-with-old-Marvell-s-A.patch b/target/linux/mvebu/patches-5.10/026-PCI-aardvark-Fix-initialization-with-old-Marvell-s-A.patch
new file mode 100644
index 0000000000..bb9d7b7849
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/026-PCI-aardvark-Fix-initialization-with-old-Marvell-s-A.patch
@@ -0,0 +1,44 @@
+From b0c6ae0f8948a2be6bf4e8b4bbab9ca1343289b6 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Wed, 2 Sep 2020 16:43:44 +0200
+Subject: [PATCH] PCI: aardvark: Fix initialization with old Marvell's Arm
+ Trusted Firmware
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Old ATF automatically power on pcie phy and does not provide SMC call for
+phy power on functionality which leads to aardvark initialization failure:
+
+[    0.330134] mvebu-a3700-comphy d0018300.phy: unsupported SMC call, try updating your firmware
+[    0.338846] phy phy-d0018300.phy.1: phy poweron failed --> -95
+[    0.344753] advk-pcie d0070000.pcie: Failed to initialize PHY (-95)
+[    0.351160] advk-pcie: probe of d0070000.pcie failed with error -95
+
+This patch fixes above failure by ignoring 'not supported' error in
+aardvark driver. In this case it is expected that phy is already power on.
+
+Tested-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+Link: https://lore.kernel.org/r/20200902144344.16684-3-pali@kernel.org
+Fixes: 366697018c9a ("PCI: aardvark: Add PHY support")
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+Reviewed-by: Rob Herring <robh@kernel.org>
+Cc: <stable@vger.kernel.org> # 5.8+: ea17a0f153af: phy: marvell: comphy: Convert internal SMCC firmware return codes to errno
+---
+ drivers/pci/controller/pci-aardvark.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1123,7 +1123,9 @@ static int advk_pcie_enable_phy(struct a
+ 	}
+ 
+ 	ret = phy_power_on(pcie->phy);
+-	if (ret) {
++	if (ret == -EOPNOTSUPP) {
++		dev_warn(&pcie->pdev->dev, "PHY unsupported by firmware\n");
++	} else if (ret) {
+ 		phy_exit(pcie->phy);
+ 		return ret;
+ 	}
diff --git a/target/linux/mvebu/patches-5.10/027-arm64-dts-marvell-espressobin-Add-ethernet-switch-al.patch b/target/linux/mvebu/patches-5.10/027-arm64-dts-marvell-espressobin-Add-ethernet-switch-al.patch
new file mode 100644
index 0000000000..927670d8b3
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/027-arm64-dts-marvell-espressobin-Add-ethernet-switch-al.patch
@@ -0,0 +1,88 @@
+From b64d814257b027e29a474bcd660f6372490138c7 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 7 Sep 2020 13:27:17 +0200
+Subject: [PATCH] arm64: dts: marvell: espressobin: Add ethernet switch aliases
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Espressobin boards have 3 ethernet ports and some of them got assigned more
+then one MAC address. MAC addresses are stored in U-Boot environment.
+
+Since commit a2c7023f7075c ("net: dsa: read mac address from DT for slave
+device") kernel can use MAC addresses from DT for particular DSA port.
+
+Currently Espressobin DTS file contains alias just for ethernet0.
+
+This patch defines additional ethernet aliases in Espressobin DTS files, so
+bootloader can fill correct MAC address for DSA switch ports if more MAC
+addresses were specified.
+
+DT alias ethernet1 is used for wan port, DT aliases ethernet2 and ethernet3
+are used for lan ports for both Espressobin revisions (V5 and V7).
+
+Fixes: 5253cb8c00a6f ("arm64: dts: marvell: espressobin: add ethernet alias")
+Cc: <stable@vger.kernel.org> # a2c7023f7075c: dsa: read mac address
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Reviewed-by: Andre Heider <a.heider@gmail.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ .../dts/marvell/armada-3720-espressobin-v7-emmc.dts  | 10 ++++++++--
+ .../boot/dts/marvell/armada-3720-espressobin-v7.dts  | 10 ++++++++--
+ 3 files changed, 24 insertions(+), 8 deletions(-)
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7-emmc.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7-emmc.dts
+@@ -15,16 +15,22 @@
+ 	compatible = "globalscale,espressobin-v7-emmc", "globalscale,espressobin-v7",
+ 		     "globalscale,espressobin", "marvell,armada3720",
+ 		     "marvell,armada3710";
++
++	aliases {
++		/* ethernet1 is wan port */
++		ethernet1 = &switch0port3;
++		ethernet3 = &switch0port1;
++	};
+ };
+ 
+ &ports {
+-	port@1 {
++	switch0port1: port@1 {
+ 		reg = <1>;
+ 		label = "lan1";
+ 		phy-handle = <&switch0phy0>;
+ 	};
+ 
+-	port@3 {
++	switch0port3: port@3 {
+ 		reg = <3>;
+ 		label = "wan";
+ 		phy-handle = <&switch0phy2>;
+--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin-v7.dts
+@@ -14,16 +14,22 @@
+ 	model = "Globalscale Marvell ESPRESSOBin Board V7";
+ 	compatible = "globalscale,espressobin-v7", "globalscale,espressobin",
+ 		     "marvell,armada3720", "marvell,armada3710";
++
++	aliases {
++		/* ethernet1 is wan port */
++		ethernet1 = &switch0port3;
++		ethernet3 = &switch0port1;
++	};
+ };
+ 
+ &ports {
+-	port@1 {
++	switch0port1: port@1 {
+ 		reg = <1>;
+ 		label = "lan1";
+ 		phy-handle = <&switch0phy0>;
+ 	};
+ 
+-	port@3 {
++	switch0port3: port@3 {
+ 		reg = <3>;
+ 		label = "wan";
+ 		phy-handle = <&switch0phy2>;
diff --git a/target/linux/mvebu/patches-5.10/028-arm64-dts-mcbin-singleshot-add-heartbeat-LED.patch b/target/linux/mvebu/patches-5.10/028-arm64-dts-mcbin-singleshot-add-heartbeat-LED.patch
new file mode 100644
index 0000000000..c3abae60a6
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/028-arm64-dts-mcbin-singleshot-add-heartbeat-LED.patch
@@ -0,0 +1,65 @@
+From da57203dc7fd556fbb3f0ec7d7d7c0b0e893b386 Mon Sep 17 00:00:00 2001
+From: Tomasz Maciej Nowak <tmn505@gmail.com>
+Date: Tue, 10 Nov 2020 16:38:31 +0100
+Subject: [PATCH] arm64: dts: mcbin-singleshot: add heartbeat LED
+
+With board revision 1.3, SolidRun moved the power LED to the middle of
+the board. In old place of power LED a GPIO controllable heartbeat LED
+was added. This commit only touches Single Shot variant, since only this
+variant is all revision 1.3.
+
+Note:
+This is slightly modified patch. Some boards could be placed in an
+enclosure, so the LED18 is enabled by default, since that'll be the only
+visible indicator that the board is operating.
+
+Reported-by: Alexandra Alth <alexandra@alth.de>
+Signed-off-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ .../marvell/armada-8040-mcbin-singleshot.dts  | 22 +++++++++++++++++++
+ 1 file changed, 22 insertions(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-8040-mcbin-singleshot.dts
++++ b/arch/arm64/boot/dts/marvell/armada-8040-mcbin-singleshot.dts
+@@ -5,6 +5,8 @@
+  * Device Tree file for MACCHIATOBin Armada 8040 community board platform
+  */
+ 
++#include <dt-bindings/leds/common.h>
++
+ #include "armada-8040-mcbin.dtsi"
+ 
+ / {
+@@ -12,6 +14,20 @@
+ 	compatible = "marvell,armada8040-mcbin-singleshot",
+ 			"marvell,armada8040-mcbin", "marvell,armada8040",
+ 			"marvell,armada-ap806-quad", "marvell,armada-ap806";
++
++	leds {
++		compatible = "gpio-leds";
++		pinctrl-0 = <&cp0_led18_pins>;
++		pinctrl-names = "default";
++
++		led18 {
++			gpios = <&cp0_gpio2 1 GPIO_ACTIVE_LOW>;
++			function = LED_FUNCTION_HEARTBEAT;
++			color = <LED_COLOR_ID_GREEN>;
++			linux,default-trigger = "heartbeat";
++			default-state = "on";
++		};
++	};
+ };
+ 
+ &cp0_eth0 {
+@@ -27,3 +43,10 @@
+ 	managed = "in-band-status";
+ 	sfp = <&sfp_eth1>;
+ };
++
++&cp0_pinctrl {
++	cp0_led18_pins: led18-pins {
++		marvell,pins = "mpp33";
++		marvell,function = "gpio";
++	};
++};
diff --git a/target/linux/mvebu/patches-5.10/300-mvebu-Mangle-bootloader-s-kernel-arguments.patch b/target/linux/mvebu/patches-5.10/300-mvebu-Mangle-bootloader-s-kernel-arguments.patch
new file mode 100644
index 0000000000..fd60cdb322
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/300-mvebu-Mangle-bootloader-s-kernel-arguments.patch
@@ -0,0 +1,208 @@
+From 71270226b14733a4b1f2cde58ea9265caa50b38d Mon Sep 17 00:00:00 2001
+From: Adrian Panella <ianchi74@outlook.com>
+Date: Thu, 9 Mar 2017 09:37:17 +0100
+Subject: [PATCH 67/69] generic: Mangle bootloader's kernel arguments
+
+The command-line arguments provided by the boot loader will be
+appended to a new device tree property: bootloader-args.
+If there is a property "append-rootblock" in DT under /chosen
+and a root= option in bootloaders command line it will be parsed
+and added to DT bootargs with the form: <append-rootblock>XX.
+Only command line ATAG will be processed, the rest of the ATAGs
+sent by bootloader will be ignored.
+This is usefull in dual boot systems, to get the current root partition
+without afecting the rest of the system.
+
+Signed-off-by: Adrian Panella <ianchi74@outlook.com>
+
+This patch has been modified to be mvebu specific. The original patch 
+did not pass the bootloader cmdline on if no append-rootblock stanza 
+was found, resulting in blank cmdline and failure to boot.
+
+Signed-off-by: Michael Gray <michael.gray@lantisproject.com>
+---
+ arch/arm/Kconfig                        | 11 ++++
+ arch/arm/boot/compressed/atags_to_fdt.c | 85 ++++++++++++++++++++++++-
+ init/main.c                             | 16 +++++
+ 3 files changed, 111 insertions(+), 1 deletion(-)
+
+--- a/arch/arm/Kconfig
++++ b/arch/arm/Kconfig
+@@ -1827,6 +1827,17 @@ config ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEN
+ 	  The command-line arguments provided by the boot loader will be
+ 	  appended to the the device tree bootargs property.
+ 
++config ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE
++	bool "Append rootblock parsing bootloader's kernel arguments"
++	help
++	  The command-line arguments provided by the boot loader will be
++	  appended to a new device tree property: bootloader-args.
++	  If there is a property "append-rootblock" in DT under /chosen 
++	  and a root= option in bootloaders command line it will be parsed 
++	  and added to DT bootargs with the form: <append-rootblock>XX.
++	  Only command line ATAG will be processed, the rest of the ATAGs
++	  sent by bootloader will be ignored.
++
+ endchoice
+ 
+ config CMDLINE
+--- a/arch/arm/boot/compressed/atags_to_fdt.c
++++ b/arch/arm/boot/compressed/atags_to_fdt.c
+@@ -4,6 +4,8 @@
+ 
+ #if defined(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND)
+ #define do_extend_cmdline 1
++#elif defined(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE)
++#define do_extend_cmdline 1
+ #else
+ #define do_extend_cmdline 0
+ #endif
+@@ -67,6 +69,72 @@ static uint32_t get_cell_size(const void
+ 	return cell_size;
+ }
+ 
++#if defined(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE)
++
++static char *append_rootblock(char *dest, const char *str, int len, void *fdt)
++{
++	char *ptr, *end;
++	char *root="root=";
++	int i, l;
++	const char *rootblock;
++
++	//ARM doesn't have __HAVE_ARCH_STRSTR, so search manually
++	ptr = str - 1;
++
++	do {
++		//first find an 'r' at the begining or after a space
++		do {
++			ptr++;
++			ptr = strchr(ptr, 'r');
++			if (!ptr)
++				goto no_append;
++
++		} while (ptr != str && *(ptr-1) != ' ');
++
++		//then check for the rest
++		for(i = 1; i <= 4; i++)
++			if(*(ptr+i) != *(root+i)) break;
++
++	} while (i != 5);
++
++	end = strchr(ptr, ' ');
++	end = end ? (end - 1) : (strchr(ptr, 0) - 1);
++
++	//find partition number (assumes format root=/dev/mtdXX | /dev/mtdblockXX | yy:XX )
++	for( i = 0; end >= ptr && *end >= '0' && *end <= '9'; end--, i++);
++	ptr = end + 1;
++
++	/* if append-rootblock property is set use it to append to command line */
++	rootblock = getprop(fdt, "/chosen", "append-rootblock", &l);
++	if (rootblock == NULL)
++		goto no_append;
++
++	if (*dest != ' ') {
++		*dest = ' ';
++		dest++;
++		len++;
++	}
++
++	if (len + l + i <= COMMAND_LINE_SIZE) {
++		memcpy(dest, rootblock, l);
++		dest += l - 1;
++		memcpy(dest, ptr, i);
++		dest += i;
++	}
++
++	return dest;
++
++no_append:
++	len = strlen(str);
++	if (len + 1 < COMMAND_LINE_SIZE) {
++		memcpy(dest, str, len);
++		dest += len;
++	}
++
++	return dest;
++}
++#endif
++
+ static void merge_fdt_bootargs(void *fdt, const char *fdt_cmdline)
+ {
+ 	char cmdline[COMMAND_LINE_SIZE];
+@@ -86,12 +154,21 @@ static void merge_fdt_bootargs(void *fdt
+ 
+ 	/* and append the ATAG_CMDLINE */
+ 	if (fdt_cmdline) {
++
++#if defined(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE)
++		//save original bootloader args
++		//and append ubi.mtd with root partition number to current cmdline
++		setprop_string(fdt, "/chosen", "bootloader-args", fdt_cmdline);
++		ptr = append_rootblock(ptr, fdt_cmdline, len, fdt);
++
++#else
+ 		len = strlen(fdt_cmdline);
+ 		if (ptr - cmdline + len + 2 < COMMAND_LINE_SIZE) {
+ 			*ptr++ = ' ';
+ 			memcpy(ptr, fdt_cmdline, len);
+ 			ptr += len;
+ 		}
++#endif
+ 	}
+ 	*ptr = '\0';
+ 
+@@ -166,7 +243,9 @@ int atags_to_fdt(void *atag_list, void *
+ 			else
+ 				setprop_string(fdt, "/chosen", "bootargs",
+ 					       atag->u.cmdline.cmdline);
+-		} else if (atag->hdr.tag == ATAG_MEM) {
++		}
++#ifndef CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE
++		else if (atag->hdr.tag == ATAG_MEM) {
+ 			if (memcount >= sizeof(mem_reg_property)/4)
+ 				continue;
+ 			if (!atag->u.mem.size)
+@@ -210,6 +289,10 @@ int atags_to_fdt(void *atag_list, void *
+ 		setprop(fdt, "/memory", "reg", mem_reg_property,
+ 			4 * memcount * memsize);
+ 	}
++#else
++
++	}
++#endif
+ 
+ 	return fdt_pack(fdt);
+ }
+--- a/init/main.c
++++ b/init/main.c
+@@ -104,6 +104,10 @@
+ #define CREATE_TRACE_POINTS
+ #include <trace/events/initcall.h>
+ 
++#if defined(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE)
++#include <linux/of.h>
++#endif
++
+ static int kernel_init(void *);
+ 
+ extern void init_IRQ(void);
+@@ -631,6 +635,18 @@ asmlinkage __visible void __init start_k
+ 	page_alloc_init();
+ 
+ 	pr_notice("Kernel command line: %s\n", boot_command_line);
++
++#if defined(CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_MANGLE)
++	//Show bootloader's original command line for reference
++	if(of_chosen) {
++		const char *prop = of_get_property(of_chosen, "bootloader-args", NULL);
++		if(prop)
++			pr_notice("Bootloader command line (ignored): %s\n", prop);
++		else
++			pr_notice("Bootloader command line not present\n");
++	}
++#endif
++
+ 	/* parameters may set static keys */
+ 	jump_label_init();
+ 	parse_early_param();
diff --git a/target/linux/mvebu/patches-5.10/301-mvebu-armada-38x-enable-libata-leds.patch b/target/linux/mvebu/patches-5.10/301-mvebu-armada-38x-enable-libata-leds.patch
new file mode 100644
index 0000000000..b8ab700c97
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/301-mvebu-armada-38x-enable-libata-leds.patch
@@ -0,0 +1,10 @@
+--- a/arch/arm/mach-mvebu/Kconfig
++++ b/arch/arm/mach-mvebu/Kconfig
+@@ -69,6 +69,7 @@ config MACH_ARMADA_38X
+ 	select HAVE_SMP
+ 	select MACH_MVEBU_V7
+ 	select PINCTRL_ARMADA_38X
++	select ARCH_WANT_LIBATA_LEDS
+ 	help
+ 	  Say 'Y' here if you want your kernel to support boards based
+ 	  on the Marvell Armada 380/385 SoC with device tree.
diff --git a/target/linux/mvebu/patches-5.10/302-add_powertables.patch b/target/linux/mvebu/patches-5.10/302-add_powertables.patch
new file mode 100644
index 0000000000..efbbbc7d78
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/302-add_powertables.patch
@@ -0,0 +1,770 @@
+--- a/arch/arm/boot/dts/armada-385-linksys.dtsi
++++ b/arch/arm/boot/dts/armada-385-linksys.dtsi
+@@ -212,11 +212,19 @@
+ &pcie1 {
+ 	/* Marvell 88W8864, 5GHz-only */
+ 	status = "okay";
++
++	mwlwifi {
++		marvell,2ghz = <0>;
++	};
+ };
+ 
+ &pcie2 {
+ 	/* Marvell 88W8864, 2GHz-only */
+ 	status = "okay";
++
++	mwlwifi {
++		marvell,5ghz = <0>;
++	};
+ };
+ 
+ &pinctrl {
+--- a/arch/arm/boot/dts/armada-385-linksys-caiman.dts
++++ b/arch/arm/boot/dts/armada-385-linksys-caiman.dts
+@@ -142,3 +142,205 @@
+ 		};
+ 	};
+ };
++
++&pcie1 {
++	mwlwifi {
++		marvell,chainmask = <2 2>;
++		marvell,powertable {
++			AU =
++				<36 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<40 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<44 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<48 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<52 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<56 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<60 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<64 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<100 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<104 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<108 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<112 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<116 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<120 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<124 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<128 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<132 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<136 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<140 0 0x17 0x17 0x17 0x17 0x17 0x17 0x17 0x15 0x17 0x17 0x17 0x14 0x17 0x17 0x17 0x14 0 0xf>,
++				<149 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x1a 0x1a 0x17 0x14 0 0xf>,
++				<153 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x1a 0x1a 0x17 0x14 0 0xf>,
++				<157 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x1a 0x1a 0x17 0x14 0 0xf>,
++				<161 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x1a 0x1a 0x17 0x14 0 0xf>,
++				<165 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x1a 0x1a 0x17 0x14 0 0xf>;
++			CA =
++				<36 0 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0 0xf>,
++				<40 0 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0 0xf>,
++				<44 0 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0 0xf>,
++				<48 0 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0 0xf>,
++				<52 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<56 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<60 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<64 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<100 0 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<104 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<108 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<112 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<116 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<120 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<124 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<128 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<132 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<136 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<140 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<149 0 0x1a 0x1a 0x18 0x17 0x19 0x19 0x17 0x15 0x18 0x18 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>,
++				<153 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>,
++				<157 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>,
++				<161 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>,
++				<165 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>;
++			CN =
++				<36 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<40 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<44 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<48 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<52 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<56 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<60 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<64 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<100 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<104 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<108 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<112 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<116 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<120 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<124 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<128 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<132 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<136 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<140 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<149 0 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0x11 0x11 0x11 0x11 0 0xf>,
++				<153 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0 0xf>,
++				<157 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0 0xf>,
++				<161 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0 0xf>,
++				<165 0 0x15 0x15 0x15 0x15 0x16 0x16 0x16 0x15 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0 0xf>;
++			ETSI =
++				<36 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<40 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<44 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<48 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<52 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<56 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<60 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<64 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<100 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<104 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<108 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<112 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<116 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<120 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<124 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<128 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<132 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<136 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<140 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>,
++				<149 0 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0 0xf>;
++			FCC =
++				<36 0 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<40 0 0x19 0x19 0x18 0x17 0x19 0x19 0x17 0x15 0x17 0x17 0x17 0x14 0x10 0x10 0x10 0x10 0 0xf>,
++				<44 0 0x19 0x19 0x18 0x17 0x19 0x19 0x17 0x15 0x17 0x17 0x17 0x14 0x10 0x10 0x10 0x10 0 0xf>,
++				<48 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x17 0x17 0x17 0x14 0x10 0x10 0x10 0x10 0 0xf>,
++				<52 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<56 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<60 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<64 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<100 0 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<104 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<108 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<112 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<116 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<120 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<124 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<128 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<132 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<136 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<140 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<149 0 0x1a 0x1a 0x18 0x17 0x19 0x19 0x17 0x15 0x18 0x18 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>,
++				<153 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>,
++				<157 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>,
++				<161 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>,
++				<165 0 0x1a 0x1a 0x18 0x17 0x1a 0x1a 0x17 0x15 0x1a 0x1a 0x17 0x14 0x15 0x15 0x15 0x14 0 0xf>;
++		};
++	};
++};
++
++&pcie2 {
++	mwlwifi {
++		marvell,chainmask = <2 2>;
++		marvell,powertable {
++			AU =
++				<1 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>;
++			CA =
++				<1 0 0x19 0x14 0x14 0x14 0x13 0x13 0x13 0x13 0x10 0x10 0x10 0x10 0x00 0x00 0x00 0x00 0 0xf>,
++				<2 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x00 0x00 0x00 0x00 0 0xf>,
++				<3 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x00 0x00 0x00 0x00 0 0xf>,
++				<4 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x00 0x00 0x00 0x00 0 0xf>,
++				<5 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x00 0x00 0x00 0x00 0 0xf>,
++				<6 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x00 0x00 0x00 0x00 0 0xf>,
++				<7 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x00 0x00 0x00 0x00 0 0xf>,
++				<8 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x00 0x00 0x00 0x00 0 0xf>,
++				<9 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x00 0x00 0x00 0x00 0 0xf>,
++				<10 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x00 0x00 0x00 0x00 0 0xf>,
++				<11 0 0x19 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0x13 0x13 0x13 0x13 0x00 0x00 0x00 0x00 0 0xf>;
++			CN =
++				<1 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<12 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<13 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<14 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>;
++			ETSI =
++				<1 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<12 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>,
++				<13 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0x0 0x0 0x0 0x0 0 0xf>;
++			FCC =
++				<1 0 0x19 0x14 0x14 0x14 0x13 0x13 0x13 0x13 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0x1a 0x19 0x18 0x17 0x19 0x19 0x17 0x16 0x14 0x14 0x14 0x14 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0x19 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0x13 0x13 0x13 0x13 0x0 0x0 0x0 0x0 0 0xf>;
++		};
++	};
++};
+--- a/arch/arm/boot/dts/armada-385-linksys-cobra.dts
++++ b/arch/arm/boot/dts/armada-385-linksys-cobra.dts
+@@ -142,3 +142,205 @@
+ 		};
+ 	};
+ };
++
++&pcie1 {
++	mwlwifi {
++		marvell,chainmask = <4 4>;
++		marvell,powertable {
++			AU =
++				<36 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<40 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<44 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<48 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<52 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<56 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<60 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<64 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<100 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<104 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<108 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<112 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<116 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<120 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<124 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<128 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<132 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<136 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<140 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<149 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>,
++				<153 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>,
++				<157 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>,
++				<161 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>,
++				<165 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>;
++			CA =
++				<36 0 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++				<40 0 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++				<44 0 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++				<48 0 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++				<52 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<56 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<60 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<64 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<100 0 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<104 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<108 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<112 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<116 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<120 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<124 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<128 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<132 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<136 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<140 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<149 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<153 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<157 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<161 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<165 0 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>;
++			CN =
++				<36 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<40 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<44 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<48 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<52 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<56 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<60 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<64 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<100 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<104 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<108 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<112 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<116 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<120 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<124 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<128 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<132 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<136 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<140 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<149 0 0x14 0x14 0x14 0x14 0x13 0x13 0x13 0x13 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<153 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0x10 0x10 0x10 0x10 0 0xf>,
++				<157 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0x10 0x10 0x10 0x10 0 0xf>,
++				<161 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0x10 0x10 0x10 0x10 0 0xf>,
++				<165 0 0x13 0x13 0x13 0x13 0x13 0x13 0x13 0x13 0x14 0x14 0x14 0x14 0x10 0x10 0x10 0x10 0 0xf>;
++			ETSI =
++				<36 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<40 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<44 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<48 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<52 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<56 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<60 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<64 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<100 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<104 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<108 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<112 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<116 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<120 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<124 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<128 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<132 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<136 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<140 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<149 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>;
++			FCC =
++				<36 0 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0xf 0xf 0xf 0xf 0 0xf>,
++				<40 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0xf 0xf 0xf 0xf 0 0xf>,
++				<44 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0xf 0xf 0xf 0xf 0 0xf>,
++				<48 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0xf 0xf 0xf 0xf 0 0xf>,
++				<52 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<56 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<60 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<64 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<100 0 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<104 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<108 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<112 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<116 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<120 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<124 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<128 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<132 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<136 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<140 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<149 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<153 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<157 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<161 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<165 0 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>;
++		};
++	};
++};
++
++&pcie2 {
++	mwlwifi {
++		marvell,chainmask = <4 4>;
++		marvell,powertable {
++			AU =
++				<1 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>;
++			CA =
++				<1 0 0x17 0x10 0x10 0x10 0xf 0xf 0xf 0xf 0xe 0xe 0xe 0xe 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0x17 0x12 0x12 0x12 0x13 0x13 0x13 0x13 0xf 0xf 0xf 0xf 0x0 0x0 0x0 0x0 0 0xf>;
++			CN =
++				<1 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<12 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<13 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<14 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>;
++			ETSI =
++				<1 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<12 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<13 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>;
++			FCC =
++				<1 0 0x17 0x10 0x10 0x10 0xf 0xf 0xf 0xf 0xe 0xe 0xe 0xe 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0x17 0x12 0x12 0x12 0x13 0x13 0x13 0x13 0xf 0xf 0xf 0xf 0x0 0x0 0x0 0x0 0 0xf>;
++		};
++	};
++};
+--- a/arch/arm/boot/dts/armada-385-linksys-shelby.dts
++++ b/arch/arm/boot/dts/armada-385-linksys-shelby.dts
+@@ -142,3 +142,205 @@
+ 		};
+ 	};
+ };
++
++&pcie1 {
++	mwlwifi {
++		marvell,chainmask = <4 4>;
++		marvell,powertable {
++			AU =
++				<36 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<40 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<44 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<48 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<52 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<56 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<60 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<64 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<100 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<104 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<108 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<112 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<116 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<120 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<124 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<128 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<132 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<136 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<140 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++				<149 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>,
++				<153 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>,
++				<157 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>,
++				<161 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>,
++				<165 0 0x19 0x19 0x19 0x17 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0x19 0x19 0x16 0x15 0 0xf>;
++			CA =
++				<36 0 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++				<40 0 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++				<44 0 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++				<48 0 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++				<52 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<56 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<60 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<64 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<100 0 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<104 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<108 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<112 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<116 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<120 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<124 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<128 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<132 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<136 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<140 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<149 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<153 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<157 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<161 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<165 0 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>;
++			CN =
++				<36 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<40 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<44 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<48 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<52 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<56 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<60 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<64 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<100 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<104 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<108 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<112 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<116 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<120 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<124 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<128 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<132 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<136 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<140 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<149 0 0x14 0x14 0x14 0x14 0x13 0x13 0x13 0x13 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<153 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0x10 0x10 0x10 0x10 0 0xf>,
++				<157 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0x10 0x10 0x10 0x10 0 0xf>,
++				<161 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0x10 0x10 0x10 0x10 0 0xf>,
++				<165 0 0x13 0x13 0x13 0x13 0x13 0x13 0x13 0x13 0x14 0x14 0x14 0x14 0x10 0x10 0x10 0x10 0 0xf>;
++			ETSI =
++				<36 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<40 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<44 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<48 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<52 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<56 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<60 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<64 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<100 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<104 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<108 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<112 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<116 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<120 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<124 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<128 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<132 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<136 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<140 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>,
++				<149 0 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xd 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0xe 0 0xf>;
++			FCC =
++				<36 0 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0xf 0xf 0xf 0xf 0 0xf>,
++				<40 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0xf 0xf 0xf 0xf 0 0xf>,
++				<44 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0xf 0xf 0xf 0xf 0 0xf>,
++				<48 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0xf 0xf 0xf 0xf 0 0xf>,
++				<52 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<56 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<60 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<64 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<100 0 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<104 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x12 0x12 0x12 0x12 0x10 0x10 0x10 0x10 0 0xf>,
++				<108 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<112 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<116 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<120 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<124 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<128 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<132 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<136 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<140 0 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0 0xf>,
++				<149 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<153 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<157 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<161 0 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>,
++				<165 0 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0 0xf>;
++		};
++	};
++};
++
++&pcie2 {
++	mwlwifi {
++		marvell,chainmask = <4 4>;
++		marvell,powertable {
++			AU =
++				<1 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>;
++			CA =
++				<1 0 0x17 0x10 0x10 0x10 0xf 0xf 0xf 0xf 0xe 0xe 0xe 0xe 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0x17 0x12 0x12 0x12 0x13 0x13 0x13 0x13 0xf 0xf 0xf 0xf 0x0 0x0 0x0 0x0 0 0xf>;
++			CN =
++				<1 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<12 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<13 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<14 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>;
++			ETSI =
++				<1 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<12 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>,
++				<13 0 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0xa 0x0 0x0 0x0 0x0 0 0xf>;
++			FCC =
++				<1 0 0x17 0x10 0x10 0x10 0xf 0xf 0xf 0xf 0xe 0xe 0xe 0xe 0x0 0x0 0x0 0x0 0 0xf>,
++				<2 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<3 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<4 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<5 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<6 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<7 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<8 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<9 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<10 0 0x18 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x11 0x11 0x11 0x11 0x0 0x0 0x0 0x0 0 0xf>,
++				<11 0 0x17 0x12 0x12 0x12 0x13 0x13 0x13 0x13 0xf 0xf 0xf 0xf 0x0 0x0 0x0 0x0 0 0xf>;
++		};
++	};
++};
+--- a/arch/arm/boot/dts/armada-385-linksys-rango.dts
++++ b/arch/arm/boot/dts/armada-385-linksys-rango.dts
+@@ -157,6 +157,18 @@
+ 	};
+ };
+ 
++&pcie1 {
++	mwlwifi {
++		marvell,chainmask = <4 4>;
++	};
++};
++
++&pcie2 {
++	mwlwifi {
++		marvell,chainmask = <4 4>;
++	};
++};
++
+ &sdhci {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&sdhci_pins>;
+--- a/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
++++ b/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
+@@ -225,12 +225,100 @@
+ 	pcie@2,0 {
+ 		/* Port 0, Lane 1 */
+ 		status = "okay";
++
++		mwlwifi {
++			marvell,5ghz = <0>;
++			marvell,chainmask = <4 4>;
++			marvell,powertable {
++				FCC =
++					<1 0 0x17 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0xf 0xf 0xf 0xf 0x0 0x0 0x0 0x0 0 0xf>,
++					<2 0 0x17 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++					<3 0 0x17 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++					<4 0 0x17 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++					<5 0 0x17 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++					<6 0 0x17 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++					<7 0 0x17 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++					<8 0 0x17 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++					<9 0 0x17 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++					<10 0 0x17 0x16 0x16 0x16 0x16 0x16 0x16 0x14 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>,
++					<11 0 0x17 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x10 0x10 0x10 0x10 0x0 0x0 0x0 0x0 0 0xf>;
++
++				ETSI =
++					<1 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<2 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<3 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<4 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<5 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<6 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<7 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<8 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<9 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<10 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<11 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<12 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>,
++					<13 0 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0xb 0x0 0x0 0x0 0x0 0 0xf>;
++			};
++		};
+ 	};
+ 
+ 	/* Second mini-PCIe port */
+ 	pcie@3,0 {
+ 		/* Port 0, Lane 3 */
+ 		status = "okay";
++
++		mwlwifi {
++			marvell,2ghz = <0>;
++			marvell,chainmask = <4 4>;
++			marvell,powertable {
++				FCC =
++					<36 0 0x8 0x8 0x8 0x8 0x8 0x8 0x8 0x8 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++					<40 0 0x8 0x8 0x8 0x8 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++					<44 0 0x8 0x8 0x8 0x8 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++					<48 0 0x8 0x8 0x8 0x8 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0x9 0 0xf>,
++					<52 0 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0 0xf>,
++					<56 0 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0 0xf>,
++					<60 0 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0 0xf>,
++					<64 0 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0xf 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0x12 0 0xf>,
++					<100 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<104 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<108 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<112 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<116 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<120 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<124 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<128 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<132 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<136 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<140 0 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0x14 0 0xf>,
++					<149 0 0x16 0x16 0x16 0x16 0x14 0x14 0x14 0x14 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0 0xf>,
++					<153 0 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0 0xf>,
++					<157 0 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0 0xf>,
++					<161 0 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0 0xf>,
++					<165 0 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x16 0x15 0x15 0x15 0x15 0x14 0x14 0x14 0x14 0 0xf>;
++
++				ETSI =
++					<36 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<40 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<44 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<48 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<52 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<56 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<60 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<64 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<100 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<104 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<108 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<112 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<116 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<120 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<124 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<128 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<132 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<136 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<140 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>,
++					<149 0 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xc 0xd 0xd 0xd 0xd 0xc 0xc 0xc 0xc 0 0xf>;
++			};
++		};
+ 	};
+ };
+ 
diff --git a/target/linux/mvebu/patches-5.10/303-linksys_hardcode_nand_ecc_settings.patch b/target/linux/mvebu/patches-5.10/303-linksys_hardcode_nand_ecc_settings.patch
new file mode 100644
index 0000000000..89a5e19803
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/303-linksys_hardcode_nand_ecc_settings.patch
@@ -0,0 +1,17 @@
+Newer Linksys boards might come with a Winbond W29N02GV which can be
+configured in different ways. Make sure we configure it the same way
+as the older chips so everything keeps working.
+
+Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
+
+--- a/arch/arm/boot/dts/armada-385-linksys.dtsi
++++ b/arch/arm/boot/dts/armada-385-linksys.dtsi
+@@ -148,6 +148,8 @@
+ 		reg = <0>;
+ 		label = "pxa3xx_nand-0";
+ 		nand-rb = <0>;
++		nand-ecc-strength = <4>;
++		nand-ecc-step-size = <512>;
+ 		marvell,nand-keep-config;
+ 		nand-on-flash-bbt;
+ 	};
diff --git a/target/linux/mvebu/patches-5.10/304-revert_i2c_delay.patch b/target/linux/mvebu/patches-5.10/304-revert_i2c_delay.patch
new file mode 100644
index 0000000000..930c0f9494
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/304-revert_i2c_delay.patch
@@ -0,0 +1,15 @@
+--- a/arch/arm/boot/dts/armada-xp.dtsi
++++ b/arch/arm/boot/dts/armada-xp.dtsi
+@@ -237,12 +237,10 @@
+ };
+ 
+ &i2c0 {
+-	compatible = "marvell,mv78230-i2c", "marvell,mv64xxx-i2c";
+ 	reg = <0x11000 0x100>;
+ };
+ 
+ &i2c1 {
+-	compatible = "marvell,mv78230-i2c", "marvell,mv64xxx-i2c";
+ 	reg = <0x11100 0x100>;
+ };
+ 
diff --git a/target/linux/mvebu/patches-5.10/305-armada-385-rd-mtd-partitions.patch b/target/linux/mvebu/patches-5.10/305-armada-385-rd-mtd-partitions.patch
new file mode 100644
index 0000000000..31bd53b1f3
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/305-armada-385-rd-mtd-partitions.patch
@@ -0,0 +1,19 @@
+--- a/arch/arm/boot/dts/armada-388-rd.dts
++++ b/arch/arm/boot/dts/armada-388-rd.dts
+@@ -103,6 +103,16 @@
+ 		compatible = "st,m25p128", "jedec,spi-nor";
+ 		reg = <0>; /* Chip select 0 */
+ 		spi-max-frequency = <108000000>;
++
++		partition@0 {
++			label = "uboot";
++			reg = <0 0x400000>;
++		};
++
++		partition@1 {
++			label = "firmware";
++			reg = <0x400000 0xc00000>;
++		};
+ 	};
+ };
+ 
diff --git a/target/linux/mvebu/patches-5.10/306-ARM-mvebu-385-ap-Add-partitions.patch b/target/linux/mvebu/patches-5.10/306-ARM-mvebu-385-ap-Add-partitions.patch
new file mode 100644
index 0000000000..2057e31c7e
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/306-ARM-mvebu-385-ap-Add-partitions.patch
@@ -0,0 +1,35 @@
+From 9861f93a59142a3131870df2521eb2deb73026d7 Mon Sep 17 00:00:00 2001
+From: Maxime Ripard <maxime.ripard@free-electrons.com>
+Date: Tue, 13 Jan 2015 11:14:09 +0100
+Subject: [PATCH 2/2] ARM: mvebu: 385-ap: Add partitions
+
+Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
+---
+ arch/arm/boot/dts/armada-385-db-ap.dts | 15 +++++++++++++++
+ 1 file changed, 15 insertions(+)
+
+--- a/arch/arm/boot/dts/armada-385-db-ap.dts
++++ b/arch/arm/boot/dts/armada-385-db-ap.dts
+@@ -218,19 +218,19 @@
+ 			#size-cells = <1>;
+ 
+ 			partition@0 {
+-				label = "U-Boot";
++				label = "u-boot";
+ 				reg = <0x00000000 0x00800000>;
+ 				read-only;
+ 			};
+ 
+ 			partition@800000 {
+-				label = "uImage";
++				label = "kernel";
+ 				reg = <0x00800000 0x00400000>;
+ 				read-only;
+ 			};
+ 
+ 			partition@c00000 {
+-				label = "Root";
++				label = "ubi";
+ 				reg = <0x00c00000 0x3f400000>;
+ 			};
+ 		};
diff --git a/target/linux/mvebu/patches-5.10/307-armada-xp-linksys-mamba-broken-idle.patch b/target/linux/mvebu/patches-5.10/307-armada-xp-linksys-mamba-broken-idle.patch
new file mode 100644
index 0000000000..16112d53fc
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/307-armada-xp-linksys-mamba-broken-idle.patch
@@ -0,0 +1,10 @@
+--- a/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
++++ b/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
+@@ -485,3 +485,7 @@
+ 		};
+ 	};
+ };
++
++&coherencyfab {
++	broken-idle;
++};
diff --git a/target/linux/mvebu/patches-5.10/308-armada-xp-linksys-mamba-wan.patch b/target/linux/mvebu/patches-5.10/308-armada-xp-linksys-mamba-wan.patch
new file mode 100644
index 0000000000..4315abc7d2
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/308-armada-xp-linksys-mamba-wan.patch
@@ -0,0 +1,11 @@
+--- a/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
++++ b/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
+@@ -387,7 +387,7 @@
+ 
+ 			port@4 {
+ 				reg = <4>;
+-				label = "internet";
++				label = "wan";
+ 			};
+ 
+ 			port@5 {
diff --git a/target/linux/mvebu/patches-5.10/309-linksys-status-led.patch b/target/linux/mvebu/patches-5.10/309-linksys-status-led.patch
new file mode 100644
index 0000000000..e5e83572c9
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/309-linksys-status-led.patch
@@ -0,0 +1,50 @@
+--- a/arch/arm/boot/dts/armada-385-linksys.dtsi
++++ b/arch/arm/boot/dts/armada-385-linksys.dtsi
+@@ -14,6 +14,13 @@
+ 	compatible = "linksys,armada385", "marvell,armada385",
+ 		     "marvell,armada380";
+ 
++	aliases {
++		led-boot = &led_power;
++		led-failsafe = &led_power;
++		led-running = &led_power;
++		led-upgrade = &led_power;
++	};
++
+ 	chosen {
+ 		stdout-path = "serial0:115200n8";
+ 	};
+@@ -71,7 +78,7 @@
+ 		pinctrl-0 = <&gpio_leds_pins>;
+ 		pinctrl-names = "default";
+ 
+-		power {
++		led_power: power {
+ 			gpios = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+ 			default-state = "on";
+ 		};
+--- a/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
++++ b/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
+@@ -26,6 +26,13 @@
+ 	compatible = "linksys,mamba", "marvell,armadaxp-mv78230",
+ 		     "marvell,armadaxp", "marvell,armada-370-xp";
+ 
++	aliases {
++		led-boot = &led_power;
++		led-failsafe = &led_power;
++		led-running = &led_power;
++		led-upgrade = &led_power;
++	};
++
+ 	chosen {
+ 		bootargs = "console=ttyS0,115200";
+ 		stdout-path = &uart0;
+@@ -197,7 +204,7 @@
+ 		pinctrl-0 = <&power_led_pin>;
+ 		pinctrl-names = "default";
+ 
+-		power {
++		led_power: power {
+ 			label = "mamba:white:power";
+ 			gpios = <&gpio1 8 GPIO_ACTIVE_HIGH>;
+ 			default-state = "on";
diff --git a/target/linux/mvebu/patches-5.10/310-linksys-use-eth0-as-cpu-port.patch b/target/linux/mvebu/patches-5.10/310-linksys-use-eth0-as-cpu-port.patch
new file mode 100644
index 0000000000..84d49a004b
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/310-linksys-use-eth0-as-cpu-port.patch
@@ -0,0 +1,25 @@
+--- a/arch/arm/boot/dts/armada-385-linksys.dtsi
++++ b/arch/arm/boot/dts/armada-385-linksys.dtsi
+@@ -116,7 +116,7 @@
+ };
+ 
+ &eth2 {
+-	status = "okay";
++	status = "disabled";
+ 	phy-mode = "sgmii";
+ 	buffer-manager = <&bm>;
+ 	bm,pool-long = <2>;
+@@ -200,10 +200,10 @@
+ 				label = "wan";
+ 			};
+ 
+-			port@5 {
+-				reg = <5>;
++			port@6 {
++				reg = <6>;
+ 				label = "cpu";
+-				ethernet = <&eth2>;
++				ethernet = <&eth0>;
+ 
+ 				fixed-link {
+ 					speed = <1000>;
diff --git a/target/linux/mvebu/patches-5.10/311-adjust-compatible-for-linksys.patch b/target/linux/mvebu/patches-5.10/311-adjust-compatible-for-linksys.patch
new file mode 100644
index 0000000000..a5d3e63810
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/311-adjust-compatible-for-linksys.patch
@@ -0,0 +1,68 @@
+--- a/arch/arm/boot/dts/armada-385-linksys-rango.dts
++++ b/arch/arm/boot/dts/armada-385-linksys-rango.dts
+@@ -12,8 +12,8 @@
+ 
+ / {
+ 	model = "Linksys WRT3200ACM";
+-	compatible = "linksys,rango", "linksys,armada385", "marvell,armada385",
+-		     "marvell,armada380";
++	compatible = "linksys,wrt3200acm", "linksys,rango", "linksys,armada385",
++		     "marvell,armada385", "marvell,armada380";
+ };
+ 
+ &expander0 {
+--- a/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
++++ b/arch/arm/boot/dts/armada-xp-linksys-mamba.dts
+@@ -22,9 +22,10 @@
+ #include "armada-xp-mv78230.dtsi"
+ 
+ / {
+-	model = "Linksys WRT1900AC";
+-	compatible = "linksys,mamba", "marvell,armadaxp-mv78230",
+-		     "marvell,armadaxp", "marvell,armada-370-xp";
++	model = "Linksys WRT1900AC v1";
++	compatible = "linksys,wrt1900ac-v1", "linksys,mamba",
++		     "marvell,armadaxp-mv78230", "marvell,armadaxp",
++		     "marvell,armada-370-xp";
+ 
+ 	aliases {
+ 		led-boot = &led_power;
+--- a/arch/arm/boot/dts/armada-385-linksys-cobra.dts
++++ b/arch/arm/boot/dts/armada-385-linksys-cobra.dts
+@@ -9,8 +9,9 @@
+ #include "armada-385-linksys.dtsi"
+ 
+ / {
+-	model = "Linksys WRT1900ACv2";
+-	compatible = "linksys,cobra", "linksys,armada385", "marvell,armada385",
++	model = "Linksys WRT1900AC v2";
++	compatible = "linksys,wrt1900ac-v2", "linksys,cobra",
++		     "linksys,armada385", "marvell,armada385",
+ 		     "marvell,armada380";
+ };
+ 
+--- a/arch/arm/boot/dts/armada-385-linksys-caiman.dts
++++ b/arch/arm/boot/dts/armada-385-linksys-caiman.dts
+@@ -10,8 +10,8 @@
+ 
+ / {
+ 	model = "Linksys WRT1200AC";
+-	compatible = "linksys,caiman", "linksys,armada385", "marvell,armada385",
+-		     "marvell,armada380";
++	compatible = "linksys,wrt1200ac", "linksys,caiman", "linksys,armada385",
++		     "marvell,armada385", "marvell,armada380";
+ };
+ 
+ &expander0 {
+--- a/arch/arm/boot/dts/armada-385-linksys-shelby.dts
++++ b/arch/arm/boot/dts/armada-385-linksys-shelby.dts
+@@ -10,7 +10,8 @@
+ 
+ / {
+ 	model = "Linksys WRT1900ACS";
+-	compatible = "linksys,shelby", "linksys,armada385", "marvell,armada385",
++	compatible = "linksys,wrt1900acs", "linksys,shelby",
++		     "linksys,armada385", "marvell,armada385",
+ 		     "marvell,armada380";
+ };
+ 
diff --git a/target/linux/mvebu/patches-5.10/312-ARM-dts-armada388-clearfog-emmc-on-clearfog-base.patch b/target/linux/mvebu/patches-5.10/312-ARM-dts-armada388-clearfog-emmc-on-clearfog-base.patch
new file mode 100644
index 0000000000..dd2bef7f63
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/312-ARM-dts-armada388-clearfog-emmc-on-clearfog-base.patch
@@ -0,0 +1,87 @@
+From 8137da20701c776ad3481115305a5e8e410871ba Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 29 Nov 2016 10:15:45 +0000
+Subject: ARM: dts: armada388-clearfog: emmc on clearfog base
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ arch/arm/boot/dts/armada-388-clearfog-base.dts     |  1 +
+ .../dts/armada-38x-solidrun-microsom-emmc.dtsi     | 62 ++++++++++++++++++++++
+ 2 files changed, 63 insertions(+)
+ create mode 100644 arch/arm/boot/dts/armada-38x-solidrun-microsom-emmc.dtsi
+
+--- a/arch/arm/boot/dts/armada-388-clearfog-base.dts
++++ b/arch/arm/boot/dts/armada-388-clearfog-base.dts
+@@ -7,6 +7,7 @@
+ 
+ /dts-v1/;
+ #include "armada-388-clearfog.dtsi"
++#include "armada-38x-solidrun-microsom-emmc.dtsi"
+ 
+ / {
+ 	model = "SolidRun Clearfog Base A1";
+--- /dev/null
++++ b/arch/arm/boot/dts/armada-38x-solidrun-microsom-emmc.dtsi
+@@ -0,0 +1,62 @@
++/*
++ * Device Tree file for SolidRun Armada 38x Microsom add-on for eMMC
++ *
++ *  Copyright (C) 2015 Russell King
++ *
++ * This board is in development; the contents of this file work with
++ * the A1 rev 2.0 of the board, which does not represent final
++ * production board.  Things will change, don't expect this file to
++ * remain compatible info the future.
++ *
++ * This file is dual-licensed: you can use it either under the terms
++ * of the GPL or the X11 license, at your option. Note that this dual
++ * licensing only applies to this file, and not this project as a
++ * whole.
++ *
++ *  a) This file is free software; you can redistribute it and/or
++ *     modify it under the terms of the GNU General Public License
++ *     version 2 as published by the Free Software Foundation.
++ *
++ *     This file is distributed in the hope that it will be useful
++ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *     GNU General Public License for more details.
++ *
++ * Or, alternatively
++ *
++ *  b) Permission is hereby granted, free of charge, to any person
++ *     obtaining a copy of this software and associated documentation
++ *     files (the "Software"), to deal in the Software without
++ *     restriction, including without limitation the rights to use
++ *     copy, modify, merge, publish, distribute, sublicense, and/or
++ *     sell copies of the Software, and to permit persons to whom the
++ *     Software is furnished to do so, subject to the following
++ *     conditions:
++ *
++ *     The above copyright notice and this permission notice shall be
++ *     included in all copies or substantial portions of the Software.
++ *
++ *     THE SOFTWARE IS PROVIDED , WITHOUT WARRANTY OF ANY KIND
++ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
++ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
++ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
++ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY
++ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
++ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
++ *     OTHER DEALINGS IN THE SOFTWARE.
++ */
++/ {
++	soc {
++		internal-regs {
++			sdhci@d8000 {
++				bus-width = <4>;
++				no-1-8-v;
++				non-removable;
++				pinctrl-0 = <&microsom_sdhci_pins>;
++				pinctrl-names = "default";
++				status = "okay";
++				wp-inverted;
++			};
++		};
++	};
++};
diff --git a/target/linux/mvebu/patches-5.10/312-helios4-dts-status-led-alias.patch b/target/linux/mvebu/patches-5.10/312-helios4-dts-status-led-alias.patch
new file mode 100644
index 0000000000..4c4fbec764
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/312-helios4-dts-status-led-alias.patch
@@ -0,0 +1,28 @@
+--- a/arch/arm/boot/dts/armada-388-helios4.dts
++++ b/arch/arm/boot/dts/armada-388-helios4.dts
+@@ -15,6 +15,13 @@
+ 	model = "Helios4";
+ 	compatible = "kobol,helios4", "marvell,armada388",
+ 		"marvell,armada385", "marvell,armada380";
++		
++	aliases {
++		led-boot = &led_status;
++		led-failsafe = &led_status;
++		led-running = &led_status;
++		led-upgrade = &led_status;
++	};
+ 
+ 	memory {
+ 		device_type = "memory";
+@@ -70,10 +77,9 @@
+ 
+ 	system-leds {
+ 		compatible = "gpio-leds";
+-		status-led {
++		led_status: status-led {
+ 			label = "helios4:green:status";
+ 			gpios = <&gpio0 24 GPIO_ACTIVE_LOW>;
+-			linux,default-trigger = "heartbeat";
+ 			default-state = "on";
+ 		};
+ 
diff --git a/target/linux/mvebu/patches-5.10/314-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch b/target/linux/mvebu/patches-5.10/314-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
new file mode 100644
index 0000000000..e989f59d5c
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/314-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
@@ -0,0 +1,20 @@
+From be893f672e340b56ca60f2f6c32fdd713a5852f5 Mon Sep 17 00:00:00 2001
+From: Kevin Mihelich <kevin@archlinuxarm.org>
+Date: Tue, 4 Jul 2017 19:25:28 -0600
+Subject: arm64: dts: marvell: armada37xx: Add eth0 alias
+
+Signed-off-by: Kevin Mihelich <kevin@archlinuxarm.org>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -18,6 +18,7 @@
+ 	#size-cells = <2>;
+ 
+ 	aliases {
++		ethernet0 = &eth0;
+ 		serial0 = &uart0;
+ 		serial1 = &uart1;
+ 	};
diff --git a/target/linux/mvebu/patches-5.10/315-arm64-dts-marvell-armada-3720-espressobin-add-ports-.patch b/target/linux/mvebu/patches-5.10/315-arm64-dts-marvell-armada-3720-espressobin-add-ports-.patch
new file mode 100644
index 0000000000..a741e378d9
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/315-arm64-dts-marvell-armada-3720-espressobin-add-ports-.patch
@@ -0,0 +1,26 @@
+From 6ea9a1ee9367fb35acff1c08a0dc4213ff4687a0 Mon Sep 17 00:00:00 2001
+From: Tomasz Maciej Nowak <tmn505@gmail.com>
+Date: Tue, 9 Apr 2019 15:53:42 +0200
+Subject: [PATCH] arm64: dts: marvell: armada-3720-espressobin: add ports
+ phandle
+
+Instead of referencing the whole mdio node, add ports phandle to adjust
+port labels in dts for different hardware iterations of ESPRESSObin
+boards.
+
+Signed-off-by: Tomasz Maciej Nowak <tmn505@gmail.com>
+---
+ arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts
+@@ -147,7 +147,7 @@
+ 
+ 		dsa,member = <0 0>;
+ 
+-		ports {
++		ports: ports {
+ 			#address-cells = <1>;
+ 			#size-cells = <0>;
+ 
diff --git a/target/linux/mvebu/patches-5.10/316-arm64-dts-uDPU-switch-PHY-operation-mode-to-2500base.patch b/target/linux/mvebu/patches-5.10/316-arm64-dts-uDPU-switch-PHY-operation-mode-to-2500base.patch
new file mode 100644
index 0000000000..2240d0b39e
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/316-arm64-dts-uDPU-switch-PHY-operation-mode-to-2500base.patch
@@ -0,0 +1,34 @@
+Certain SFP modules (most notably Nokia GPON ones) first check
+connectivity on 1000base-x, and switch to 2500base-x afterwards. This
+is considered a quirk so the phylink switches the interface to
+2500base-x as well.
+
+However, after power-cycling the uDPU device, network interface/SFP module
+will not work correctly until the module is re-seated. This patch
+resolves this issue by forcing the interface to be brought up in
+2500base-x mode by default.
+
+Signed-off-by: Jakov Petrina <jakov.petrina@sartura.hr>
+Signed-off-by: Vladimir Vid <vladimir.vid@sartura.hr>
+Cc: Luka Perkov <luka.perkov@sartura.hr>
+
+--- a/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
++++ b/arch/arm64/boot/dts/marvell/armada-3720-uDPU.dts
+@@ -162,7 +162,7 @@
+ };
+ 
+ &eth0 {
+-	phy-mode = "sgmii";
++	phy-mode = "2500base-x";
+ 	status = "okay";
+ 	managed = "in-band-status";
+ 	phys = <&comphy1 0>;
+@@ -170,7 +170,7 @@
+ };
+ 
+ &eth1 {
+-	phy-mode = "sgmii";
++	phy-mode = "2500base-x";
+ 	status = "okay";
+ 	managed = "in-band-status";
+ 	phys = <&comphy0 1>;
diff --git a/target/linux/mvebu/patches-5.10/400-find_active_root.patch b/target/linux/mvebu/patches-5.10/400-find_active_root.patch
new file mode 100644
index 0000000000..854031b0d5
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/400-find_active_root.patch
@@ -0,0 +1,60 @@
+The WRT1900AC among other Linksys routers uses a dual-firmware layout.
+Dynamically rename the active partition to "ubi".
+
+Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
+
+--- a/drivers/mtd/parsers/ofpart.c
++++ b/drivers/mtd/parsers/ofpart.c
+@@ -21,6 +21,8 @@ static bool node_has_compatible(struct d
+ 	return of_get_property(pp, "compatible", NULL);
+ }
+ 
++static int mangled_rootblock;
++
+ static int parse_fixed_partitions(struct mtd_info *master,
+ 				  const struct mtd_partition **pparts,
+ 				  struct mtd_part_parser_data *data)
+@@ -29,6 +31,7 @@ static int parse_fixed_partitions(struct
+ 	struct device_node *mtd_node;
+ 	struct device_node *ofpart_node;
+ 	const char *partname;
++	const char *owrtpart = "ubi";
+ 	struct device_node *pp;
+ 	int nr_parts, i, ret = 0;
+ 	bool dedicated = true;
+@@ -106,9 +109,13 @@ static int parse_fixed_partitions(struct
+ 		parts[i].size = of_read_number(reg + a_cells, s_cells);
+ 		parts[i].of_node = pp;
+ 
+-		partname = of_get_property(pp, "label", &len);
+-		if (!partname)
+-			partname = of_get_property(pp, "name", &len);
++		if (mangled_rootblock && (i == mangled_rootblock)) {
++			partname = owrtpart;
++		} else {
++			partname = of_get_property(pp, "label", &len);
++			if (!partname)
++				partname = of_get_property(pp, "name", &len);
++		}
+ 		parts[i].name = partname;
+ 
+ 		if (of_get_property(pp, "read-only", &len))
+@@ -215,6 +222,18 @@ static int __init ofpart_parser_init(voi
+ 	return 0;
+ }
+ 
++static int __init active_root(char *str)
++{
++	get_option(&str, &mangled_rootblock);
++
++	if (!mangled_rootblock)
++		return 1;
++
++	return 1;
++}
++
++__setup("mangled_rootblock=", active_root);
++
+ static void __exit ofpart_parser_exit(void)
+ {
+ 	deregister_mtd_parser(&ofpart_parser);
diff --git a/target/linux/mvebu/patches-5.10/700-mvneta-tx-queue-workaround.patch b/target/linux/mvebu/patches-5.10/700-mvneta-tx-queue-workaround.patch
new file mode 100644
index 0000000000..a82a4c0d62
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/700-mvneta-tx-queue-workaround.patch
@@ -0,0 +1,34 @@
+The hardware queue scheduling is apparently configured with fixed
+priorities, which creates a nasty fairness issue where traffic from one
+CPU can starve traffic from all other CPUs.
+
+Work around this issue by forcing all tx packets to go through one CPU,
+until this issue is fixed properly.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -4684,6 +4684,14 @@ static int mvneta_ethtool_set_eee(struct
+ 	return phylink_ethtool_set_eee(pp->phylink, eee);
+ }
+ 
++static u16 mvneta_select_queue(struct net_device *dev, struct sk_buff *skb,
++			       struct net_device *sb_dev)
++{
++	/* XXX: hardware queue scheduling is broken,
++	 * use only one queue until it is fixed */
++	return 0;
++}
++
+ static const struct net_device_ops mvneta_netdev_ops = {
+ 	.ndo_open            = mvneta_open,
+ 	.ndo_stop            = mvneta_stop,
+@@ -4694,6 +4702,7 @@ static const struct net_device_ops mvnet
+ 	.ndo_fix_features    = mvneta_fix_features,
+ 	.ndo_get_stats64     = mvneta_get_stats64,
+ 	.ndo_do_ioctl        = mvneta_ioctl,
++	.ndo_select_queue    = mvneta_select_queue,
+ 	.ndo_bpf             = mvneta_xdp,
+ 	.ndo_xdp_xmit        = mvneta_xdp_xmit,
+ };
diff --git a/target/linux/mvebu/patches-5.10/800-cpuidle-mvebu-indicate-failure-to-enter-deeper-sleep.patch b/target/linux/mvebu/patches-5.10/800-cpuidle-mvebu-indicate-failure-to-enter-deeper-sleep.patch
new file mode 100644
index 0000000000..29f36be460
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/800-cpuidle-mvebu-indicate-failure-to-enter-deeper-sleep.patch
@@ -0,0 +1,40 @@
+From c28b2d367da8a471482e6a4aa8337ab6369a80c2 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@arm.linux.org.uk>
+Date: Sat, 3 Oct 2015 09:13:05 +0100
+Subject: cpuidle: mvebu: indicate failure to enter deeper sleep states
+
+The cpuidle ->enter method expects the return value to be the sleep
+state we entered.  Returning negative numbers or other codes is not
+permissible since coupled CPU idle was merged.
+
+At least some of the mvebu_v7_cpu_suspend() implementations return the
+value from cpu_suspend(), which returns zero if the CPU vectors back
+into the kernel via cpu_resume() (the success case), or the non-zero
+return value of the suspend actor, or one (failure cases).
+
+We do not want to be returning the failure case value back to CPU idle
+as that indicates that we successfully entered one of the deeper idle
+states.  Always return zero instead, indicating that we slept for the
+shortest amount of time.
+
+Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
+---
+ drivers/cpuidle/cpuidle-mvebu-v7.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/cpuidle/cpuidle-mvebu-v7.c
++++ b/drivers/cpuidle/cpuidle-mvebu-v7.c
+@@ -39,8 +39,12 @@ static int mvebu_v7_enter_idle(struct cp
+ 	ret = mvebu_v7_cpu_suspend(deepidle);
+ 	cpu_pm_exit();
+ 
++	/*
++	 * If we failed to enter the desired state, indicate that we
++	 * slept lightly.
++	 */
+ 	if (ret)
+-		return ret;
++		return 0;
+ 
+ 	return index;
+ }
diff --git a/target/linux/mvebu/patches-5.10/801-pci-mvebu-time-out-reset-on-link-up.patch b/target/linux/mvebu/patches-5.10/801-pci-mvebu-time-out-reset-on-link-up.patch
new file mode 100644
index 0000000000..4058dc8ed5
--- /dev/null
+++ b/target/linux/mvebu/patches-5.10/801-pci-mvebu-time-out-reset-on-link-up.patch
@@ -0,0 +1,60 @@
+From 287b9df160b6159f8d385424904f8bac501280c1 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Sat, 9 Jul 2016 10:58:16 +0100
+Subject: pci: mvebu: time out reset on link up
+
+If the port reports that the link is up while we are resetting, there's
+little point in waiting for the full duration.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/pci/controller/pci-mvebu.c | 20 ++++++++++++++------
+ 1 file changed, 14 insertions(+), 6 deletions(-)
+
+--- a/drivers/pci/controller/pci-mvebu.c
++++ b/drivers/pci/controller/pci-mvebu.c
+@@ -928,6 +928,7 @@ static int mvebu_pcie_powerup(struct mve
+ 
+ 	if (port->reset_gpio) {
+ 		u32 reset_udelay = PCI_PM_D3COLD_WAIT * 1000;
++		unsigned int i;
+ 
+ 		of_property_read_u32(port->dn, "reset-delay-us",
+ 				     &reset_udelay);
+@@ -935,7 +936,13 @@ static int mvebu_pcie_powerup(struct mve
+ 		udelay(100);
+ 
+ 		gpiod_set_value_cansleep(port->reset_gpio, 0);
+-		msleep(reset_udelay / 1000);
++		for (i = 0; i < reset_udelay; i += 1000) {
++			if (mvebu_pcie_link_up(port))
++				break;
++			msleep(1);
++		}
++
++		printk("%s: reset completed in %dus\n", port->name, i);
+ 	}
+ 
+ 	return 0;
+@@ -1099,15 +1106,16 @@ static int mvebu_pcie_probe(struct platf
+ 		if (!child)
+ 			continue;
+ 
+-		ret = mvebu_pcie_powerup(port);
+-		if (ret < 0)
+-			continue;
+-
+ 		port->base = mvebu_pcie_map_registers(pdev, child, port);
+ 		if (IS_ERR(port->base)) {
+ 			dev_err(dev, "%s: cannot map registers\n", port->name);
+ 			port->base = NULL;
+-			mvebu_pcie_powerdown(port);
++			continue;
++		}
++
++		ret = mvebu_pcie_powerup(port);
++		if (ret < 0) {
++			port->base = NULL;
+ 			continue;
+ 		}
+ 
-- 
2.29.2

